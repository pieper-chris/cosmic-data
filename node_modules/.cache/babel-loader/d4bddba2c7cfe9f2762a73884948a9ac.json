{"ast":null,"code":"'use strict';\n\nvar Queue = require('tinyqueue');\n\nif (Queue.default) Queue = Queue.default; // temporary webpack fix\n\nmodule.exports = polylabel;\nmodule.exports.default = polylabel;\n\nfunction polylabel(polygon, precision, debug) {\n  precision = precision || 1.0; // find the bounding box of the outer ring\n\n  var minX, minY, maxX, maxY;\n\n  for (var i = 0; i < polygon[0].length; i++) {\n    var p = polygon[0][i];\n    if (!i || p[0] < minX) minX = p[0];\n    if (!i || p[1] < minY) minY = p[1];\n    if (!i || p[0] > maxX) maxX = p[0];\n    if (!i || p[1] > maxY) maxY = p[1];\n  }\n\n  var width = maxX - minX;\n  var height = maxY - minY;\n  var cellSize = Math.min(width, height);\n  var h = cellSize / 2;\n\n  if (cellSize === 0) {\n    var degeneratePoleOfInaccessibility = [minX, minY];\n    degeneratePoleOfInaccessibility.distance = 0;\n    return degeneratePoleOfInaccessibility;\n  } // a priority queue of cells in order of their \"potential\" (max distance to polygon)\n\n\n  var cellQueue = new Queue(undefined, compareMax); // cover polygon with initial cells\n\n  for (var x = minX; x < maxX; x += cellSize) {\n    for (var y = minY; y < maxY; y += cellSize) {\n      cellQueue.push(new Cell(x + h, y + h, h, polygon));\n    }\n  } // take centroid as the first best guess\n\n\n  var bestCell = getCentroidCell(polygon); // special case for rectangular polygons\n\n  var bboxCell = new Cell(minX + width / 2, minY + height / 2, 0, polygon);\n  if (bboxCell.d > bestCell.d) bestCell = bboxCell;\n  var numProbes = cellQueue.length;\n\n  while (cellQueue.length) {\n    // pick the most promising cell from the queue\n    var cell = cellQueue.pop(); // update the best cell if we found a better one\n\n    if (cell.d > bestCell.d) {\n      bestCell = cell;\n      if (debug) console.log('found best %d after %d probes', Math.round(1e4 * cell.d) / 1e4, numProbes);\n    } // do not drill down further if there's no chance of a better solution\n\n\n    if (cell.max - bestCell.d <= precision) continue; // split the cell into four cells\n\n    h = cell.h / 2;\n    cellQueue.push(new Cell(cell.x - h, cell.y - h, h, polygon));\n    cellQueue.push(new Cell(cell.x + h, cell.y - h, h, polygon));\n    cellQueue.push(new Cell(cell.x - h, cell.y + h, h, polygon));\n    cellQueue.push(new Cell(cell.x + h, cell.y + h, h, polygon));\n    numProbes += 4;\n  }\n\n  if (debug) {\n    console.log('num probes: ' + numProbes);\n    console.log('best distance: ' + bestCell.d);\n  }\n\n  var poleOfInaccessibility = [bestCell.x, bestCell.y];\n  poleOfInaccessibility.distance = bestCell.d;\n  return poleOfInaccessibility;\n}\n\nfunction compareMax(a, b) {\n  return b.max - a.max;\n}\n\nfunction Cell(x, y, h, polygon) {\n  this.x = x; // cell center x\n\n  this.y = y; // cell center y\n\n  this.h = h; // half the cell size\n\n  this.d = pointToPolygonDist(x, y, polygon); // distance from cell center to polygon\n\n  this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell\n} // signed distance from point to polygon outline (negative if point is outside)\n\n\nfunction pointToPolygonDist(x, y, polygon) {\n  var inside = false;\n  var minDistSq = Infinity;\n\n  for (var k = 0; k < polygon.length; k++) {\n    var ring = polygon[k];\n\n    for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {\n      var a = ring[i];\n      var b = ring[j];\n      if (a[1] > y !== b[1] > y && x < (b[0] - a[0]) * (y - a[1]) / (b[1] - a[1]) + a[0]) inside = !inside;\n      minDistSq = Math.min(minDistSq, getSegDistSq(x, y, a, b));\n    }\n  }\n\n  return minDistSq === 0 ? 0 : (inside ? 1 : -1) * Math.sqrt(minDistSq);\n} // get polygon centroid\n\n\nfunction getCentroidCell(polygon) {\n  var area = 0;\n  var x = 0;\n  var y = 0;\n  var points = polygon[0];\n\n  for (var i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n    var a = points[i];\n    var b = points[j];\n    var f = a[0] * b[1] - b[0] * a[1];\n    x += (a[0] + b[0]) * f;\n    y += (a[1] + b[1]) * f;\n    area += f * 3;\n  }\n\n  if (area === 0) return new Cell(points[0][0], points[0][1], 0, polygon);\n  return new Cell(x / area, y / area, 0, polygon);\n} // get squared distance from a point to a segment\n\n\nfunction getSegDistSq(px, py, a, b) {\n  var x = a[0];\n  var y = a[1];\n  var dx = b[0] - x;\n  var dy = b[1] - y;\n\n  if (dx !== 0 || dy !== 0) {\n    var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      x = b[0];\n      y = b[1];\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n\n  dx = px - x;\n  dy = py - y;\n  return dx * dx + dy * dy;\n}","map":{"version":3,"sources":["/Users/christopherpieper/Desktop/flight_count/node_modules/polylabel/polylabel.js"],"names":["Queue","require","default","module","exports","polylabel","polygon","precision","debug","minX","minY","maxX","maxY","i","length","p","width","height","cellSize","Math","min","h","degeneratePoleOfInaccessibility","distance","cellQueue","undefined","compareMax","x","y","push","Cell","bestCell","getCentroidCell","bboxCell","d","numProbes","cell","pop","console","log","round","max","poleOfInaccessibility","a","b","pointToPolygonDist","SQRT2","inside","minDistSq","Infinity","k","ring","len","j","getSegDistSq","sqrt","area","points","f","px","py","dx","dy","t"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Queue = require('tinyqueue');\n\nif (Queue.default) Queue = Queue.default; // temporary webpack fix\n\nmodule.exports = polylabel;\nmodule.exports.default = polylabel;\n\nfunction polylabel(polygon, precision, debug) {\n    precision = precision || 1.0;\n\n    // find the bounding box of the outer ring\n    var minX, minY, maxX, maxY;\n    for (var i = 0; i < polygon[0].length; i++) {\n        var p = polygon[0][i];\n        if (!i || p[0] < minX) minX = p[0];\n        if (!i || p[1] < minY) minY = p[1];\n        if (!i || p[0] > maxX) maxX = p[0];\n        if (!i || p[1] > maxY) maxY = p[1];\n    }\n\n    var width = maxX - minX;\n    var height = maxY - minY;\n    var cellSize = Math.min(width, height);\n    var h = cellSize / 2;\n\n    if (cellSize === 0) {\n        var degeneratePoleOfInaccessibility = [minX, minY];\n        degeneratePoleOfInaccessibility.distance = 0;\n        return degeneratePoleOfInaccessibility;\n    }\n\n    // a priority queue of cells in order of their \"potential\" (max distance to polygon)\n    var cellQueue = new Queue(undefined, compareMax);\n\n    // cover polygon with initial cells\n    for (var x = minX; x < maxX; x += cellSize) {\n        for (var y = minY; y < maxY; y += cellSize) {\n            cellQueue.push(new Cell(x + h, y + h, h, polygon));\n        }\n    }\n\n    // take centroid as the first best guess\n    var bestCell = getCentroidCell(polygon);\n\n    // special case for rectangular polygons\n    var bboxCell = new Cell(minX + width / 2, minY + height / 2, 0, polygon);\n    if (bboxCell.d > bestCell.d) bestCell = bboxCell;\n\n    var numProbes = cellQueue.length;\n\n    while (cellQueue.length) {\n        // pick the most promising cell from the queue\n        var cell = cellQueue.pop();\n\n        // update the best cell if we found a better one\n        if (cell.d > bestCell.d) {\n            bestCell = cell;\n            if (debug) console.log('found best %d after %d probes', Math.round(1e4 * cell.d) / 1e4, numProbes);\n        }\n\n        // do not drill down further if there's no chance of a better solution\n        if (cell.max - bestCell.d <= precision) continue;\n\n        // split the cell into four cells\n        h = cell.h / 2;\n        cellQueue.push(new Cell(cell.x - h, cell.y - h, h, polygon));\n        cellQueue.push(new Cell(cell.x + h, cell.y - h, h, polygon));\n        cellQueue.push(new Cell(cell.x - h, cell.y + h, h, polygon));\n        cellQueue.push(new Cell(cell.x + h, cell.y + h, h, polygon));\n        numProbes += 4;\n    }\n\n    if (debug) {\n        console.log('num probes: ' + numProbes);\n        console.log('best distance: ' + bestCell.d);\n    }\n\n    var poleOfInaccessibility = [bestCell.x, bestCell.y];\n    poleOfInaccessibility.distance = bestCell.d;\n    return poleOfInaccessibility;\n}\n\nfunction compareMax(a, b) {\n    return b.max - a.max;\n}\n\nfunction Cell(x, y, h, polygon) {\n    this.x = x; // cell center x\n    this.y = y; // cell center y\n    this.h = h; // half the cell size\n    this.d = pointToPolygonDist(x, y, polygon); // distance from cell center to polygon\n    this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell\n}\n\n// signed distance from point to polygon outline (negative if point is outside)\nfunction pointToPolygonDist(x, y, polygon) {\n    var inside = false;\n    var minDistSq = Infinity;\n\n    for (var k = 0; k < polygon.length; k++) {\n        var ring = polygon[k];\n\n        for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {\n            var a = ring[i];\n            var b = ring[j];\n\n            if ((a[1] > y !== b[1] > y) &&\n                (x < (b[0] - a[0]) * (y - a[1]) / (b[1] - a[1]) + a[0])) inside = !inside;\n\n            minDistSq = Math.min(minDistSq, getSegDistSq(x, y, a, b));\n        }\n    }\n\n    return minDistSq === 0 ? 0 : (inside ? 1 : -1) * Math.sqrt(minDistSq);\n}\n\n// get polygon centroid\nfunction getCentroidCell(polygon) {\n    var area = 0;\n    var x = 0;\n    var y = 0;\n    var points = polygon[0];\n\n    for (var i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        var a = points[i];\n        var b = points[j];\n        var f = a[0] * b[1] - b[0] * a[1];\n        x += (a[0] + b[0]) * f;\n        y += (a[1] + b[1]) * f;\n        area += f * 3;\n    }\n    if (area === 0) return new Cell(points[0][0], points[0][1], 0, polygon);\n    return new Cell(x / area, y / area, 0, polygon);\n}\n\n// get squared distance from a point to a segment\nfunction getSegDistSq(px, py, a, b) {\n\n    var x = a[0];\n    var y = a[1];\n    var dx = b[0] - x;\n    var dy = b[1] - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = b[0];\n            y = b[1];\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = px - x;\n    dy = py - y;\n\n    return dx * dx + dy * dy;\n}\n"]},"metadata":{},"sourceType":"script"}