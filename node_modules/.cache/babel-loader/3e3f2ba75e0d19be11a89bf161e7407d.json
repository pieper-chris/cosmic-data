{"ast":null,"code":"/**\r\n * Map polygon module\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { MapObject } from \"./MapObject\";\nimport { Polygon } from \"../../core/elements/Polygon\";\nimport { registry } from \"../../core/Registry\";\nimport * as $type from \"../../core/utils/Type\";\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\nimport $polylabel from \"polylabel\";\nimport * as $mapUtils from \"./MapUtils\";\nimport * as d3geo from \"d3-geo\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Used to draw a polygon on the map.\r\n *\r\n * @see {@link IMapPolygonEvents} for a list of available events\r\n * @see {@link IMapPolygonAdapters} for a list of available Adapters\r\n */\n\nvar MapPolygon =\n/** @class */\nfunction (_super) {\n  __extends(MapPolygon, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function MapPolygon() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"MapPolygon\";\n    _this.polygon = _this.createChild(Polygon);\n    _this.polygon.shouldClone = false;\n    _this.polygon.applyOnClones = true;\n\n    _this.setPropertyValue(\"precision\", 0.5);\n\n    var interfaceColors = new InterfaceColorSet();\n    _this.fill = interfaceColors.getFor(\"secondaryButton\");\n    _this.stroke = interfaceColors.getFor(\"secondaryButtonStroke\");\n    _this.strokeOpacity = 1;\n    _this.tooltipPosition = \"pointer\";\n    _this.nonScalingStroke = true;\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapPolygon.prototype.getFeature = function () {\n    if (this.multiPolygon && this.multiPolygon.length > 0) {\n      return {\n        \"type\": \"Feature\",\n        geometry: {\n          type: \"MultiPolygon\",\n          coordinates: this.multiPolygon\n        }\n      };\n    }\n  };\n\n  Object.defineProperty(MapPolygon.prototype, \"multiGeoPolygon\", {\n    /**\r\n     * @return Polygon coordinates\r\n     */\n    get: function () {\n      var multiGeoPolygon = this.getPropertyValue(\"multiGeoPolygon\");\n\n      if (!multiGeoPolygon && this.dataItem) {\n        multiGeoPolygon = this.dataItem.multiGeoPolygon;\n      }\n\n      return multiGeoPolygon;\n    },\n\n    /**\r\n     * Set of coordinates for the polygon.\r\n     *\r\n     * @param multiGeoPolygon  Polygon coordinates\r\n     */\n    set: function (multiGeoPolygon) {\n      this.setPropertyValue(\"multiGeoPolygon\", multiGeoPolygon, true);\n      this.multiPolygon = $mapUtils.multiGeoPolygonToMultipolygon(multiGeoPolygon);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapPolygon.prototype, \"multiPolygon\", {\n    /**\r\n     * @return Coordinates\r\n     */\n    get: function () {\n      var multiPolygon = this.getPropertyValue(\"multiPolygon\");\n\n      if (!multiPolygon && this.dataItem) {\n        multiPolygon = this.dataItem.multiPolygon;\n      }\n\n      return multiPolygon;\n    },\n\n    /**\r\n     * A collection of X/Y coordinates for a multi-part polygon. E.g.:\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *   // Part 1\r\n     *   [\r\n     *     [\r\n     *       [ 100, 150 ],\r\n     *       [ 120, 200 ],\r\n     *       [ 150, 220 ],\r\n     *       [ 170, 240 ],\r\n     *       [ 100, 150 ]\r\n     *     ]\r\n     *   ],\r\n     *\r\n     *   // Part 2\r\n     *   [\r\n     *     [\r\n     *       [ 300, 350 ],\r\n     *       [ 320, 400 ],\r\n     *       [ 350, 420 ],\r\n     *       [ 370, 440 ],\r\n     *       [ 300, 350 ]\r\n     *     ]\r\n     *   ]\r\n     * ]\r\n     * ```\r\n     *\r\n     * @param multiPolygon  Coordinates\r\n     */\n    set: function (multiPolygon) {\n      if (this.setPropertyValue(\"multiPolygon\", multiPolygon)) {\n        this.updateExtremes();\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * (Re)validates the polygon, effectively redrawing it.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  MapPolygon.prototype.validate = function () {\n    if (this.series) {\n      var projection = this.series.chart.projection;\n      var pathGenerator = projection.d3Path;\n\n      if (this.multiPolygon) {\n        if (this.series) {\n          var feature = {\n            type: \"MultiPolygon\",\n            coordinates: this.multiPolygon\n          };\n          projection.d3Projection.precision(this.precision);\n          this.polygon.path = pathGenerator(feature);\n        }\n\n        if (this.series.calculateVisualCenter) {\n          var biggestArea = 0;\n          var biggestPolygon = this.multiPolygon[0];\n\n          if (this.multiPolygon.length > 1) {\n            for (var i = 0; i < this.multiPolygon.length; i++) {\n              var polygon = this.multiPolygon[i];\n              var area = d3geo.geoArea({\n                type: \"Polygon\",\n                coordinates: polygon\n              });\n\n              if (area > biggestArea) {\n                biggestPolygon = polygon;\n                biggestArea = area;\n              }\n            }\n          }\n\n          var center = $polylabel(biggestPolygon);\n          this._visualLongitude = center[0];\n          this._visualLatitude = center[1];\n        } else {\n          this._visualLongitude = this.longitude;\n          this._visualLatitude = this.latitude;\n        }\n      }\n    }\n\n    _super.prototype.validate.call(this);\n  };\n  /**\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  MapPolygon.prototype.measureElement = function () {// Overriding, just to avoid extra measure\n  };\n\n  Object.defineProperty(MapPolygon.prototype, \"latitude\", {\n    /**\r\n     * Latitude of the geometrical center of the polygon.\r\n     *\r\n     * @readonly\r\n     * @return Center latitude\r\n     */\n    get: function () {\n      return this.north + (this.south - this.north) / 2;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapPolygon.prototype, \"longitude\", {\n    /**\r\n     * Longitude of the geometrical center of the polygon.\r\n     *\r\n     * @readonly\r\n     * @return Center longitude\r\n     */\n    get: function () {\n      return this.east + (this.west - this.east) / 2;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapPolygon.prototype, \"visualLatitude\", {\n    /**\r\n     * @return  Latitude\r\n     */\n    get: function () {\n      var latitude = this.getPropertyValue(\"visualLatitude\");\n\n      if ($type.isNumber(latitude)) {\n        return latitude;\n      }\n\n      if (!this._adapterO) {\n        return this._visualLatitude;\n      } else {\n        return this._adapterO.apply(\"visualLatitude\", this._visualLatitude);\n      }\n    },\n\n    /**\r\n     * Latitude of the visual center of the polygon.\r\n     *\r\n     * It may (and probably won't) coincide with geometrical center.\r\n     *\r\n     * @since 4.3.0\r\n     * @param  value  Latitude\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"visualLatitude\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapPolygon.prototype, \"visualLongitude\", {\n    /**\r\n     * @return  Longitude\r\n     */\n    get: function () {\n      var longitude = this.getPropertyValue(\"visualLongitude\");\n\n      if ($type.isNumber(longitude)) {\n        return longitude;\n      }\n\n      if (!this._adapterO) {\n        return this._visualLongitude;\n      } else {\n        return this._adapterO.apply(\"visualLongitude\", this._visualLongitude);\n      }\n    },\n\n    /**\r\n     * Longitude of the visual center of the polygon.\r\n     *\r\n     * It may (and probably won't) coincide with geometrical center.\r\n     *\r\n     * @since 4.3.0\r\n     * @param  value  Longitude\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"visualLongitude\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapPolygon.prototype, \"pixelWidth\", {\n    /**\r\n     * Not 100% sure about this, as if we add something to MapPolygon this\r\n     * won't be true, but otherwise we will get all 0 and the tooltip won't\r\n     * be positioned properly\r\n     * @hidden\r\n     */\n\n    /**\r\n     * Element's width in pixels.\r\n     *\r\n     * @readonly\r\n     * @return Width (px)\r\n     */\n    get: function () {\n      return this.polygon.pixelWidth;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapPolygon.prototype, \"pixelHeight\", {\n    /**\r\n     * Element's height in pixels.\r\n     *\r\n     * @readonly\r\n     * @return Width (px)\r\n     */\n    get: function () {\n      return this.polygon.pixelHeight;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Copies all properties from another instance of [[MapPolygon]].\r\n   *\r\n   * @param source  Source series\r\n   */\n\n  MapPolygon.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n\n    this.polygon.copyFrom(source.polygon);\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapPolygon.prototype.updateExtremes = function () {\n    _super.prototype.updateExtremes.call(this);\n  };\n\n  Object.defineProperty(MapPolygon.prototype, \"boxArea\", {\n    /**\r\n     * @ignore\r\n     * used to sorth polygons from big to small\r\n     */\n    get: function () {\n      return (this.north - this.south) * (this.east - this.west);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * X coordinate for the slice tooltip.\r\n   *\r\n   * @ignore\r\n   * @return X\r\n   */\n\n  MapPolygon.prototype.getTooltipX = function () {\n    return this.series.chart.projection.convert({\n      longitude: this.visualLongitude,\n      latitude: this.visualLatitude\n    }).x;\n  };\n  /**\r\n   * Y coordinate for the slice tooltip.\r\n   *\r\n   * @ignore\r\n   * @return Y\r\n   */\n\n\n  MapPolygon.prototype.getTooltipY = function () {\n    return this.series.chart.projection.convert({\n      longitude: this.visualLongitude,\n      latitude: this.visualLatitude\n    }).y;\n  };\n\n  Object.defineProperty(MapPolygon.prototype, \"precision\", {\n    get: function () {\n      return this.getPropertyValue(\"precision\");\n    },\n\n    /**\r\n     * When polygon's sides are plotted, they are bent according to the used\r\n     * projection.\r\n     *\r\n     * `precision` introduces a setting which can control when such bending\r\n     * occurs.\r\n     *\r\n     * If the distance (in degrees) between two points of polygon's side is less\r\n     * than `precision`, no bending will take place and the line will be straight.\r\n     *\r\n     * Set to large number (e.g. 10000) for perfectly straight lines on all\r\n     * polygon's sides.\r\n     *\r\n     * @since 4.9.1\r\n     * @default 0.5\r\n     * @param  value  Precision\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"precision\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return MapPolygon;\n}(MapObject);\n\nexport { MapPolygon };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"MapPolygon\"] = MapPolygon;","map":{"version":3,"sources":["../../../../../src/.internal/charts/map/MapPolygon.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Map polygon module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { MapObject, IMapObjectProperties, IMapObjectAdapters, IMapObjectEvents } from \"./MapObject\";\r\nimport { MapPolygonSeriesDataItem, MapPolygonSeries } from \"./MapPolygonSeries\";\r\nimport { IGeoPoint } from \"../../core/defs/IGeoPoint\";\r\nimport { Polygon } from \"../../core/elements/Polygon\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\r\nimport $polylabel from \"polylabel\";\r\nimport * as $mapUtils from \"./MapUtils\";\r\nimport * as d3geo from \"d3-geo\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[MapPolygon]].\r\n */\r\nexport interface IMapPolygonProperties extends IMapObjectProperties {\r\n\r\n\t/**\r\n\t * Set of geographical coordinates for the polygon.\r\n\t */\r\n\tmultiGeoPolygon?: Array<[Array<IGeoPoint>, Array<IGeoPoint>]>;\r\n\r\n\t/**\r\n\t * Set of screen coordinates for the polygon.\r\n\t */\r\n\tmultiPolygon?: Array<Array<Array<[number, number]>>>;\r\n\r\n\t/**\r\n\t * Latitude of the visual center of the polygon.\r\n\t */\r\n\tvisualLatitude?: number;\r\n\r\n\t/**\r\n\t * Longitude of the visual center of the polygon.\r\n\t */\r\n\tvisualLongitude?: number;\r\n\r\n\t/**\r\n\t * When polygon's sides are plotted, they are bent according to the used\r\n\t * projection, to depict the shortest distance how it would go on the actual\r\n\t * land.\r\n\t *\r\n\t * `precision` introduces a setting which can control when such bending\r\n\t * occurs.\r\n\t *\r\n\t * If the distance (in degrees) between two points of polygon's side is less\r\n\t * than `precision`, no bending will take place and the line will be straight.\r\n\t *\r\n\t * Set to large number (e.g. 10000) for perfectly straight lines on all\r\n\t * polygon's sides.\r\n\t *\r\n\t * @since 4.9.1\r\n\t * @default 0.5\r\n\t */\r\n\tprecision?: number;\r\n}\r\n\r\n/**\r\n * Defines events for [[MapPolygon]].\r\n */\r\nexport interface IMapPolygonEvents extends IMapObjectEvents { }\r\n\r\n/**\r\n * Defines adapters for [[MapPolygon]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IMapPolygonAdapters extends IMapObjectAdapters, IMapPolygonProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Used to draw a polygon on the map.\r\n *\r\n * @see {@link IMapPolygonEvents} for a list of available events\r\n * @see {@link IMapPolygonAdapters} for a list of available Adapters\r\n */\r\nexport class MapPolygon extends MapObject {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IMapPolygonProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IMapPolygonAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IMapPolygonEvents;\r\n\r\n\t/**\r\n\t * A visual polygon element.\r\n\t */\r\n\tpublic polygon: Polygon;\r\n\r\n\t/**\r\n\t * A related data item.\r\n\t */\r\n\tpublic _dataItem: MapPolygonSeriesDataItem;\r\n\r\n\t/**\r\n\t * A map series this object belongs to.\r\n\t */\r\n\tpublic series: MapPolygonSeries;\r\n\r\n\t/**\r\n\t * Latitude of the visual center of the polygon.\r\n\t */\r\n\tprotected _visualLatitude: number;\r\n\r\n\t/**\r\n\t * Longitude of the visual center of the polygon.\r\n\t */\r\n\tprotected _visualLongitude: number;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\r\n\t\tthis.className = \"MapPolygon\";\r\n\r\n\t\tthis.polygon = this.createChild(Polygon);\r\n\t\tthis.polygon.shouldClone = false;\r\n\t\tthis.polygon.applyOnClones = true;\r\n\t\tthis.setPropertyValue(\"precision\", 0.5);\r\n\r\n\t\tlet interfaceColors = new InterfaceColorSet();\r\n\r\n\t\tthis.fill = interfaceColors.getFor(\"secondaryButton\");\r\n\t\tthis.stroke = interfaceColors.getFor(\"secondaryButtonStroke\");\r\n\t\tthis.strokeOpacity = 1;\r\n\r\n\t\tthis.tooltipPosition = \"pointer\";\r\n\r\n\t\tthis.nonScalingStroke = true;\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic getFeature(): { \"type\": \"Feature\", geometry: { type: \"MultiPolygon\", coordinates: Array<Array<Array<[number, number]>>> } } {\r\n\t\tif (this.multiPolygon && this.multiPolygon.length > 0) {\r\n\t\t\treturn { \"type\": \"Feature\", geometry: { type: \"MultiPolygon\", coordinates: this.multiPolygon } };\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Set of coordinates for the polygon.\r\n\t *\r\n\t * @param multiGeoPolygon  Polygon coordinates\r\n\t */\r\n\tpublic set multiGeoPolygon(multiGeoPolygon: Array<[Array<IGeoPoint>, Array<IGeoPoint>]>) {\r\n\t\tthis.setPropertyValue(\"multiGeoPolygon\", multiGeoPolygon, true);\r\n\t\tthis.multiPolygon = $mapUtils.multiGeoPolygonToMultipolygon(multiGeoPolygon);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Polygon coordinates\r\n\t */\r\n\tpublic get multiGeoPolygon(): Array<[Array<IGeoPoint>, Array<IGeoPoint>]> {\r\n\t\tlet multiGeoPolygon = this.getPropertyValue(\"multiGeoPolygon\");\r\n\t\tif (!multiGeoPolygon && this.dataItem) {\r\n\t\t\tmultiGeoPolygon = this.dataItem.multiGeoPolygon;\r\n\t\t}\r\n\t\treturn multiGeoPolygon;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * A collection of X/Y coordinates for a multi-part polygon. E.g.:\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *   // Part 1\r\n\t *   [\r\n\t *     [\r\n\t *       [ 100, 150 ],\r\n\t *       [ 120, 200 ],\r\n\t *       [ 150, 220 ],\r\n\t *       [ 170, 240 ],\r\n\t *       [ 100, 150 ]\r\n\t *     ]\r\n\t *   ],\r\n\t *\r\n\t *   // Part 2\r\n\t *   [\r\n\t *     [\r\n\t *       [ 300, 350 ],\r\n\t *       [ 320, 400 ],\r\n\t *       [ 350, 420 ],\r\n\t *       [ 370, 440 ],\r\n\t *       [ 300, 350 ]\r\n\t *     ]\r\n\t *   ]\r\n\t * ]\r\n\t * ```\r\n\t *\r\n\t * @param multiPolygon  Coordinates\r\n\t */\r\n\tpublic set multiPolygon(multiPolygon: Array<Array<Array<[number, number]>>>) {\r\n\t\tif (this.setPropertyValue(\"multiPolygon\", multiPolygon)) {\r\n\t\t\tthis.updateExtremes();\r\n\t\t\tthis.invalidate();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Coordinates\r\n\t */\r\n\tpublic get multiPolygon(): Array<Array<Array<[number, number]>>> {\r\n\t\tlet multiPolygon = this.getPropertyValue(\"multiPolygon\");\r\n\t\tif (!multiPolygon && this.dataItem) {\r\n\t\t\tmultiPolygon = this.dataItem.multiPolygon;\r\n\t\t}\r\n\t\treturn multiPolygon;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * (Re)validates the polygon, effectively redrawing it.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validate(): void {\r\n\t\tif (this.series) {\r\n\t\t\tlet projection = this.series.chart.projection;\r\n\r\n\t\t\tlet pathGenerator = projection.d3Path;\r\n\r\n\t\t\tif (this.multiPolygon) {\r\n\r\n\t\t\t\tif (this.series) {\r\n\t\t\t\t\tlet feature = { type: \"MultiPolygon\", coordinates: this.multiPolygon };\r\n\r\n\t\t\t\t\tprojection.d3Projection.precision(this.precision);\r\n\t\t\t\t\tthis.polygon.path = pathGenerator(<any>feature);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.series.calculateVisualCenter) {\r\n\t\t\t\t\tlet biggestArea = 0;\r\n\t\t\t\t\tlet biggestPolygon = this.multiPolygon[0];\r\n\r\n\t\t\t\t\tif (this.multiPolygon.length > 1) {\r\n\t\t\t\t\t\tfor (let i = 0; i < this.multiPolygon.length; i++) {\r\n\t\t\t\t\t\t\tlet polygon = this.multiPolygon[i];\r\n\t\t\t\t\t\t\tlet area = d3geo.geoArea({ type: \"Polygon\", coordinates: polygon });\r\n\r\n\t\t\t\t\t\t\tif (area > biggestArea) {\r\n\t\t\t\t\t\t\t\tbiggestPolygon = polygon;\r\n\t\t\t\t\t\t\t\tbiggestArea = area;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet center = $polylabel(biggestPolygon);\r\n\r\n\t\t\t\t\tthis._visualLongitude = center[0];\r\n\t\t\t\t\tthis._visualLatitude = center[1];\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis._visualLongitude = this.longitude;\r\n\t\t\t\t\tthis._visualLatitude = this.latitude;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsuper.validate();\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic measureElement(): void {\r\n\t\t// Overriding, just to avoid extra measure\r\n\t}\r\n\r\n\t/**\r\n\t * Latitude of the geometrical center of the polygon.\r\n\t *\r\n\t * @readonly\r\n\t * @return Center latitude\r\n\t */\r\n\tpublic get latitude(): number {\r\n\t\treturn this.north + (this.south - this.north) / 2;\r\n\t}\r\n\r\n\t/**\r\n\t * Longitude of the geometrical center of the polygon.\r\n\t *\r\n\t * @readonly\r\n\t * @return Center longitude\r\n\t */\r\n\tpublic get longitude(): number {\r\n\t\treturn this.east + (this.west - this.east) / 2;\r\n\t}\r\n\r\n\t/**\r\n\t * Latitude of the visual center of the polygon.\r\n\t *\r\n\t * It may (and probably won't) coincide with geometrical center.\r\n\t *\r\n\t * @since 4.3.0\r\n\t * @param  value  Latitude\r\n\t */\r\n\tpublic set visualLatitude(value: number) {\r\n\t\tthis.setPropertyValue(\"visualLatitude\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return  Latitude\r\n\t */\r\n\tpublic get visualLatitude(): number {\r\n\t\tlet latitude = this.getPropertyValue(\"visualLatitude\");\r\n\t\tif ($type.isNumber(latitude)) {\r\n\t\t\treturn (latitude);\r\n\t\t}\r\n\t\tif (!this._adapterO) {\r\n\t\t\treturn this._visualLatitude;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this._adapterO.apply(\r\n\t\t\t\t\"visualLatitude\",\r\n\t\t\t\tthis._visualLatitude\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Longitude of the visual center of the polygon.\r\n\t *\r\n\t * It may (and probably won't) coincide with geometrical center.\r\n\t *\r\n\t * @since 4.3.0\r\n\t * @param  value  Longitude\r\n\t */\r\n\tpublic set visualLongitude(value: number) {\r\n\t\tthis.setPropertyValue(\"visualLongitude\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return  Longitude\r\n\t */\r\n\tpublic get visualLongitude(): number {\r\n\t\tlet longitude = this.getPropertyValue(\"visualLongitude\");\r\n\t\tif ($type.isNumber(longitude)) {\r\n\t\t\treturn (longitude);\r\n\t\t}\r\n\t\tif (!this._adapterO) {\r\n\t\t\treturn this._visualLongitude;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this._adapterO.apply(\r\n\t\t\t\t\"visualLongitude\",\r\n\t\t\t\tthis._visualLongitude\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Not 100% sure about this, as if we add something to MapPolygon this\r\n\t * won't be true, but otherwise we will get all 0 and the tooltip won't\r\n\t * be positioned properly\r\n\t * @hidden\r\n\t */\r\n\r\n\t/**\r\n\t * Element's width in pixels.\r\n\t *\r\n\t * @readonly\r\n\t * @return Width (px)\r\n\t */\r\n\tpublic get pixelWidth(): number {\r\n\t\treturn this.polygon.pixelWidth;\r\n\t}\r\n\r\n\t/**\r\n\t * Element's height in pixels.\r\n\t *\r\n\t * @readonly\r\n\t * @return Width (px)\r\n\t */\r\n\tpublic get pixelHeight(): number {\r\n\t\treturn this.polygon.pixelHeight;\r\n\t}\r\n\r\n\t/**\r\n\t * Copies all properties from another instance of [[MapPolygon]].\r\n\t *\r\n\t * @param source  Source series\r\n\t */\r\n\tpublic copyFrom(source: this) {\r\n\t\tsuper.copyFrom(source);\r\n\t\tthis.polygon.copyFrom(source.polygon);\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic updateExtremes() {\r\n\t\tsuper.updateExtremes();\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t * used to sorth polygons from big to small\r\n\t */\r\n\tpublic get boxArea() {\r\n\t\treturn (this.north - this.south) * (this.east - this.west);\r\n\t}\r\n\r\n\t/**\r\n\t * X coordinate for the slice tooltip.\r\n\t *\r\n\t * @ignore\r\n\t * @return X\r\n\t */\r\n\tpublic getTooltipX(): number {\r\n\t\treturn this.series.chart.projection.convert({ longitude: this.visualLongitude, latitude: this.visualLatitude }).x;\r\n\t}\r\n\r\n\t/**\r\n\t * Y coordinate for the slice tooltip.\r\n\t *\r\n\t * @ignore\r\n\t * @return Y\r\n\t */\r\n\tpublic getTooltipY(): number {\r\n\t\treturn this.series.chart.projection.convert({ longitude: this.visualLongitude, latitude: this.visualLatitude }).y\r\n\t}\r\n\r\n\t/**\r\n\t * When polygon's sides are plotted, they are bent according to the used\r\n\t * projection.\r\n\t *\r\n\t * `precision` introduces a setting which can control when such bending\r\n\t * occurs.\r\n\t *\r\n\t * If the distance (in degrees) between two points of polygon's side is less\r\n\t * than `precision`, no bending will take place and the line will be straight.\r\n\t *\r\n\t * Set to large number (e.g. 10000) for perfectly straight lines on all\r\n\t * polygon's sides.\r\n\t *\r\n\t * @since 4.9.1\r\n\t * @default 0.5\r\n\t * @param  value  Precision\r\n\t */\r\n\tpublic set precision(value: number) {\r\n\t\tthis.setPropertyValue(\"precision\", value, true);\r\n\t}\r\n\r\n\tpublic get precision(): number {\r\n\t\treturn this.getPropertyValue(\"precision\");\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"MapPolygon\"] = MapPolygon;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}