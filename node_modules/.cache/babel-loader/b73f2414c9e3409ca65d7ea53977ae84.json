{"ast":null,"code":"import { EventDispatcher, Object3D, Raycaster, Vector2 } from 'three';\n/**\n * get variable type\n * @param {*} val a variable which you want to get the type\n * @return {String} variable-type\n */\n\nfunction _rt(val) {\n  return Object.prototype.toString.call(val);\n}\n/**\n * Utils tool box\n *\n * @namespace Utils\n */\n\n\nvar Utils = {\n  /**\n   * determine whether it is a `Function`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isFunction: function () {\n    var ks = _rt(function () {});\n\n    return function (variable) {\n      return _rt(variable) === ks;\n    };\n  }(),\n\n  /**\n   * determine whether it is a `undefined`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isUndefined: function isUndefined(variable) {\n    return typeof variable === 'undefined';\n  }\n};\n/**\n * proxy `addEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\n\nEventDispatcher.prototype.on = function (type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  if (this instanceof Object3D) this.interactive = true;\n  this.addEventListener(type, fn);\n  return this;\n};\n/**\n * proxy `removeEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback, which you had bind before\n * @return {this} this\n */\n\n\nEventDispatcher.prototype.off = function (type, fn) {\n  this.removeEventListener(type, fn);\n  return this;\n};\n/**\n * binding a once event, just emit once time\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\n\n\nEventDispatcher.prototype.once = function (type, fn) {\n  var _this = this;\n\n  if (!Utils.isFunction(fn)) return;\n\n  var cb = function cb(ev) {\n    fn(ev);\n\n    _this.off(type, cb);\n  };\n\n  this.on(type, cb);\n  return this;\n};\n/**\n * emit a event\n *\n * @param {String} type event type, evnet name\n * @return {this} this\n */\n\n\nEventDispatcher.prototype.emit = function (type) {\n  if (this._listeners === undefined || Utils.isUndefined(this._listeners[type])) return;\n  var cbs = this._listeners[type] || [];\n  var cache = cbs.slice(0);\n\n  for (var _len = arguments.length, argument = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    argument[_key - 1] = arguments[_key];\n  }\n\n  for (var i = 0; i < cache.length; i++) {\n    cache[i].apply(this, argument);\n  }\n\n  return this;\n};\n/**\n * whether displayObject is interactively\n */\n\n\nObject3D.prototype.interactive = false;\n/**\n * whether displayObject's children is interactively\n */\n\nObject3D.prototype.interactiveChildren = true;\n/**\n * whether displayObject had touchstart\n * @private\n */\n\nObject3D.prototype.started = false;\n/**\n * tracked event cache, like: touchend、mouseout、pointerout which decided by primary-event\n */\n\nObject.defineProperty(Object3D.prototype, 'trackedPointers', {\n  get: function get() {\n    if (!this._trackedPointers) this._trackedPointers = {};\n    return this._trackedPointers;\n  }\n});\n/**\n * dispatch a raycast\n *\n * @param {Raycaster} raycaster Raycaster object, get from THREE.Raycaster\n * @return {Object|Boolean} had pass hit-test\n */\n\nObject3D.prototype.raycastTest = function (raycaster) {\n  var result = [];\n  this.raycast(raycaster, result);\n\n  if (result.length > 0) {\n    return result[0];\n  }\n\n  return false;\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n/**\n * Holds all information related to an Interaction event\n *\n * @class\n */\n\n\nvar InteractionData = function () {\n  /**\n   * InteractionData constructor\n   */\n  function InteractionData() {\n    classCallCheck(this, InteractionData);\n    /**\n     * This point stores the global coords of where the touch/mouse event happened\n     *\n     * @member {Vector2}\n     */\n\n    this.global = new Vector2();\n    /**\n     * The target DisplayObject that was interacted with\n     *\n     * @member {Object3D}\n     */\n\n    this.target = null;\n    /**\n     * When passed to an event handler, this will be the original DOM Event that was captured\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent\n     * @member {MouseEvent|TouchEvent|PointerEvent}\n     */\n\n    this.originalEvent = null;\n    /**\n     * Unique identifier for this interaction\n     *\n     * @member {number}\n     */\n\n    this.identifier = null;\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     * @type {Boolean}\n     */\n\n    this.isPrimary = false;\n    /**\n     * Indicates which button was pressed on the mouse or pointer device to trigger the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n     * @type {number}\n     */\n\n    this.button = 0;\n    /**\n     * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n     * @type {number}\n     */\n\n    this.buttons = 0;\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     * @type {number}\n     */\n\n    this.width = 0;\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     * @type {number}\n     */\n\n    this.height = 0;\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n     * @type {number}\n     */\n\n    this.tiltX = 0;\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n     * @type {number}\n     */\n\n    this.tiltY = 0;\n    /**\n     * The type of pointer that triggered the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     * @type {string}\n     */\n\n    this.pointerType = null;\n    /**\n     * Pressure applied by the pointing device during the event. A Touch's force property\n     * will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     * @type {number}\n     */\n\n    this.pressure = 0;\n    /**\n     * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle\n     * @type {number}\n     */\n\n    this.rotationAngle = 0;\n    /**\n     * Twist of a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n\n    this.twist = 0;\n    /**\n     * Barrel pressure on a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n\n    this.tangentialPressure = 0;\n  }\n  /**\n   * The unique identifier of the pointer. It will be the same as `identifier`.\n   * @readonly\n   * @member {number}\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId\n   */\n\n\n  createClass(InteractionData, [{\n    key: '_copyEvent',\n\n    /**\n     * Copies properties from normalized event data.\n     *\n     * @param {Touch|MouseEvent|PointerEvent} event The normalized event data\n     * @private\n     */\n    value: function _copyEvent(event) {\n      // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite\n      // it with \"false\" on later events when our shim for it on touch events might not be\n      // accurate\n      if (event.isPrimary) {\n        this.isPrimary = true;\n      }\n\n      this.button = event.button;\n      this.buttons = event.buttons;\n      this.width = event.width;\n      this.height = event.height;\n      this.tiltX = event.tiltX;\n      this.tiltY = event.tiltY;\n      this.pointerType = event.pointerType;\n      this.pressure = event.pressure;\n      this.rotationAngle = event.rotationAngle;\n      this.twist = event.twist || 0;\n      this.tangentialPressure = event.tangentialPressure || 0;\n    }\n    /**\n     * Resets the data for pooling.\n     *\n     * @private\n     */\n\n  }, {\n    key: '_reset',\n    value: function _reset() {\n      // isPrimary is the only property that we really need to reset - everything else is\n      // guaranteed to be overwritten\n      this.isPrimary = false;\n    }\n  }, {\n    key: 'pointerId',\n    get: function get$$1() {\n      return this.identifier;\n    }\n  }]);\n  return InteractionData;\n}();\n/**\n * Event class that mimics native DOM events.\n *\n * @class\n */\n\n\nvar InteractionEvent = function () {\n  /**\n   * InteractionEvent constructor\n   */\n  function InteractionEvent() {\n    classCallCheck(this, InteractionEvent);\n    /**\n     * Whether this event will continue propagating in the tree\n     *\n     * @member {boolean}\n     */\n\n    this.stopped = false;\n    /**\n     * The object which caused this event to be dispatched.\n     *\n     * @member {Object3D}\n     */\n\n    this.target = null;\n    /**\n     * The object whose event listener’s callback is currently being invoked.\n     *\n     * @member {Object3D}\n     */\n\n    this.currentTarget = null;\n    /**\n     * Type of the event\n     *\n     * @member {string}\n     */\n\n    this.type = null;\n    /**\n     * InteractionData related to this event\n     *\n     * @member {InteractionData}\n     */\n\n    this.data = null;\n    /**\n     * ray caster detial from 3d-mesh\n     *\n     * @member {Intersects}\n     */\n\n    this.intersects = [];\n  }\n  /**\n   * Prevents event from reaching any objects other than the current object.\n   *\n   */\n\n\n  createClass(InteractionEvent, [{\n    key: \"stopPropagation\",\n    value: function stopPropagation() {\n      this.stopped = true;\n    }\n    /**\n     * Resets the event.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_reset\",\n    value: function _reset() {\n      this.stopped = false;\n      this.currentTarget = null;\n      this.target = null;\n      this.intersects = [];\n    }\n  }]);\n  return InteractionEvent;\n}();\n/**\n * DisplayObjects with the `trackedPointers` property use this class to track interactions\n *\n * @class\n * @private\n */\n\n\nvar InteractionTrackingData = function () {\n  /**\n   * @param {number} pointerId - Unique pointer id of the event\n   */\n  function InteractionTrackingData(pointerId) {\n    classCallCheck(this, InteractionTrackingData);\n    this._pointerId = pointerId;\n    this._flags = InteractionTrackingData.FLAGS.NONE;\n  }\n  /**\n   *\n   * @private\n   * @param {number} flag - The interaction flag to set\n   * @param {boolean} yn - Should the flag be set or unset\n   */\n\n\n  createClass(InteractionTrackingData, [{\n    key: \"_doSet\",\n    value: function _doSet(flag, yn) {\n      if (yn) {\n        this._flags = this._flags | flag;\n      } else {\n        this._flags = this._flags & ~flag;\n      }\n    }\n    /**\n     * Unique pointer id of the event\n     *\n     * @readonly\n     * @member {number}\n     */\n\n  }, {\n    key: \"pointerId\",\n    get: function get$$1() {\n      return this._pointerId;\n    }\n    /**\n     * State of the tracking data, expressed as bit flags\n     *\n     * @member {number}\n     */\n\n  }, {\n    key: \"flags\",\n    get: function get$$1() {\n      return this._flags;\n    }\n    /**\n     * Set the flags for the tracking data\n     *\n     * @param {number} flags - Flags to set\n     */\n    ,\n    set: function set$$1(flags) {\n      this._flags = flags;\n    }\n    /**\n     * Is the tracked event inactive (not over or down)?\n     *\n     * @member {number}\n     */\n\n  }, {\n    key: \"none\",\n    get: function get$$1() {\n      return this._flags === this.constructor.FLAGS.NONE;\n    }\n    /**\n     * Is the tracked event over the DisplayObject?\n     *\n     * @member {boolean}\n     */\n\n  }, {\n    key: \"over\",\n    get: function get$$1() {\n      return (this._flags & this.constructor.FLAGS.OVER) !== 0;\n    }\n    /**\n     * Set the over flag\n     *\n     * @param {boolean} yn - Is the event over?\n     */\n    ,\n    set: function set$$1(yn) {\n      this._doSet(this.constructor.FLAGS.OVER, yn);\n    }\n    /**\n     * Did the right mouse button come down in the DisplayObject?\n     *\n     * @member {boolean}\n     */\n\n  }, {\n    key: \"rightDown\",\n    get: function get$$1() {\n      return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0;\n    }\n    /**\n     * Set the right down flag\n     *\n     * @param {boolean} yn - Is the right mouse button down?\n     */\n    ,\n    set: function set$$1(yn) {\n      this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn);\n    }\n    /**\n     * Did the left mouse button come down in the DisplayObject?\n     *\n     * @member {boolean}\n     */\n\n  }, {\n    key: \"leftDown\",\n    get: function get$$1() {\n      return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0;\n    }\n    /**\n     * Set the left down flag\n     *\n     * @param {boolean} yn - Is the left mouse button down?\n     */\n    ,\n    set: function set$$1(yn) {\n      this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn);\n    }\n  }]);\n  return InteractionTrackingData;\n}();\n\nInteractionTrackingData.FLAGS = Object.freeze({\n  NONE: 0,\n  OVER: 1 << 0,\n  LEFT_DOWN: 1 << 1,\n  RIGHT_DOWN: 1 << 2\n});\nvar MOUSE_POINTER_ID = 'MOUSE'; // helpers for hitTest() - only used inside hitTest()\n\nvar hitTestEvent = {\n  target: null,\n  data: {\n    global: null\n  }\n};\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @private\n * @class\n * @extends EventDispatcher\n */\n\nvar InteractionManager = function (_EventDispatcher) {\n  inherits(InteractionManager, _EventDispatcher);\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Scene} scene - A reference to the current scene\n   * @param {Camera} camera - A reference to the current camera\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n\n  function InteractionManager(renderer, scene, camera, options) {\n    classCallCheck(this, InteractionManager);\n\n    var _this = possibleConstructorReturn(this, (InteractionManager.__proto__ || Object.getPrototypeOf(InteractionManager)).call(this));\n\n    options = options || {};\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n\n    _this.renderer = renderer;\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Scene}\n     */\n\n    _this.scene = scene;\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Camera}\n     */\n\n    _this.camera = camera;\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default false\n     */\n\n    _this.autoPreventDefault = options.autoPreventDefault || false;\n    /**\n     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n     *\n     * @member {number}\n     * @default 10\n     */\n\n    _this.interactionFrequency = options.interactionFrequency || 10;\n    /**\n     * The mouse data\n     *\n     * @member {InteractionData}\n     */\n\n    _this.mouse = new InteractionData();\n    _this.mouse.identifier = MOUSE_POINTER_ID; // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n\n    _this.mouse.global.set(-999999);\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,InteractionData>}\n     */\n\n\n    _this.activeInteractionData = {};\n    _this.activeInteractionData[MOUSE_POINTER_ID] = _this.mouse;\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {InteractionData[]}\n     */\n\n    _this.interactionDataPool = [];\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n\n    _this.eventData = new InteractionEvent();\n    /**\n     * The DOM element to bind to.\n     *\n     * @private\n     * @member {HTMLElement}\n     */\n\n    _this.interactionDOMElement = null;\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM verison works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how three.js used to work.\n     *\n     * @member {boolean}\n     * @default true\n     */\n\n    _this.moveWhenInside = true;\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @private\n     * @member {boolean}\n     */\n\n    _this.eventsAdded = false;\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @private\n     * @member {boolean}\n     */\n\n    _this.mouseOverRenderer = false;\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n\n    _this.supportsTouchEvents = 'ontouchstart' in window;\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n\n    _this.supportsPointerEvents = !!window.PointerEvent; // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onClick = _this.onClick.bind(_this);\n    _this.processClick = _this.processClick.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerUp = _this.onPointerUp.bind(_this);\n    _this.processPointerUp = _this.processPointerUp.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerCancel = _this.onPointerCancel.bind(_this);\n    _this.processPointerCancel = _this.processPointerCancel.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerDown = _this.onPointerDown.bind(_this);\n    _this.processPointerDown = _this.processPointerDown.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerMove = _this.onPointerMove.bind(_this);\n    _this.processPointerMove = _this.processPointerMove.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerOut = _this.onPointerOut.bind(_this);\n    _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerOver = _this.onPointerOver.bind(_this);\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, (string|Function|Object.<string, string>)>}\n     */\n\n    _this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer'\n    };\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n\n    _this.currentCursorMode = null;\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n\n    _this.cursor = null;\n    /**\n     * ray caster, for survey intersects from 3d-scene\n     *\n     * @private\n     * @member {Raycaster}\n     */\n\n    _this.raycaster = new Raycaster();\n    /**\n     * snippet time\n     *\n     * @private\n     * @member {Number}\n     */\n\n    _this._deltaTime = 0;\n\n    _this.setTargetElement(_this.renderer.domElement);\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event InteractionManager#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event InteractionManager#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event InteractionManager#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event InteractionManager#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event InteractionManager#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event InteractionManager#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link InteractionManager#event:mousedown}.\n     *\n     * @event InteractionManager#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link InteractionManager#event:rightdown}.\n     *\n     * @event InteractionManager#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event InteractionManager#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event InteractionManager#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event InteractionManager#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event InteractionManager#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     *\n     * @event InteractionManager#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event InteractionManager#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event InteractionManager#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link InteractionManager#event:pointerdown}.\n     *\n     * @event InteractionManager#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event InteractionManager#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event InteractionManager#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event InteractionManager#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event InteractionManager#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event InteractionManager#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event InteractionManager#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event InteractionManager#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link InteractionManager#event:touchstart}.\n     *\n     * @event InteractionManager#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event InteractionManager#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link Object3D#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link Object3D#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link Object3D#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n\n    return _this;\n  }\n  /**\n   * Hit tests a point against the display tree, returning the first interactive object that is hit.\n   *\n   * @param {Point} globalPoint - A point to hit test with, in global space.\n   * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n   * to the last rendered root of the associated renderer.\n   * @return {Object3D} The hit display object, if any.\n   */\n\n\n  createClass(InteractionManager, [{\n    key: 'hitTest',\n    value: function hitTest(globalPoint, root) {\n      // clear the target for our hit test\n      hitTestEvent.target = null; // assign the global point\n\n      hitTestEvent.data.global = globalPoint; // ensure safety of the root\n\n      if (!root) {\n        root = this.scene;\n      } // run the hit test\n\n\n      this.processInteractive(hitTestEvent, root, null, true); // return our found object - it'll be null if we didn't hit anything\n\n      return hitTestEvent.target;\n    }\n    /**\n     * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n     * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n     * another DOM element to receive those events.\n     *\n     * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n     */\n\n  }, {\n    key: 'setTargetElement',\n    value: function setTargetElement(element) {\n      this.removeEvents();\n      this.interactionDOMElement = element;\n      this.addEvents();\n    }\n    /**\n     * Registers all the DOM events\n     *\n     * @private\n     */\n\n  }, {\n    key: 'addEvents',\n    value: function addEvents() {\n      if (!this.interactionDOMElement || this.eventsAdded) {\n        return;\n      }\n\n      this.emit('addevents');\n      this.interactionDOMElement.addEventListener('click', this.onClick, true);\n\n      if (window.navigator.msPointerEnabled) {\n        this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n        this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n      } else if (this.supportsPointerEvents) {\n        this.interactionDOMElement.style['touch-action'] = 'none';\n      }\n      /**\n       * These events are added first, so that if pointer events are normalised, they are fired\n       * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n       */\n\n\n      if (this.supportsPointerEvents) {\n        window.document.addEventListener('pointermove', this.onPointerMove, true);\n        this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true); // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n        // we already handle those, so for the purposes of what we do in onPointerOut, we only\n        // care about the pointerleave event\n\n        this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n        this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n        window.addEventListener('pointercancel', this.onPointerCancel, true);\n        window.addEventListener('pointerup', this.onPointerUp, true);\n      } else {\n        window.document.addEventListener('mousemove', this.onPointerMove, true);\n        this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n        this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n        this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n        window.addEventListener('mouseup', this.onPointerUp, true);\n      } // always look directly for touch events so that we can provide original data\n      // In a future version we should change this to being just a fallback and rely solely on\n      // PointerEvents whenever available\n\n\n      if (this.supportsTouchEvents) {\n        this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n        this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n        this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n        this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n      }\n\n      this.eventsAdded = true;\n    }\n    /**\n     * Removes all the DOM events that were previously registered\n     *\n     * @private\n     */\n\n  }, {\n    key: 'removeEvents',\n    value: function removeEvents() {\n      if (!this.interactionDOMElement) {\n        return;\n      }\n\n      this.emit('removeevents');\n      this.interactionDOMElement.removeEventListener('click', this.onClick, true);\n\n      if (window.navigator.msPointerEnabled) {\n        this.interactionDOMElement.style['-ms-content-zooming'] = '';\n        this.interactionDOMElement.style['-ms-touch-action'] = '';\n      } else if (this.supportsPointerEvents) {\n        this.interactionDOMElement.style['touch-action'] = '';\n      }\n\n      if (this.supportsPointerEvents) {\n        window.document.removeEventListener('pointermove', this.onPointerMove, true);\n        this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n        this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n        this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n        window.removeEventListener('pointercancel', this.onPointerCancel, true);\n        window.removeEventListener('pointerup', this.onPointerUp, true);\n      } else {\n        window.document.removeEventListener('mousemove', this.onPointerMove, true);\n        this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n        this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n        this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n        window.removeEventListener('mouseup', this.onPointerUp, true);\n      }\n\n      if (this.supportsTouchEvents) {\n        this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n        this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n        this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n        this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n      }\n\n      this.interactionDOMElement = null;\n      this.eventsAdded = false;\n    }\n    /**\n     * Updates the state of interactive objects.\n     * Invoked by a throttled ticker.\n     *\n     * @param {number} deltaTime - time delta since last tick\n     */\n\n  }, {\n    key: 'update',\n    value: function update(_ref) {\n      var snippet = _ref.snippet;\n      this._deltaTime += snippet;\n\n      if (this._deltaTime < this.interactionFrequency) {\n        return;\n      }\n\n      this._deltaTime = 0;\n\n      if (!this.interactionDOMElement) {\n        return;\n      } // if the user move the mouse this check has already been done using the mouse move!\n\n\n      if (this.didMove) {\n        this.didMove = false;\n        return;\n      }\n\n      this.cursor = null; // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n      // but there was a scenario of a display object moving under a static mouse cursor.\n      // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function\n\n      for (var k in this.activeInteractionData) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (this.activeInteractionData.hasOwnProperty(k)) {\n          var interactionData = this.activeInteractionData[k];\n\n          if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n            var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);\n            this.processInteractive(interactionEvent, this.scene, this.processPointerOverOut, true);\n          }\n        }\n      }\n\n      this.setCursorMode(this.cursor); // TODO\n    }\n    /**\n     * Sets the current cursor mode, handling any callbacks or CSS style changes.\n     *\n     * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n     */\n\n  }, {\n    key: 'setCursorMode',\n    value: function setCursorMode(mode) {\n      mode = mode || 'default'; // if the mode didn't actually change, bail early\n\n      if (this.currentCursorMode === mode) {\n        return;\n      }\n\n      this.currentCursorMode = mode;\n      var style = this.cursorStyles[mode]; // only do things if there is a cursor style for it\n\n      if (style) {\n        switch (typeof style === 'undefined' ? 'undefined' : _typeof(style)) {\n          case 'string':\n            // string styles are handled as cursor CSS\n            this.interactionDOMElement.style.cursor = style;\n            break;\n\n          case 'function':\n            // functions are just called, and passed the cursor mode\n            style(mode);\n            break;\n\n          case 'object':\n            // if it is an object, assume that it is a dictionary of CSS styles,\n            // apply it to the interactionDOMElement\n            Object.assign(this.interactionDOMElement.style, style);\n            break;\n\n          default:\n            break;\n        }\n      } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n        // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n        // for the mode, then assume that the dev wants it to be CSS for the cursor.\n        this.interactionDOMElement.style.cursor = mode;\n      }\n    }\n    /**\n     * Dispatches an event on the display object that was interacted with\n     *\n     * @param {Object3D} displayObject - the display object in question\n     * @param {string} eventString - the name of the event (e.g, mousedown)\n     * @param {object} eventData - the event data object\n     * @private\n     */\n\n  }, {\n    key: 'triggerEvent',\n    value: function triggerEvent(displayObject, eventString, eventData) {\n      if (!eventData.stopped) {\n        eventData.currentTarget = displayObject;\n        eventData.type = eventString;\n        displayObject.emit(eventString, eventData);\n\n        if (displayObject[eventString]) {\n          displayObject[eventString](eventData);\n        }\n      }\n    }\n    /**\n     * This function is provides a neat way of crawling through the scene graph and running a\n     * specified function on all interactive objects it finds. It will also take care of hit\n     * testing the interactive objects and passes the hit across in the function.\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - event containing the point that\n     *  is tested for collision\n     * @param {Object3D} displayObject - the displayObject\n     *  that will be hit test (recursively crawls its children)\n     * @param {Function} [func] - the function that will be called on each interactive object. The\n     *  interactionEvent, displayObject and hit will be passed to the function\n     * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n     * @param {boolean} [interactive] - Whether the displayObject is interactive\n     * @return {boolean} returns true if the displayObject hit the point\n     */\n\n  }, {\n    key: 'processInteractive',\n    value: function processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n      if (!displayObject || !displayObject.visible) {\n        return false;\n      } // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n      //\n      // This function will now loop through all objects and then only hit test the objects it HAS\n      // to, not all of them. MUCH faster..\n      // An object will be hit test if the following is true:\n      //\n      // 1: It is interactive.\n      // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n      //\n      // As another little optimisation once an interactive object has been hit we can carry on\n      // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n      // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n\n      interactive = displayObject.interactive || interactive;\n      var hit = false;\n      var interactiveParent = interactive;\n\n      if (displayObject.interactiveChildren && displayObject.children) {\n        var children = displayObject.children;\n\n        for (var i = children.length - 1; i >= 0; i--) {\n          var child = children[i]; // time to get recursive.. if this function will return if something is hit..\n\n          var childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n\n          if (childHit) {\n            // its a good idea to check if a child has lost its parent.\n            // this means it has been removed whilst looping so its best\n            if (!child.parent) {\n              continue;\n            } // we no longer need to hit test any more objects in this container as we we\n            // now know the parent has been hit\n\n\n            interactiveParent = false; // If the child is interactive , that means that the object hit was actually\n            // interactive and not just the child of an interactive object.\n            // This means we no longer need to hit test anything else. We still need to run\n            // through all objects, but we don't need to perform any hit tests.\n\n            if (childHit) {\n              if (interactionEvent.target) {\n                hitTest = false;\n              }\n\n              hit = true;\n            }\n          }\n        }\n      } // no point running this if the item is not interactive or does not have an interactive parent.\n\n\n      if (interactive) {\n        // if we are hit testing (as in we have no hit any objects yet)\n        // We also don't need to worry about hit testing if once of the displayObjects children\n        // has already been hit - but only if it was interactive, otherwise we need to keep\n        // looking for an interactive child, just in case we hit one\n        if (hitTest && !interactionEvent.target) {\n          if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {\n            hit = true;\n          }\n        }\n\n        if (displayObject.interactive) {\n          if (hit && !interactionEvent.target) {\n            interactionEvent.data.target = interactionEvent.target = displayObject;\n          }\n\n          if (func) {\n            func(interactionEvent, displayObject, !!hit);\n          }\n        }\n      }\n\n      return hit;\n    }\n    /**\n     * Is called when the click is pressed down on the renderer element\n     *\n     * @private\n     * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down\n     */\n\n  }, {\n    key: 'onClick',\n    value: function onClick(originalEvent) {\n      if (originalEvent.type !== 'click') return;\n      var events = this.normalizeToPointerData(originalEvent);\n\n      if (this.autoPreventDefault && events[0].isNormalized) {\n        originalEvent.preventDefault();\n      }\n\n      var interactionData = this.getInteractionDataForPointerId(events[0]);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);\n      interactionEvent.data.originalEvent = originalEvent;\n      this.processInteractive(interactionEvent, this.scene, this.processClick, true);\n      this.emit('click', interactionEvent);\n    }\n    /**\n     * Processes the result of the click check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processClick',\n    value: function processClick(interactionEvent, displayObject, hit) {\n      if (hit) {\n        this.triggerEvent(displayObject, 'click', interactionEvent);\n      }\n    }\n    /**\n     * Is called when the pointer button is pressed down on the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n     */\n\n  }, {\n    key: 'onPointerDown',\n    value: function onPointerDown(originalEvent) {\n      // if we support touch events, then only use those for touch events, not pointer events\n      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n      var events = this.normalizeToPointerData(originalEvent);\n      /**\n       * No need to prevent default on natural pointer events, as there are no side effects\n       * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n       * so still need to be prevented.\n       */\n      // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n      if (this.autoPreventDefault && events[0].isNormalized) {\n        originalEvent.preventDefault();\n      }\n\n      var eventLen = events.length;\n\n      for (var i = 0; i < eventLen; i++) {\n        var event = events[i];\n        var interactionData = this.getInteractionDataForPointerId(event);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n        interactionEvent.data.originalEvent = originalEvent;\n        this.processInteractive(interactionEvent, this.scene, this.processPointerDown, true);\n        this.emit('pointerdown', interactionEvent);\n\n        if (event.pointerType === 'touch') {\n          this.emit('touchstart', interactionEvent);\n        } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n          var isRightButton = event.button === 2;\n          this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n        }\n      }\n    }\n    /**\n     * Processes the result of the pointer down check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerDown',\n    value: function processPointerDown(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n\n      if (hit) {\n        if (!displayObject.trackedPointers[id]) {\n          displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n        }\n\n        this.triggerEvent(displayObject, 'pointerdown', interactionEvent);\n\n        if (data.pointerType === 'touch') {\n          displayObject.started = true;\n          this.triggerEvent(displayObject, 'touchstart', interactionEvent);\n        } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n          var isRightButton = data.button === 2;\n\n          if (isRightButton) {\n            displayObject.trackedPointers[id].rightDown = true;\n          } else {\n            displayObject.trackedPointers[id].leftDown = true;\n          }\n\n          this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n        }\n      }\n    }\n    /**\n     * Is called when the pointer button is released on the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n     * @param {boolean} cancelled - true if the pointer is cancelled\n     * @param {Function} func - Function passed to {@link processInteractive}\n     */\n\n  }, {\n    key: 'onPointerComplete',\n    value: function onPointerComplete(originalEvent, cancelled, func) {\n      var events = this.normalizeToPointerData(originalEvent);\n      var eventLen = events.length; // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n      // in all cases (unless it was a pointercancel)\n\n      var eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n      for (var i = 0; i < eventLen; i++) {\n        var event = events[i];\n        var interactionData = this.getInteractionDataForPointerId(event);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n        interactionEvent.data.originalEvent = originalEvent; // perform hit testing for events targeting our canvas or cancel events\n\n        this.processInteractive(interactionEvent, this.scene, func, cancelled || !eventAppend);\n        this.emit(cancelled ? 'pointercancel' : 'pointerup' + eventAppend, interactionEvent);\n\n        if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n          var isRightButton = event.button === 2;\n          this.emit(isRightButton ? 'rightup' + eventAppend : 'mouseup' + eventAppend, interactionEvent);\n        } else if (event.pointerType === 'touch') {\n          this.emit(cancelled ? 'touchcancel' : 'touchend' + eventAppend, interactionEvent);\n          this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n        }\n      }\n    }\n    /**\n     * Is called when the pointer button is cancelled\n     *\n     * @private\n     * @param {PointerEvent} event - The DOM event of a pointer button being released\n     */\n\n  }, {\n    key: 'onPointerCancel',\n    value: function onPointerCancel(event) {\n      // if we support touch events, then only use those for touch events, not pointer events\n      if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n      this.onPointerComplete(event, true, this.processPointerCancel);\n    }\n    /**\n     * Processes the result of the pointer cancel check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     */\n\n  }, {\n    key: 'processPointerCancel',\n    value: function processPointerCancel(interactionEvent, displayObject) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n\n      if (displayObject.trackedPointers[id] !== undefined) {\n        delete displayObject.trackedPointers[id];\n        this.triggerEvent(displayObject, 'pointercancel', interactionEvent);\n\n        if (data.pointerType === 'touch') {\n          this.triggerEvent(displayObject, 'touchcancel', interactionEvent);\n        }\n      }\n    }\n    /**\n     * Is called when the pointer button is released on the renderer element\n     *\n     * @private\n     * @param {PointerEvent} event - The DOM event of a pointer button being released\n     */\n\n  }, {\n    key: 'onPointerUp',\n    value: function onPointerUp(event) {\n      // if we support touch events, then only use those for touch events, not pointer events\n      if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n      this.onPointerComplete(event, false, this.processPointerUp);\n    }\n    /**\n     * Processes the result of the pointer up check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerUp',\n    value: function processPointerUp(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n      var trackingData = displayObject.trackedPointers[id];\n      var isTouch = data.pointerType === 'touch';\n      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen'; // Mouse only\n\n      if (isMouse) {\n        var isRightButton = data.button === 2;\n        var flags = InteractionTrackingData.FLAGS;\n        var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n        var isDown = trackingData !== undefined && trackingData.flags & test;\n\n        if (hit) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n          if (isDown) {\n            this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);\n          }\n        } else if (isDown) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n        } // update the down state of the tracking data\n\n\n        if (trackingData) {\n          if (isRightButton) {\n            trackingData.rightDown = false;\n          } else {\n            trackingData.leftDown = false;\n          }\n        }\n      } // Pointers and Touches, and Mouse\n\n\n      if (isTouch && displayObject.started) {\n        displayObject.started = false;\n        this.triggerEvent(displayObject, 'touchend', interactionEvent);\n      }\n\n      if (hit) {\n        this.triggerEvent(displayObject, 'pointerup', interactionEvent);\n\n        if (trackingData) {\n          this.triggerEvent(displayObject, 'pointertap', interactionEvent);\n\n          if (isTouch) {\n            this.triggerEvent(displayObject, 'tap', interactionEvent); // touches are no longer over (if they ever were) when we get the touchend\n            // so we should ensure that we don't keep pretending that they are\n\n            trackingData.over = false;\n          }\n        }\n      } else if (trackingData) {\n        this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);\n        if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);\n      } // Only remove the tracking data if there is no over/down state still associated with it\n\n\n      if (trackingData && trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n    /**\n     * Is called when the pointer moves across the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n     */\n\n  }, {\n    key: 'onPointerMove',\n    value: function onPointerMove(originalEvent) {\n      // if we support touch events, then only use those for touch events, not pointer events\n      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n      var events = this.normalizeToPointerData(originalEvent);\n\n      if (events[0].pointerType === 'mouse') {\n        this.didMove = true;\n        this.cursor = null;\n      }\n\n      var eventLen = events.length;\n\n      for (var i = 0; i < eventLen; i++) {\n        var event = events[i];\n        var interactionData = this.getInteractionDataForPointerId(event);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n        interactionEvent.data.originalEvent = originalEvent;\n        var interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n        this.processInteractive(interactionEvent, this.scene, this.processPointerMove, interactive);\n        this.emit('pointermove', interactionEvent);\n        if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n        if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n      }\n\n      if (events[0].pointerType === 'mouse') {\n        this.setCursorMode(this.cursor); // TODO BUG for parents interactive object (border order issue)\n      }\n    }\n    /**\n     * Processes the result of the pointer move check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerMove',\n    value: function processPointerMove(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var isTouch = data.pointerType === 'touch';\n      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n\n      if (isMouse) {\n        this.processPointerOverOut(interactionEvent, displayObject, hit);\n      }\n\n      if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);\n\n      if (!this.moveWhenInside || hit) {\n        this.triggerEvent(displayObject, 'pointermove', interactionEvent);\n        if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);\n      }\n    }\n    /**\n     * Is called when the pointer is moved out of the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n     */\n\n  }, {\n    key: 'onPointerOut',\n    value: function onPointerOut(originalEvent) {\n      // if we support touch events, then only use those for touch events, not pointer events\n      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n      var events = this.normalizeToPointerData(originalEvent); // Only mouse and pointer can call onPointerOut, so events will always be length 1\n\n      var event = events[0];\n\n      if (event.pointerType === 'mouse') {\n        this.mouseOverRenderer = false;\n        this.setCursorMode(null);\n      }\n\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = event;\n      this.processInteractive(interactionEvent, this.scene, this.processPointerOverOut, false);\n      this.emit('pointerout', interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        this.emit('mouseout', interactionEvent);\n      } else {\n        // we can get touchleave events after touchend, so we want to make sure we don't\n        // introduce memory leaks\n        this.releaseInteractionDataForPointerId(interactionData.identifier);\n      }\n    }\n    /**\n     * Processes the result of the pointer over/out check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerOverOut',\n    value: function processPointerOverOut(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n      var trackingData = displayObject.trackedPointers[id]; // if we just moused over the display object, then we need to track that state\n\n      if (hit && !trackingData) {\n        trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n\n      if (trackingData === undefined) return;\n\n      if (hit && this.mouseOverRenderer) {\n        if (!trackingData.over) {\n          trackingData.over = true;\n          this.triggerEvent(displayObject, 'pointerover', interactionEvent);\n\n          if (isMouse) {\n            this.triggerEvent(displayObject, 'mouseover', interactionEvent);\n          }\n        } // only change the cursor if it has not already been changed (by something deeper in the\n        // display tree)\n\n\n        if (isMouse && this.cursor === null) {\n          this.cursor = displayObject.cursor;\n        }\n      } else if (trackingData.over) {\n        trackingData.over = false;\n        this.triggerEvent(displayObject, 'pointerout', this.eventData);\n\n        if (isMouse) {\n          this.triggerEvent(displayObject, 'mouseout', interactionEvent);\n        } // if there is no mouse down information for the pointer, then it is safe to delete\n\n\n        if (trackingData.none) {\n          delete displayObject.trackedPointers[id];\n        }\n      }\n    }\n    /**\n     * Is called when the pointer is moved into the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n     */\n\n  }, {\n    key: 'onPointerOver',\n    value: function onPointerOver(originalEvent) {\n      var events = this.normalizeToPointerData(originalEvent); // Only mouse and pointer can call onPointerOver, so events will always be length 1\n\n      var event = events[0];\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = event;\n\n      if (event.pointerType === 'mouse') {\n        this.mouseOverRenderer = true;\n      }\n\n      this.emit('pointerover', interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        this.emit('mouseover', interactionEvent);\n      }\n    }\n    /**\n     * Get InteractionData for a given pointerId. Store that data as well\n     *\n     * @private\n     * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n     * @return {InteractionData} - Interaction data for the given pointer identifier\n     */\n\n  }, {\n    key: 'getInteractionDataForPointerId',\n    value: function getInteractionDataForPointerId(event) {\n      var pointerId = event.pointerId;\n      var interactionData = void 0;\n\n      if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {\n        interactionData = this.mouse;\n      } else if (this.activeInteractionData[pointerId]) {\n        interactionData = this.activeInteractionData[pointerId];\n      } else {\n        interactionData = this.interactionDataPool.pop() || new InteractionData();\n        interactionData.identifier = pointerId;\n        this.activeInteractionData[pointerId] = interactionData;\n      } // copy properties from the event, so that we can make sure that touch/pointer specific\n      // data is available\n\n\n      interactionData._copyEvent(event);\n\n      return interactionData;\n    }\n    /**\n     * Return unused InteractionData to the pool, for a given pointerId\n     *\n     * @private\n     * @param {number} pointerId - Identifier from a pointer event\n     */\n\n  }, {\n    key: 'releaseInteractionDataForPointerId',\n    value: function releaseInteractionDataForPointerId(pointerId) {\n      var interactionData = this.activeInteractionData[pointerId];\n\n      if (interactionData) {\n        delete this.activeInteractionData[pointerId];\n\n        interactionData._reset();\n\n        this.interactionDataPool.push(interactionData);\n      }\n    }\n    /**\n     * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n     * resulting value is stored in the point. This takes into account the fact that the DOM\n     * element could be scaled and positioned anywhere on the screen.\n     *\n     * @param  {Vector2} point - the point that the result will be stored in\n     * @param  {number} x - the x coord of the position to map\n     * @param  {number} y - the y coord of the position to map\n     */\n\n  }, {\n    key: 'mapPositionToPoint',\n    value: function mapPositionToPoint(point, x, y) {\n      var rect = void 0; // IE 11 fix\n\n      if (!this.interactionDOMElement.parentElement) {\n        rect = {\n          x: 0,\n          y: 0,\n          left: 0,\n          top: 0,\n          width: 0,\n          height: 0\n        };\n      } else {\n        rect = this.interactionDOMElement.getBoundingClientRect();\n      }\n\n      point.x = (x - rect.left) / rect.width * 2 - 1;\n      point.y = -((y - rect.top) / rect.height) * 2 + 1;\n    }\n    /**\n     * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The event to be configured\n     * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n     * @param {InteractionData} interactionData - The InteractionData that will be paired\n     *        with the InteractionEvent\n     * @return {InteractionEvent} the interaction event that was passed in\n     */\n\n  }, {\n    key: 'configureInteractionEventForDOMEvent',\n    value: function configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n      interactionEvent.data = interactionData;\n      this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n      this.raycaster.setFromCamera(interactionData.global, this.camera); // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n\n      if (pointerEvent.pointerType === 'touch') {\n        pointerEvent.globalX = interactionData.global.x;\n        pointerEvent.globalY = interactionData.global.y;\n      }\n\n      interactionData.originalEvent = pointerEvent;\n\n      interactionEvent._reset();\n\n      interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);\n      return interactionEvent;\n    }\n    /**\n     * Ensures that the original event object contains all data that a regular pointer event would have\n     *\n     * @private\n     * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n     * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n     */\n\n  }, {\n    key: 'normalizeToPointerData',\n    value: function normalizeToPointerData(event) {\n      var normalizedEvents = [];\n\n      if (this.supportsTouchEvents && event instanceof TouchEvent) {\n        for (var i = 0, li = event.changedTouches.length; i < li; i++) {\n          var touch = event.changedTouches[i];\n          if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n          if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n\n          if (typeof touch.isPrimary === 'undefined') {\n            touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n          }\n\n          if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n          if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n          if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n          if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n          if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n          if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n          if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n          touch.twist = 0;\n          touch.tangentialPressure = 0; // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n          // support, and the fill ins are not quite the same\n          // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n          // left is not 0,0 on the page\n\n          if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n          if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY; // mark the touch as normalized, just so that we know we did it\n\n          touch.isNormalized = true;\n          normalizedEvents.push(touch);\n        }\n      } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n        if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n        if (typeof event.width === 'undefined') event.width = 1;\n        if (typeof event.height === 'undefined') event.height = 1;\n        if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n        if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n        if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n        if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;\n        if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n        event.twist = 0;\n        event.tangentialPressure = 0; // mark the mouse event as normalized, just so that we know we did it\n\n        event.isNormalized = true;\n        normalizedEvents.push(event);\n      } else {\n        normalizedEvents.push(event);\n      }\n\n      return normalizedEvents;\n    }\n    /**\n     * Destroys the interaction manager\n     *\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.removeEvents();\n      this.removeAllListeners();\n      this.renderer = null;\n      this.mouse = null;\n      this.eventData = null;\n      this.interactionDOMElement = null;\n      this.onPointerDown = null;\n      this.processPointerDown = null;\n      this.onPointerUp = null;\n      this.processPointerUp = null;\n      this.onPointerCancel = null;\n      this.processPointerCancel = null;\n      this.onPointerMove = null;\n      this.processPointerMove = null;\n      this.onPointerOut = null;\n      this.processPointerOverOut = null;\n      this.onPointerOver = null;\n      this._tempPoint = null;\n    }\n  }]);\n  return InteractionManager;\n}(EventDispatcher);\n\nvar MOUSE_POINTER_ID$1 = 'MOUSE'; // helpers for hitTest() - only used inside hitTest()\n\nvar hitTestEvent$1 = {\n  target: null,\n  data: {\n    global: null\n  }\n};\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @private\n * @class\n * @extends EventDispatcher\n */\n\nvar InteractionLayer = function (_EventDispatcher) {\n  inherits(InteractionLayer, _EventDispatcher);\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n\n  function InteractionLayer(renderer, options) {\n    classCallCheck(this, InteractionLayer);\n\n    var _this = possibleConstructorReturn(this, (InteractionLayer.__proto__ || Object.getPrototypeOf(InteractionLayer)).call(this));\n\n    options = options || {};\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n\n    _this.renderer = renderer;\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Layer}\n     */\n\n    _this.layer = null;\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Scene}\n     */\n    // this.scene = scene;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Camera}\n     */\n    // this.camera = camera;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default false\n     */\n\n    _this.autoPreventDefault = options.autoPreventDefault || false;\n    /**\n     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n     *\n     * @member {number}\n     * @default 10\n     */\n\n    _this.interactionFrequency = options.interactionFrequency || 10;\n    /**\n     * The mouse data\n     *\n     * @member {InteractionData}\n     */\n\n    _this.mouse = new InteractionData();\n    _this.mouse.identifier = MOUSE_POINTER_ID$1; // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n\n    _this.mouse.global.set(-999999);\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,InteractionData>}\n     */\n\n\n    _this.activeInteractionData = {};\n    _this.activeInteractionData[MOUSE_POINTER_ID$1] = _this.mouse;\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {InteractionData[]}\n     */\n\n    _this.interactionDataPool = [];\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n\n    _this.eventData = new InteractionEvent();\n    /**\n     * The DOM element to bind to.\n     *\n     * @private\n     * @member {HTMLElement}\n     */\n\n    _this.interactionDOMElement = null;\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM verison works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how three.js used to work.\n     *\n     * @member {boolean}\n     * @default true\n     */\n\n    _this.moveWhenInside = true;\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @private\n     * @member {boolean}\n     */\n\n    _this.eventsAdded = false;\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @private\n     * @member {boolean}\n     */\n\n    _this.mouseOverRenderer = false;\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n\n    _this.supportsTouchEvents = 'ontouchstart' in window;\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n\n    _this.supportsPointerEvents = !!window.PointerEvent; // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onClick = _this.onClick.bind(_this);\n    _this.processClick = _this.processClick.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerUp = _this.onPointerUp.bind(_this);\n    _this.processPointerUp = _this.processPointerUp.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerCancel = _this.onPointerCancel.bind(_this);\n    _this.processPointerCancel = _this.processPointerCancel.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerDown = _this.onPointerDown.bind(_this);\n    _this.processPointerDown = _this.processPointerDown.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerMove = _this.onPointerMove.bind(_this);\n    _this.processPointerMove = _this.processPointerMove.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerOut = _this.onPointerOut.bind(_this);\n    _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);\n    /**\n     * @private\n     * @member {Function}\n     */\n\n    _this.onPointerOver = _this.onPointerOver.bind(_this);\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, (string|Function|Object.<string, string>)>}\n     */\n\n    _this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer'\n    };\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n\n    _this.currentCursorMode = null;\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n\n    _this.cursor = null;\n    /**\n     * ray caster, for survey intersects from 3d-scene\n     *\n     * @private\n     * @member {Raycaster}\n     */\n\n    _this.raycaster = new Raycaster();\n    /**\n     * snippet time\n     *\n     * @private\n     * @member {Number}\n     */\n\n    _this._deltaTime = 0;\n\n    _this.setTargetElement(_this.renderer.domElement);\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event InteractionLayer#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event InteractionLayer#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event InteractionLayer#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event InteractionLayer#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event InteractionLayer#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event InteractionLayer#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link InteractionLayer#event:mousedown}.\n     *\n     * @event InteractionLayer#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link InteractionLayer#event:rightdown}.\n     *\n     * @event InteractionLayer#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event InteractionLayer#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event InteractionLayer#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event InteractionLayer#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event InteractionLayer#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     *\n     * @event InteractionLayer#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event InteractionLayer#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event InteractionLayer#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link InteractionLayer#event:pointerdown}.\n     *\n     * @event InteractionLayer#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event InteractionLayer#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event InteractionLayer#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event InteractionLayer#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event InteractionLayer#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event InteractionLayer#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event InteractionLayer#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event InteractionLayer#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link InteractionLayer#event:touchstart}.\n     *\n     * @event InteractionLayer#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event InteractionLayer#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link Object3D#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link Object3D#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link Object3D#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n\n    return _this;\n  }\n  /**\n   * @return {boolean}\n   */\n\n\n  createClass(InteractionLayer, [{\n    key: 'isAble',\n    value: function isAble() {\n      return this.layer && this.layer.interactive;\n    }\n    /**\n     * set layer\n     * @param {Layer} layer layer\n     */\n\n  }, {\n    key: 'setLayer',\n    value: function setLayer(layer) {\n      this.layer = layer;\n    }\n    /**\n     * Hit tests a point against the display tree, returning the first interactive object that is hit.\n     *\n     * @param {Point} globalPoint - A point to hit test with, in global space.\n     * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n     * to the last rendered root of the associated renderer.\n     * @return {Object3D} The hit display object, if any.\n     */\n\n  }, {\n    key: 'hitTest',\n    value: function hitTest(globalPoint, root) {\n      if (!this.isAble()) return null; // clear the target for our hit test\n\n      hitTestEvent$1.target = null; // assign the global point\n\n      hitTestEvent$1.data.global = globalPoint; // ensure safety of the root\n\n      if (!root) {\n        root = this.layer.scene;\n      } // run the hit test\n\n\n      this.processInteractive(hitTestEvent$1, root, null, true); // return our found object - it'll be null if we didn't hit anything\n\n      return hitTestEvent$1.target;\n    }\n    /**\n     * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n     * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n     * another DOM element to receive those events.\n     *\n     * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n     */\n\n  }, {\n    key: 'setTargetElement',\n    value: function setTargetElement(element) {\n      this.removeEvents();\n      this.interactionDOMElement = element;\n      this.addEvents();\n    }\n    /**\n     * Registers all the DOM events\n     *\n     * @private\n     */\n\n  }, {\n    key: 'addEvents',\n    value: function addEvents() {\n      if (!this.interactionDOMElement || this.eventsAdded) {\n        return;\n      }\n\n      this.emit('addevents');\n      this.interactionDOMElement.addEventListener('click', this.onClick, true);\n\n      if (window.navigator.msPointerEnabled) {\n        this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n        this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n      } else if (this.supportsPointerEvents) {\n        this.interactionDOMElement.style['touch-action'] = 'none';\n      }\n      /**\n       * These events are added first, so that if pointer events are normalised, they are fired\n       * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n       */\n\n\n      if (this.supportsPointerEvents) {\n        window.document.addEventListener('pointermove', this.onPointerMove, true);\n        this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true); // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n        // we already handle those, so for the purposes of what we do in onPointerOut, we only\n        // care about the pointerleave event\n\n        this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n        this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n        window.addEventListener('pointercancel', this.onPointerCancel, true);\n        window.addEventListener('pointerup', this.onPointerUp, true);\n      } else {\n        window.document.addEventListener('mousemove', this.onPointerMove, true);\n        this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n        this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n        this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n        window.addEventListener('mouseup', this.onPointerUp, true);\n      } // always look directly for touch events so that we can provide original data\n      // In a future version we should change this to being just a fallback and rely solely on\n      // PointerEvents whenever available\n\n\n      if (this.supportsTouchEvents) {\n        this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n        this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n        this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n        this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n      }\n\n      this.eventsAdded = true;\n    }\n    /**\n     * Removes all the DOM events that were previously registered\n     *\n     * @private\n     */\n\n  }, {\n    key: 'removeEvents',\n    value: function removeEvents() {\n      if (!this.interactionDOMElement) {\n        return;\n      }\n\n      this.emit('removeevents');\n      this.interactionDOMElement.removeEventListener('click', this.onClick, true);\n\n      if (window.navigator.msPointerEnabled) {\n        this.interactionDOMElement.style['-ms-content-zooming'] = '';\n        this.interactionDOMElement.style['-ms-touch-action'] = '';\n      } else if (this.supportsPointerEvents) {\n        this.interactionDOMElement.style['touch-action'] = '';\n      }\n\n      if (this.supportsPointerEvents) {\n        window.document.removeEventListener('pointermove', this.onPointerMove, true);\n        this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n        this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n        this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n        window.removeEventListener('pointercancel', this.onPointerCancel, true);\n        window.removeEventListener('pointerup', this.onPointerUp, true);\n      } else {\n        window.document.removeEventListener('mousemove', this.onPointerMove, true);\n        this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n        this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n        this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n        window.removeEventListener('mouseup', this.onPointerUp, true);\n      }\n\n      if (this.supportsTouchEvents) {\n        this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n        this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n        this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n        this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n      }\n\n      this.interactionDOMElement = null;\n      this.eventsAdded = false;\n    }\n    /**\n     * Updates the state of interactive objects.\n     * Invoked by a throttled ticker.\n     *\n     * @param {number} deltaTime - time delta since last tick\n     */\n\n  }, {\n    key: 'update',\n    value: function update(_ref) {\n      var snippet = _ref.snippet;\n      if (!this.isAble()) return;\n      this._deltaTime += snippet;\n\n      if (this._deltaTime < this.interactionFrequency) {\n        return;\n      }\n\n      this._deltaTime = 0;\n\n      if (!this.interactionDOMElement) {\n        return;\n      } // if the user move the mouse this check has already been done using the mouse move!\n\n\n      if (this.didMove) {\n        this.didMove = false;\n        return;\n      }\n\n      this.cursor = null; // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n      // but there was a scenario of a display object moving under a static mouse cursor.\n      // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function\n\n      for (var k in this.activeInteractionData) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (this.activeInteractionData.hasOwnProperty(k)) {\n          var interactionData = this.activeInteractionData[k];\n\n          if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n            var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);\n            this.processInteractive(interactionEvent, this.layer.scene, this.processPointerOverOut, true);\n          }\n        }\n      }\n\n      this.setCursorMode(this.cursor); // TODO\n    }\n    /**\n     * Sets the current cursor mode, handling any callbacks or CSS style changes.\n     *\n     * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n     */\n\n  }, {\n    key: 'setCursorMode',\n    value: function setCursorMode(mode) {\n      mode = mode || 'default'; // if the mode didn't actually change, bail early\n\n      if (this.currentCursorMode === mode) {\n        return;\n      }\n\n      this.currentCursorMode = mode;\n      var style = this.cursorStyles[mode]; // only do things if there is a cursor style for it\n\n      if (style) {\n        switch (typeof style === 'undefined' ? 'undefined' : _typeof(style)) {\n          case 'string':\n            // string styles are handled as cursor CSS\n            this.interactionDOMElement.style.cursor = style;\n            break;\n\n          case 'function':\n            // functions are just called, and passed the cursor mode\n            style(mode);\n            break;\n\n          case 'object':\n            // if it is an object, assume that it is a dictionary of CSS styles,\n            // apply it to the interactionDOMElement\n            Object.assign(this.interactionDOMElement.style, style);\n            break;\n\n          default:\n            break;\n        }\n      } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n        // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n        // for the mode, then assume that the dev wants it to be CSS for the cursor.\n        this.interactionDOMElement.style.cursor = mode;\n      }\n    }\n    /**\n     * Dispatches an event on the display object that was interacted with\n     *\n     * @param {Object3D} displayObject - the display object in question\n     * @param {string} eventString - the name of the event (e.g, mousedown)\n     * @param {object} eventData - the event data object\n     * @private\n     */\n\n  }, {\n    key: 'triggerEvent',\n    value: function triggerEvent(displayObject, eventString, eventData) {\n      if (!eventData.stopped) {\n        eventData.currentTarget = displayObject;\n        eventData.type = eventString;\n        displayObject.emit(eventString, eventData);\n\n        if (displayObject[eventString]) {\n          displayObject[eventString](eventData);\n        }\n      }\n    }\n    /**\n     * This function is provides a neat way of crawling through the scene graph and running a\n     * specified function on all interactive objects it finds. It will also take care of hit\n     * testing the interactive objects and passes the hit across in the function.\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - event containing the point that\n     *  is tested for collision\n     * @param {Object3D} displayObject - the displayObject\n     *  that will be hit test (recursively crawls its children)\n     * @param {Function} [func] - the function that will be called on each interactive object. The\n     *  interactionEvent, displayObject and hit will be passed to the function\n     * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n     * @param {boolean} [interactive] - Whether the displayObject is interactive\n     * @return {boolean} returns true if the displayObject hit the point\n     */\n\n  }, {\n    key: 'processInteractive',\n    value: function processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n      if (!displayObject || !displayObject.visible) {\n        return false;\n      } // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n      //\n      // This function will now loop through all objects and then only hit test the objects it HAS\n      // to, not all of them. MUCH faster..\n      // An object will be hit test if the following is true:\n      //\n      // 1: It is interactive.\n      // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n      //\n      // As another little optimisation once an interactive object has been hit we can carry on\n      // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n      // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n\n      interactive = displayObject.interactive || interactive;\n      var hit = false;\n      var interactiveParent = interactive;\n\n      if (displayObject.interactiveChildren && displayObject.children) {\n        var children = displayObject.children;\n\n        for (var i = children.length - 1; i >= 0; i--) {\n          var child = children[i]; // time to get recursive.. if this function will return if something is hit..\n\n          var childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n\n          if (childHit) {\n            // its a good idea to check if a child has lost its parent.\n            // this means it has been removed whilst looping so its best\n            if (!child.parent) {\n              continue;\n            } // we no longer need to hit test any more objects in this container as we we\n            // now know the parent has been hit\n\n\n            interactiveParent = false; // If the child is interactive , that means that the object hit was actually\n            // interactive and not just the child of an interactive object.\n            // This means we no longer need to hit test anything else. We still need to run\n            // through all objects, but we don't need to perform any hit tests.\n\n            if (childHit) {\n              if (interactionEvent.target) {\n                hitTest = false;\n              }\n\n              hit = true;\n            }\n          }\n        }\n      } // no point running this if the item is not interactive or does not have an interactive parent.\n\n\n      if (interactive) {\n        // if we are hit testing (as in we have no hit any objects yet)\n        // We also don't need to worry about hit testing if once of the displayObjects children\n        // has already been hit - but only if it was interactive, otherwise we need to keep\n        // looking for an interactive child, just in case we hit one\n        if (hitTest && !interactionEvent.target) {\n          if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {\n            hit = true;\n          }\n        }\n\n        if (displayObject.interactive) {\n          if (hit && !interactionEvent.target) {\n            interactionEvent.data.target = interactionEvent.target = displayObject;\n          }\n\n          if (func) {\n            func(interactionEvent, displayObject, !!hit);\n          }\n        }\n      }\n\n      return hit;\n    }\n    /**\n     * Is called when the click is pressed down on the renderer element\n     *\n     * @private\n     * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down\n     */\n\n  }, {\n    key: 'onClick',\n    value: function onClick(originalEvent) {\n      if (!this.isAble()) return;\n      if (originalEvent.type !== 'click') return;\n      var events = this.normalizeToPointerData(originalEvent);\n\n      if (this.autoPreventDefault && events[0].isNormalized) {\n        originalEvent.preventDefault();\n      }\n\n      var interactionData = this.getInteractionDataForPointerId(events[0]);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);\n      interactionEvent.data.originalEvent = originalEvent;\n      this.processInteractive(interactionEvent, this.layer.scene, this.processClick, true);\n      this.emit('click', interactionEvent);\n    }\n    /**\n     * Processes the result of the click check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processClick',\n    value: function processClick(interactionEvent, displayObject, hit) {\n      if (hit) {\n        this.triggerEvent(displayObject, 'click', interactionEvent);\n      }\n    }\n    /**\n     * Is called when the pointer button is pressed down on the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n     */\n\n  }, {\n    key: 'onPointerDown',\n    value: function onPointerDown(originalEvent) {\n      if (!this.isAble()) return; // if we support touch events, then only use those for touch events, not pointer events\n\n      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n      var events = this.normalizeToPointerData(originalEvent);\n      /**\n       * No need to prevent default on natural pointer events, as there are no side effects\n       * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n       * so still need to be prevented.\n       */\n      // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n      if (this.autoPreventDefault && events[0].isNormalized) {\n        originalEvent.preventDefault();\n      }\n\n      var eventLen = events.length;\n\n      for (var i = 0; i < eventLen; i++) {\n        var event = events[i];\n        var interactionData = this.getInteractionDataForPointerId(event);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n        interactionEvent.data.originalEvent = originalEvent;\n        this.processInteractive(interactionEvent, this.layer.scene, this.processPointerDown, true);\n        this.emit('pointerdown', interactionEvent);\n\n        if (event.pointerType === 'touch') {\n          this.emit('touchstart', interactionEvent);\n        } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n          var isRightButton = event.button === 2;\n          this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n        }\n      }\n    }\n    /**\n     * Processes the result of the pointer down check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerDown',\n    value: function processPointerDown(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n\n      if (hit) {\n        if (!displayObject.trackedPointers[id]) {\n          displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n        }\n\n        this.triggerEvent(displayObject, 'pointerdown', interactionEvent);\n\n        if (data.pointerType === 'touch') {\n          displayObject.started = true;\n          this.triggerEvent(displayObject, 'touchstart', interactionEvent);\n        } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n          var isRightButton = data.button === 2;\n\n          if (isRightButton) {\n            displayObject.trackedPointers[id].rightDown = true;\n          } else {\n            displayObject.trackedPointers[id].leftDown = true;\n          }\n\n          this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n        }\n      }\n    }\n    /**\n     * Is called when the pointer button is released on the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n     * @param {boolean} cancelled - true if the pointer is cancelled\n     * @param {Function} func - Function passed to {@link processInteractive}\n     */\n\n  }, {\n    key: 'onPointerComplete',\n    value: function onPointerComplete(originalEvent, cancelled, func) {\n      var events = this.normalizeToPointerData(originalEvent);\n      var eventLen = events.length; // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n      // in all cases (unless it was a pointercancel)\n\n      var eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n      for (var i = 0; i < eventLen; i++) {\n        var event = events[i];\n        var interactionData = this.getInteractionDataForPointerId(event);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n        interactionEvent.data.originalEvent = originalEvent; // perform hit testing for events targeting our canvas or cancel events\n\n        this.processInteractive(interactionEvent, this.layer.scene, func, cancelled || !eventAppend);\n        this.emit(cancelled ? 'pointercancel' : 'pointerup' + eventAppend, interactionEvent);\n\n        if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n          var isRightButton = event.button === 2;\n          this.emit(isRightButton ? 'rightup' + eventAppend : 'mouseup' + eventAppend, interactionEvent);\n        } else if (event.pointerType === 'touch') {\n          this.emit(cancelled ? 'touchcancel' : 'touchend' + eventAppend, interactionEvent);\n          this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n        }\n      }\n    }\n    /**\n     * Is called when the pointer button is cancelled\n     *\n     * @private\n     * @param {PointerEvent} event - The DOM event of a pointer button being released\n     */\n\n  }, {\n    key: 'onPointerCancel',\n    value: function onPointerCancel(event) {\n      if (!this.isAble()) return; // if we support touch events, then only use those for touch events, not pointer events\n\n      if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n      this.onPointerComplete(event, true, this.processPointerCancel);\n    }\n    /**\n     * Processes the result of the pointer cancel check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     */\n\n  }, {\n    key: 'processPointerCancel',\n    value: function processPointerCancel(interactionEvent, displayObject) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n\n      if (displayObject.trackedPointers[id] !== undefined) {\n        delete displayObject.trackedPointers[id];\n        this.triggerEvent(displayObject, 'pointercancel', interactionEvent);\n\n        if (data.pointerType === 'touch') {\n          this.triggerEvent(displayObject, 'touchcancel', interactionEvent);\n        }\n      }\n    }\n    /**\n     * Is called when the pointer button is released on the renderer element\n     *\n     * @private\n     * @param {PointerEvent} event - The DOM event of a pointer button being released\n     */\n\n  }, {\n    key: 'onPointerUp',\n    value: function onPointerUp(event) {\n      if (!this.isAble()) return; // if we support touch events, then only use those for touch events, not pointer events\n\n      if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n      this.onPointerComplete(event, false, this.processPointerUp);\n    }\n    /**\n     * Processes the result of the pointer up check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerUp',\n    value: function processPointerUp(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n      var trackingData = displayObject.trackedPointers[id];\n      var isTouch = data.pointerType === 'touch';\n      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen'; // Mouse only\n\n      if (isMouse) {\n        var isRightButton = data.button === 2;\n        var flags = InteractionTrackingData.FLAGS;\n        var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n        var isDown = trackingData !== undefined && trackingData.flags & test;\n\n        if (hit) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n          if (isDown) {\n            this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);\n          }\n        } else if (isDown) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n        } // update the down state of the tracking data\n\n\n        if (trackingData) {\n          if (isRightButton) {\n            trackingData.rightDown = false;\n          } else {\n            trackingData.leftDown = false;\n          }\n        }\n      } // Pointers and Touches, and Mouse\n\n\n      if (isTouch && displayObject.started) {\n        displayObject.started = false;\n        this.triggerEvent(displayObject, 'touchend', interactionEvent);\n      }\n\n      if (hit) {\n        this.triggerEvent(displayObject, 'pointerup', interactionEvent);\n\n        if (trackingData) {\n          this.triggerEvent(displayObject, 'pointertap', interactionEvent);\n\n          if (isTouch) {\n            this.triggerEvent(displayObject, 'tap', interactionEvent); // touches are no longer over (if they ever were) when we get the touchend\n            // so we should ensure that we don't keep pretending that they are\n\n            trackingData.over = false;\n          }\n        }\n      } else if (trackingData) {\n        this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);\n        if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);\n      } // Only remove the tracking data if there is no over/down state still associated with it\n\n\n      if (trackingData && trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n    /**\n     * Is called when the pointer moves across the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n     */\n\n  }, {\n    key: 'onPointerMove',\n    value: function onPointerMove(originalEvent) {\n      if (!this.isAble()) return; // if we support touch events, then only use those for touch events, not pointer events\n\n      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n      var events = this.normalizeToPointerData(originalEvent);\n\n      if (events[0].pointerType === 'mouse') {\n        this.didMove = true;\n        this.cursor = null;\n      }\n\n      var eventLen = events.length;\n\n      for (var i = 0; i < eventLen; i++) {\n        var event = events[i];\n        var interactionData = this.getInteractionDataForPointerId(event);\n        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n        interactionEvent.data.originalEvent = originalEvent;\n        var interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n        this.processInteractive(interactionEvent, this.layer.scene, this.processPointerMove, interactive);\n        this.emit('pointermove', interactionEvent);\n        if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n        if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n      }\n\n      if (events[0].pointerType === 'mouse') {\n        this.setCursorMode(this.cursor); // TODO BUG for parents interactive object (border order issue)\n      }\n    }\n    /**\n     * Processes the result of the pointer move check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerMove',\n    value: function processPointerMove(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var isTouch = data.pointerType === 'touch';\n      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n\n      if (isMouse) {\n        this.processPointerOverOut(interactionEvent, displayObject, hit);\n      }\n\n      if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);\n\n      if (!this.moveWhenInside || hit) {\n        this.triggerEvent(displayObject, 'pointermove', interactionEvent);\n        if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);\n      }\n    }\n    /**\n     * Is called when the pointer is moved out of the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n     */\n\n  }, {\n    key: 'onPointerOut',\n    value: function onPointerOut(originalEvent) {\n      if (!this.isAble()) return; // if we support touch events, then only use those for touch events, not pointer events\n\n      if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n      var events = this.normalizeToPointerData(originalEvent); // Only mouse and pointer can call onPointerOut, so events will always be length 1\n\n      var event = events[0];\n\n      if (event.pointerType === 'mouse') {\n        this.mouseOverRenderer = false;\n        this.setCursorMode(null);\n      }\n\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = event;\n      this.processInteractive(interactionEvent, this.layer.scene, this.processPointerOverOut, false);\n      this.emit('pointerout', interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        this.emit('mouseout', interactionEvent);\n      } else {\n        // we can get touchleave events after touchend, so we want to make sure we don't\n        // introduce memory leaks\n        this.releaseInteractionDataForPointerId(interactionData.identifier);\n      }\n    }\n    /**\n     * Processes the result of the pointer over/out check and dispatches the event if need be\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n     * @param {Object3D} displayObject - The display object that was tested\n     * @param {boolean} hit - the result of the hit test on the display object\n     */\n\n  }, {\n    key: 'processPointerOverOut',\n    value: function processPointerOverOut(interactionEvent, displayObject, hit) {\n      var data = interactionEvent.data;\n      var id = interactionEvent.data.identifier;\n      var isMouse = data.pointerType === 'mouse' || data.pointerType === 'pen';\n      var trackingData = displayObject.trackedPointers[id]; // if we just moused over the display object, then we need to track that state\n\n      if (hit && !trackingData) {\n        trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n\n      if (trackingData === undefined) return;\n\n      if (hit && this.mouseOverRenderer) {\n        if (!trackingData.over) {\n          trackingData.over = true;\n          this.triggerEvent(displayObject, 'pointerover', interactionEvent);\n\n          if (isMouse) {\n            this.triggerEvent(displayObject, 'mouseover', interactionEvent);\n          }\n        } // only change the cursor if it has not already been changed (by something deeper in the\n        // display tree)\n\n\n        if (isMouse && this.cursor === null) {\n          this.cursor = displayObject.cursor;\n        }\n      } else if (trackingData.over) {\n        trackingData.over = false;\n        this.triggerEvent(displayObject, 'pointerout', this.eventData);\n\n        if (isMouse) {\n          this.triggerEvent(displayObject, 'mouseout', interactionEvent);\n        } // if there is no mouse down information for the pointer, then it is safe to delete\n\n\n        if (trackingData.none) {\n          delete displayObject.trackedPointers[id];\n        }\n      }\n    }\n    /**\n     * Is called when the pointer is moved into the renderer element\n     *\n     * @private\n     * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n     */\n\n  }, {\n    key: 'onPointerOver',\n    value: function onPointerOver(originalEvent) {\n      if (!this.isAble()) return;\n      var events = this.normalizeToPointerData(originalEvent); // Only mouse and pointer can call onPointerOver, so events will always be length 1\n\n      var event = events[0];\n      var interactionData = this.getInteractionDataForPointerId(event);\n      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n      interactionEvent.data.originalEvent = event;\n\n      if (event.pointerType === 'mouse') {\n        this.mouseOverRenderer = true;\n      }\n\n      this.emit('pointerover', interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        this.emit('mouseover', interactionEvent);\n      }\n    }\n    /**\n     * Get InteractionData for a given pointerId. Store that data as well\n     *\n     * @private\n     * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n     * @return {InteractionData} - Interaction data for the given pointer identifier\n     */\n\n  }, {\n    key: 'getInteractionDataForPointerId',\n    value: function getInteractionDataForPointerId(event) {\n      var pointerId = event.pointerId;\n      var interactionData = void 0;\n\n      if (pointerId === MOUSE_POINTER_ID$1 || event.pointerType === 'mouse') {\n        interactionData = this.mouse;\n      } else if (this.activeInteractionData[pointerId]) {\n        interactionData = this.activeInteractionData[pointerId];\n      } else {\n        interactionData = this.interactionDataPool.pop() || new InteractionData();\n        interactionData.identifier = pointerId;\n        this.activeInteractionData[pointerId] = interactionData;\n      } // copy properties from the event, so that we can make sure that touch/pointer specific\n      // data is available\n\n\n      interactionData._copyEvent(event);\n\n      return interactionData;\n    }\n    /**\n     * Return unused InteractionData to the pool, for a given pointerId\n     *\n     * @private\n     * @param {number} pointerId - Identifier from a pointer event\n     */\n\n  }, {\n    key: 'releaseInteractionDataForPointerId',\n    value: function releaseInteractionDataForPointerId(pointerId) {\n      var interactionData = this.activeInteractionData[pointerId];\n\n      if (interactionData) {\n        delete this.activeInteractionData[pointerId];\n\n        interactionData._reset();\n\n        this.interactionDataPool.push(interactionData);\n      }\n    }\n    /**\n     * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n     * resulting value is stored in the point. This takes into account the fact that the DOM\n     * element could be scaled and positioned anywhere on the screen.\n     *\n     * @param  {Vector2} point - the point that the result will be stored in\n     * @param  {number} x - the x coord of the position to map\n     * @param  {number} y - the y coord of the position to map\n     */\n\n  }, {\n    key: 'mapPositionToPoint',\n    value: function mapPositionToPoint(point, x, y) {\n      var rect = void 0; // IE 11 fix\n\n      if (!this.interactionDOMElement.parentElement) {\n        rect = {\n          x: 0,\n          y: 0,\n          left: 0,\n          top: 0,\n          width: 0,\n          height: 0\n        };\n      } else {\n        rect = this.interactionDOMElement.getBoundingClientRect();\n      }\n\n      point.x = (x - rect.left) / rect.width * 2 - 1;\n      point.y = -((y - rect.top) / rect.height) * 2 + 1;\n    }\n    /**\n     * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n     *\n     * @private\n     * @param {InteractionEvent} interactionEvent - The event to be configured\n     * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n     * @param {InteractionData} interactionData - The InteractionData that will be paired\n     *        with the InteractionEvent\n     * @return {InteractionEvent} the interaction event that was passed in\n     */\n\n  }, {\n    key: 'configureInteractionEventForDOMEvent',\n    value: function configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n      interactionEvent.data = interactionData;\n      this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n      if (this.layer && this.layer.interactive) this.raycaster.setFromCamera(interactionData.global, this.layer.camera); // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n\n      if (pointerEvent.pointerType === 'touch') {\n        pointerEvent.globalX = interactionData.global.x;\n        pointerEvent.globalY = interactionData.global.y;\n      }\n\n      interactionData.originalEvent = pointerEvent;\n\n      interactionEvent._reset();\n\n      interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);\n      return interactionEvent;\n    }\n    /**\n     * Ensures that the original event object contains all data that a regular pointer event would have\n     *\n     * @private\n     * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n     * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n     */\n\n  }, {\n    key: 'normalizeToPointerData',\n    value: function normalizeToPointerData(event) {\n      var normalizedEvents = [];\n\n      if (this.supportsTouchEvents && event instanceof TouchEvent) {\n        for (var i = 0, li = event.changedTouches.length; i < li; i++) {\n          var touch = event.changedTouches[i];\n          if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n          if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n\n          if (typeof touch.isPrimary === 'undefined') {\n            touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n          }\n\n          if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n          if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n          if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n          if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n          if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n          if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n          if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n          touch.twist = 0;\n          touch.tangentialPressure = 0; // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n          // support, and the fill ins are not quite the same\n          // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n          // left is not 0,0 on the page\n\n          if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n          if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY; // mark the touch as normalized, just so that we know we did it\n\n          touch.isNormalized = true;\n          normalizedEvents.push(touch);\n        }\n      } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n        if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n        if (typeof event.width === 'undefined') event.width = 1;\n        if (typeof event.height === 'undefined') event.height = 1;\n        if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n        if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n        if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n        if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID$1;\n        if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n        event.twist = 0;\n        event.tangentialPressure = 0; // mark the mouse event as normalized, just so that we know we did it\n\n        event.isNormalized = true;\n        normalizedEvents.push(event);\n      } else {\n        normalizedEvents.push(event);\n      }\n\n      return normalizedEvents;\n    }\n    /**\n     * Destroys the interaction manager\n     *\n     */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.removeEvents();\n      this.removeAllListeners();\n      this.renderer = null;\n      this.mouse = null;\n      this.eventData = null;\n      this.interactionDOMElement = null;\n      this.onPointerDown = null;\n      this.processPointerDown = null;\n      this.onPointerUp = null;\n      this.processPointerUp = null;\n      this.onPointerCancel = null;\n      this.processPointerCancel = null;\n      this.onPointerMove = null;\n      this.processPointerMove = null;\n      this.onPointerOut = null;\n      this.processPointerOverOut = null;\n      this.onPointerOver = null;\n      this._tempPoint = null;\n    }\n  }]);\n  return InteractionLayer;\n}(EventDispatcher);\n\n(function () {\n  var lastTime = 0;\n  var vendors = ['ms', 'moz', 'webkit', 'o'];\n\n  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = function (callback) {\n      var currTime = new Date().getTime();\n      var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n      var id = window.setTimeout(function () {\n        callback(currTime + timeToCall);\n      }, timeToCall);\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n  }\n\n  if (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = function (id) {\n      clearTimeout(id);\n    };\n  }\n\n  window.RAF = window.requestAnimationFrame;\n  window.CAF = window.cancelAnimationFrame;\n})();\n/**\n * @extends EventDispatcher\n */\n\n\nvar Ticker = function (_EventDispatcher) {\n  inherits(Ticker, _EventDispatcher);\n  /**\n   *\n   */\n\n  function Ticker() {\n    classCallCheck(this, Ticker);\n\n    var _this = possibleConstructorReturn(this, (Ticker.__proto__ || Object.getPrototypeOf(Ticker)).call(this));\n\n    _this.timer = null;\n    _this.started = false;\n    /**\n     * pre-time cache\n     *\n     * @member {Number}\n     * @private\n     */\n\n    _this.pt = 0;\n    /**\n     * how long the time through, at this tick\n     *\n     * @member {Number}\n     * @private\n     */\n\n    _this.snippet = 0;\n\n    _this.start();\n\n    return _this;\n  }\n  /**\n   * start tick loop\n   */\n\n\n  createClass(Ticker, [{\n    key: 'start',\n    value: function start() {\n      var _this2 = this;\n\n      if (this.started) return;\n\n      var loop = function loop() {\n        _this2.timeline();\n\n        _this2.emit('tick', {\n          snippet: _this2.snippet\n        });\n\n        _this2.timer = RAF(loop);\n      };\n\n      loop();\n    }\n    /**\n     * stop tick loop\n     */\n\n  }, {\n    key: 'stop',\n    value: function stop() {\n      CAF(this.timer);\n      this.started = false;\n    }\n    /**\n     * get timeline snippet\n     *\n     * @private\n     */\n\n  }, {\n    key: 'timeline',\n    value: function timeline() {\n      this.snippet = Date.now() - this.pt;\n\n      if (this.pt === 0 || this.snippet > 200) {\n        this.pt = Date.now();\n        this.snippet = Date.now() - this.pt;\n      }\n\n      this.pt += this.snippet;\n    }\n  }]);\n  return Ticker;\n}(EventDispatcher);\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @example\n * import { Scene, PerspectiveCamera, WebGLRenderer, Mesh, BoxGeometry, MeshBasicMaterial } from 'three';\n * import { Interaction } from 'three.interaction';\n * const renderer = new WebGLRenderer({ canvas: canvasElement });\n * const scene = new Scene();\n * const camera = new PerspectiveCamera(60, width / height, 0.1, 100);\n *\n * const interaction = new Interaction(renderer, scene, camera);\n * // then you can bind every interaction event with any mesh which you had `add` into `scene` before\n * const cube = new Mesh(\n *   new BoxGeometry(1, 1, 1),\n *   new MeshBasicMaterial({ color: 0xffffff }),\n * );\n * scene.add(cube);\n * cube.on('touchstart', ev => {\n *   console.log(ev);\n * });\n *\n * cube.on('mousedown', ev => {\n *   console.log(ev);\n * });\n *\n * cube.on('pointerdown', ev => {\n *   console.log(ev);\n * });\n * // and so on ...\n *\n * // you can also listen on parent-node or any display-tree node,\n * // source event will bubble up along with display-tree.\n * // you can stop the bubble-up by invoke ev.stopPropagation function.\n * scene.on('touchstart', ev => {\n *   console.log(ev);\n * })\n *\n * @class\n * @extends InteractionManager\n */\n\n\nvar Interaction = function (_InteractionManager) {\n  inherits(Interaction, _InteractionManager);\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Scene} scene - A reference to the current scene\n   * @param {Camera} camera - A reference to the current camera\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=false] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n\n  function Interaction(renderer, scene, camera, options) {\n    classCallCheck(this, Interaction);\n    options = Object.assign({\n      autoAttach: false\n    }, options);\n    /**\n     * a ticker\n     *\n     * @private\n     * @member {Ticker}\n     */\n\n    var _this = possibleConstructorReturn(this, (Interaction.__proto__ || Object.getPrototypeOf(Interaction)).call(this, renderer, scene, camera, options));\n\n    _this.ticker = new Ticker();\n    /**\n     * update for some over event\n     *\n     * @private\n     */\n\n    _this.update = _this.update.bind(_this);\n\n    _this.on('addevents', function () {\n      _this.ticker.on('tick', _this.update);\n    });\n\n    _this.on('removeevents', function () {\n      _this.ticker.off('tick', _this.update);\n    });\n\n    _this.setTargetElement(_this.renderer.domElement);\n\n    return _this;\n  }\n\n  return Interaction;\n}(InteractionManager);\n\nexport { InteractionManager, InteractionLayer, Interaction };","map":{"version":3,"sources":["../src/utils/Utils.js","../src/patch/EventDispatcher.js","../src/patch/Object3D.js","../src/interaction/InteractionData.js","../src/interaction/InteractionEvent.js","../src/interaction/InteractionTrackingData.js","../src/interaction/InteractionManager.js","../src/interaction/InteractionLayer.js","../src/utils/Raf.js","../src/utils/Ticker.js","../src/interaction/Interaction.js"],"names":["Object","Utils","ks","_rt","EventDispatcher","cb","argument","cbs","cache","i","Object3D","result","InteractionData","event","InteractionEvent","InteractionTrackingData","flag","yn","flags","MOUSE_POINTER_ID","hitTestEvent","InteractionManager","options","window","globalPoint","root","element","snippet","interactionData","interactionEvent","mode","style","displayObject","eventString","eventData","func","hitTest","interactive","hit","interactiveParent","children","child","childHit","originalEvent","events","eventLen","isRightButton","data","id","cancelled","eventAppend","trackingData","isTouch","isMouse","test","isDown","pointerId","point","x","y","rect","pointerEvent","normalizedEvents","li","touch","InteractionLayer","layer","lastTime","vendors","currTime","timeToCall","Math","Ticker","loop","RAF","Date","Interaction","autoAttach"],"mappings":"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","sourcesContent":["/**\n * get variable type\n * @param {*} val a variable which you want to get the type\n * @return {String} variable-type\n */\nfunction _rt(val) {\n  return Object.prototype.toString.call(val);\n}\n\n/**\n * Utils tool box\n *\n * @namespace Utils\n */\nexport const Utils = {\n  /**\n   * determine whether it is a `Function`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isFunction: (function() {\n    const ks = _rt(function() {});\n    return function(variable) {\n      return _rt(variable) === ks;\n    };\n  })(),\n\n\n  /**\n   * determine whether it is a `undefined`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isUndefined(variable) {\n    return typeof variable === 'undefined';\n  },\n};\n","import { EventDispatcher, Object3D } from 'three';\nimport { Utils } from '../utils/Utils.js';\n\n/**\n * proxy `addEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\nEventDispatcher.prototype.on = function(type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  if (this instanceof Object3D) this.interactive = true;\n  this.addEventListener(type, fn);\n  return this;\n};\n\n/**\n * proxy `removeEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback, which you had bind before\n * @return {this} this\n */\nEventDispatcher.prototype.off = function(type, fn) {\n  this.removeEventListener(type, fn);\n  return this;\n};\n\n/**\n * binding a once event, just emit once time\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\nEventDispatcher.prototype.once = function(type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  const cb = (ev) => {\n    fn(ev);\n    this.off(type, cb);\n  };\n  this.on(type, cb);\n  return this;\n};\n\n/**\n * emit a event\n *\n * @param {String} type event type, evnet name\n * @return {this} this\n */\nEventDispatcher.prototype.emit = function(type, ...argument) {\n  if (this._listeners === undefined || Utils.isUndefined(this._listeners[type])) return;\n  const cbs = this._listeners[type] || [];\n  const cache = cbs.slice(0);\n\n  for (let i = 0; i < cache.length; i++) {\n    cache[i].apply(this, argument);\n  }\n  return this;\n};\n\n","import { Object3D } from 'three';\n\n/**\n * whether displayObject is interactively\n */\nObject3D.prototype.interactive = false;\n\n/**\n * whether displayObject's children is interactively\n */\nObject3D.prototype.interactiveChildren = true;\n\n/**\n * whether displayObject had touchstart\n * @private\n */\nObject3D.prototype.started = false;\n\n/**\n * tracked event cache, like: touchend、mouseout、pointerout which decided by primary-event\n */\nObject.defineProperty(Object3D.prototype, 'trackedPointers', {\n  get() {\n    if (!this._trackedPointers) this._trackedPointers = {};\n    return this._trackedPointers;\n  },\n});\n\n/**\n * dispatch a raycast\n *\n * @param {Raycaster} raycaster Raycaster object, get from THREE.Raycaster\n * @return {Object|Boolean} had pass hit-test\n */\nObject3D.prototype.raycastTest = function(raycaster) {\n  const result = [];\n  this.raycast(raycaster, result);\n\n  if (result.length > 0) {\n    return result[0];\n  }\n\n  return false;\n};\n","import { Vector2 } from 'three';\n\n/**\n * Holds all information related to an Interaction event\n *\n * @class\n */\nclass InteractionData {\n  /**\n   * InteractionData constructor\n   */\n  constructor() {\n    /**\n     * This point stores the global coords of where the touch/mouse event happened\n     *\n     * @member {Vector2}\n     */\n    this.global = new Vector2();\n\n    /**\n     * The target DisplayObject that was interacted with\n     *\n     * @member {Object3D}\n     */\n    this.target = null;\n\n    /**\n     * When passed to an event handler, this will be the original DOM Event that was captured\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent\n     * @member {MouseEvent|TouchEvent|PointerEvent}\n     */\n    this.originalEvent = null;\n\n    /**\n     * Unique identifier for this interaction\n     *\n     * @member {number}\n     */\n    this.identifier = null;\n\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     * @type {Boolean}\n     */\n    this.isPrimary = false;\n\n    /**\n     * Indicates which button was pressed on the mouse or pointer device to trigger the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n     * @type {number}\n     */\n    this.button = 0;\n\n    /**\n     * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n     * @type {number}\n     */\n    this.buttons = 0;\n\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     * @type {number}\n     */\n    this.width = 0;\n\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     * @type {number}\n     */\n    this.height = 0;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n     * @type {number}\n     */\n    this.tiltX = 0;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n     * @type {number}\n     */\n    this.tiltY = 0;\n\n    /**\n     * The type of pointer that triggered the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     * @type {string}\n     */\n    this.pointerType = null;\n\n    /**\n     * Pressure applied by the pointing device during the event. A Touch's force property\n     * will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     * @type {number}\n     */\n    this.pressure = 0;\n\n    /**\n     * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle\n     * @type {number}\n     */\n    this.rotationAngle = 0;\n\n    /**\n     * Twist of a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n    this.twist = 0;\n\n    /**\n     * Barrel pressure on a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n    this.tangentialPressure = 0;\n  }\n\n  /**\n   * The unique identifier of the pointer. It will be the same as `identifier`.\n   * @readonly\n   * @member {number}\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId\n   */\n  get pointerId() {\n    return this.identifier;\n  }\n\n  /**\n   * Copies properties from normalized event data.\n   *\n   * @param {Touch|MouseEvent|PointerEvent} event The normalized event data\n   * @private\n   */\n  _copyEvent(event) {\n    // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite\n    // it with \"false\" on later events when our shim for it on touch events might not be\n    // accurate\n    if (event.isPrimary) {\n      this.isPrimary = true;\n    }\n    this.button = event.button;\n    this.buttons = event.buttons;\n    this.width = event.width;\n    this.height = event.height;\n    this.tiltX = event.tiltX;\n    this.tiltY = event.tiltY;\n    this.pointerType = event.pointerType;\n    this.pressure = event.pressure;\n    this.rotationAngle = event.rotationAngle;\n    this.twist = event.twist || 0;\n    this.tangentialPressure = event.tangentialPressure || 0;\n  }\n\n  /**\n   * Resets the data for pooling.\n   *\n   * @private\n   */\n  _reset() {\n    // isPrimary is the only property that we really need to reset - everything else is\n    // guaranteed to be overwritten\n    this.isPrimary = false;\n  }\n}\n\nexport default InteractionData;\n","/**\n * Event class that mimics native DOM events.\n *\n * @class\n */\nclass InteractionEvent {\n  /**\n   * InteractionEvent constructor\n   */\n  constructor() {\n    /**\n     * Whether this event will continue propagating in the tree\n     *\n     * @member {boolean}\n     */\n    this.stopped = false;\n\n    /**\n     * The object which caused this event to be dispatched.\n     *\n     * @member {Object3D}\n     */\n    this.target = null;\n\n    /**\n     * The object whose event listener’s callback is currently being invoked.\n     *\n     * @member {Object3D}\n     */\n    this.currentTarget = null;\n\n    /**\n     * Type of the event\n     *\n     * @member {string}\n     */\n    this.type = null;\n\n    /**\n     * InteractionData related to this event\n     *\n     * @member {InteractionData}\n     */\n    this.data = null;\n\n    /**\n     * ray caster detial from 3d-mesh\n     *\n     * @member {Intersects}\n     */\n    this.intersects = [];\n  }\n\n  /**\n   * Prevents event from reaching any objects other than the current object.\n   *\n   */\n  stopPropagation() {\n    this.stopped = true;\n  }\n\n  /**\n   * Resets the event.\n   *\n   * @private\n   */\n  _reset() {\n    this.stopped = false;\n    this.currentTarget = null;\n    this.target = null;\n    this.intersects = [];\n  }\n}\n\nexport default InteractionEvent;\n","/**\n * DisplayObjects with the `trackedPointers` property use this class to track interactions\n *\n * @class\n * @private\n */\nexport default class InteractionTrackingData {\n  /**\n   * @param {number} pointerId - Unique pointer id of the event\n   */\n  constructor(pointerId) {\n    this._pointerId = pointerId;\n    this._flags = InteractionTrackingData.FLAGS.NONE;\n  }\n\n  /**\n   *\n   * @private\n   * @param {number} flag - The interaction flag to set\n   * @param {boolean} yn - Should the flag be set or unset\n   */\n  _doSet(flag, yn) {\n    if (yn) {\n      this._flags = this._flags | flag;\n    } else {\n      this._flags = this._flags & (~flag);\n    }\n  }\n\n  /**\n   * Unique pointer id of the event\n   *\n   * @readonly\n   * @member {number}\n   */\n  get pointerId() {\n    return this._pointerId;\n  }\n\n  /**\n   * State of the tracking data, expressed as bit flags\n   *\n   * @member {number}\n   */\n  get flags() {\n    return this._flags;\n  }\n\n  /**\n   * Set the flags for the tracking data\n   *\n   * @param {number} flags - Flags to set\n   */\n  set flags(flags) {\n    this._flags = flags;\n  }\n\n  /**\n   * Is the tracked event inactive (not over or down)?\n   *\n   * @member {number}\n   */\n  get none() {\n    return this._flags === this.constructor.FLAGS.NONE;\n  }\n\n  /**\n   * Is the tracked event over the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get over() {\n    return (this._flags & this.constructor.FLAGS.OVER) !== 0;\n  }\n\n  /**\n   * Set the over flag\n   *\n   * @param {boolean} yn - Is the event over?\n   */\n  set over(yn) {\n    this._doSet(this.constructor.FLAGS.OVER, yn);\n  }\n\n  /**\n   * Did the right mouse button come down in the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get rightDown() {\n    return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0;\n  }\n\n  /**\n   * Set the right down flag\n   *\n   * @param {boolean} yn - Is the right mouse button down?\n   */\n  set rightDown(yn) {\n    this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn);\n  }\n\n  /**\n   * Did the left mouse button come down in the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get leftDown() {\n    return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0;\n  }\n\n  /**\n   * Set the left down flag\n   *\n   * @param {boolean} yn - Is the left mouse button down?\n   */\n  set leftDown(yn) {\n    this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn);\n  }\n}\n\nInteractionTrackingData.FLAGS = Object.freeze({\n  NONE: 0,\n  OVER: 1 << 0,\n  LEFT_DOWN: 1 << 1,\n  RIGHT_DOWN: 1 << 2,\n});\n","import '../patch/EventDispatcher';\nimport '../patch/Object3D';\n\nimport { EventDispatcher, Raycaster } from 'three';\nimport InteractionData from './InteractionData';\nimport InteractionEvent from './InteractionEvent';\nimport InteractionTrackingData from './InteractionTrackingData';\n\nconst MOUSE_POINTER_ID = 'MOUSE';\n\n// helpers for hitTest() - only used inside hitTest()\nconst hitTestEvent = {\n  target: null,\n  data: {\n    global: null,\n  },\n};\n\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @private\n * @class\n * @extends EventDispatcher\n */\nclass InteractionManager extends EventDispatcher {\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Scene} scene - A reference to the current scene\n   * @param {Camera} camera - A reference to the current camera\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n  constructor(renderer, scene, camera, options) {\n    super();\n\n    options = options || {};\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Scene}\n     */\n    this.scene = scene;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Camera}\n     */\n    this.camera = camera;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.autoPreventDefault = options.autoPreventDefault || false;\n\n    /**\n     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n     *\n     * @member {number}\n     * @default 10\n     */\n    this.interactionFrequency = options.interactionFrequency || 10;\n\n    /**\n     * The mouse data\n     *\n     * @member {InteractionData}\n     */\n    this.mouse = new InteractionData();\n    this.mouse.identifier = MOUSE_POINTER_ID;\n\n    // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n    this.mouse.global.set(-999999);\n\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,InteractionData>}\n     */\n    this.activeInteractionData = {};\n    this.activeInteractionData[MOUSE_POINTER_ID] = this.mouse;\n\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {InteractionData[]}\n     */\n    this.interactionDataPool = [];\n\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n    this.eventData = new InteractionEvent();\n\n    /**\n     * The DOM element to bind to.\n     *\n     * @private\n     * @member {HTMLElement}\n     */\n    this.interactionDOMElement = null;\n\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM verison works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how three.js used to work.\n     *\n     * @member {boolean}\n     * @default true\n     */\n    this.moveWhenInside = true;\n\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.eventsAdded = false;\n\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.mouseOverRenderer = false;\n\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsTouchEvents = 'ontouchstart' in window;\n\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsPointerEvents = !!window.PointerEvent;\n\n    // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onClick = this.onClick.bind(this);\n    this.processClick = this.processClick.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.processPointerUp = this.processPointerUp.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerCancel = this.onPointerCancel.bind(this);\n    this.processPointerCancel = this.processPointerCancel.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.processPointerDown = this.processPointerDown.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.processPointerMove = this.processPointerMove.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOut = this.onPointerOut.bind(this);\n    this.processPointerOverOut = this.processPointerOverOut.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOver = this.onPointerOver.bind(this);\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, (string|Function|Object.<string, string>)>}\n     */\n    this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer',\n    };\n\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n    this.currentCursorMode = null;\n\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n    this.cursor = null;\n\n    /**\n     * ray caster, for survey intersects from 3d-scene\n     *\n     * @private\n     * @member {Raycaster}\n     */\n    this.raycaster = new Raycaster();\n\n    /**\n     * snippet time\n     *\n     * @private\n     * @member {Number}\n     */\n    this._deltaTime = 0;\n\n    this.setTargetElement(this.renderer.domElement);\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event InteractionManager#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event InteractionManager#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event InteractionManager#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event InteractionManager#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event InteractionManager#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event InteractionManager#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link InteractionManager#event:mousedown}.\n     *\n     * @event InteractionManager#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link InteractionManager#event:rightdown}.\n     *\n     * @event InteractionManager#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event InteractionManager#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event InteractionManager#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event InteractionManager#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event InteractionManager#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     *\n     * @event InteractionManager#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event InteractionManager#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event InteractionManager#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link InteractionManager#event:pointerdown}.\n     *\n     * @event InteractionManager#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event InteractionManager#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event InteractionManager#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event InteractionManager#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event InteractionManager#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event InteractionManager#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event InteractionManager#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event InteractionManager#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link InteractionManager#event:touchstart}.\n     *\n     * @event InteractionManager#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event InteractionManager#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link Object3D#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link Object3D#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link Object3D#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n  }\n\n  /**\n   * Hit tests a point against the display tree, returning the first interactive object that is hit.\n   *\n   * @param {Point} globalPoint - A point to hit test with, in global space.\n   * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n   * to the last rendered root of the associated renderer.\n   * @return {Object3D} The hit display object, if any.\n   */\n  hitTest(globalPoint, root) {\n    // clear the target for our hit test\n    hitTestEvent.target = null;\n    // assign the global point\n    hitTestEvent.data.global = globalPoint;\n    // ensure safety of the root\n    if (!root) {\n      root = this.scene;\n    }\n    // run the hit test\n    this.processInteractive(hitTestEvent, root, null, true);\n    // return our found object - it'll be null if we didn't hit anything\n\n    return hitTestEvent.target;\n  }\n\n  /**\n   * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n   * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n   * another DOM element to receive those events.\n   *\n   * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n   */\n  setTargetElement(element) {\n    this.removeEvents();\n\n    this.interactionDOMElement = element;\n\n    this.addEvents();\n  }\n\n  /**\n   * Registers all the DOM events\n   *\n   * @private\n   */\n  addEvents() {\n    if (!this.interactionDOMElement || this.eventsAdded) {\n      return;\n    }\n\n    this.emit('addevents');\n\n    this.interactionDOMElement.addEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n      this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = 'none';\n    }\n\n    /**\n     * These events are added first, so that if pointer events are normalised, they are fired\n     * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n     */\n    if (this.supportsPointerEvents) {\n      window.document.addEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);\n      // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n      // we already handle those, so for the purposes of what we do in onPointerOut, we only\n      // care about the pointerleave event\n      this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n      window.addEventListener('pointercancel', this.onPointerCancel, true);\n      window.addEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.addEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n      window.addEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    // always look directly for touch events so that we can provide original data\n    // In a future version we should change this to being just a fallback and rely solely on\n    // PointerEvents whenever available\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.eventsAdded = true;\n  }\n\n  /**\n   * Removes all the DOM events that were previously registered\n   *\n   * @private\n   */\n  removeEvents() {\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    this.emit('removeevents');\n\n    this.interactionDOMElement.removeEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = '';\n      this.interactionDOMElement.style['-ms-touch-action'] = '';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = '';\n    }\n\n    if (this.supportsPointerEvents) {\n      window.document.removeEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n      window.removeEventListener('pointercancel', this.onPointerCancel, true);\n      window.removeEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.removeEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n      window.removeEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.interactionDOMElement = null;\n\n    this.eventsAdded = false;\n  }\n\n  /**\n   * Updates the state of interactive objects.\n   * Invoked by a throttled ticker.\n   *\n   * @param {number} deltaTime - time delta since last tick\n   */\n  update({ snippet }) {\n    this._deltaTime += snippet;\n\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n\n    this._deltaTime = 0;\n\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    // if the user move the mouse this check has already been done using the mouse move!\n    if (this.didMove) {\n      this.didMove = false;\n\n      return;\n    }\n\n    this.cursor = null;\n\n    // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n    // but there was a scenario of a display object moving under a static mouse cursor.\n    // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function\n    for (const k in this.activeInteractionData) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.activeInteractionData.hasOwnProperty(k)) {\n        const interactionData = this.activeInteractionData[k];\n\n        if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n          const interactionEvent = this.configureInteractionEventForDOMEvent(\n            this.eventData,\n            interactionData.originalEvent,\n            interactionData\n          );\n\n          this.processInteractive(\n            interactionEvent,\n            this.scene,\n            this.processPointerOverOut,\n            true\n          );\n        }\n      }\n    }\n\n    this.setCursorMode(this.cursor);\n\n    // TODO\n  }\n\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   *\n   * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n   */\n  setCursorMode(mode) {\n    mode = mode || 'default';\n    // if the mode didn't actually change, bail early\n    if (this.currentCursorMode === mode) {\n      return;\n    }\n    this.currentCursorMode = mode;\n    const style = this.cursorStyles[mode];\n\n    // only do things if there is a cursor style for it\n    if (style) {\n      switch (typeof style) {\n        case 'string':\n          // string styles are handled as cursor CSS\n          this.interactionDOMElement.style.cursor = style;\n          break;\n        case 'function':\n          // functions are just called, and passed the cursor mode\n          style(mode);\n          break;\n        case 'object':\n          // if it is an object, assume that it is a dictionary of CSS styles,\n          // apply it to the interactionDOMElement\n          Object.assign(this.interactionDOMElement.style, style);\n          break;\n        default:\n          break;\n      }\n    } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n      // for the mode, then assume that the dev wants it to be CSS for the cursor.\n      this.interactionDOMElement.style.cursor = mode;\n    }\n  }\n\n  /**\n   * Dispatches an event on the display object that was interacted with\n   *\n   * @param {Object3D} displayObject - the display object in question\n   * @param {string} eventString - the name of the event (e.g, mousedown)\n   * @param {object} eventData - the event data object\n   * @private\n   */\n  triggerEvent(displayObject, eventString, eventData) {\n    if (!eventData.stopped) {\n      eventData.currentTarget = displayObject;\n      eventData.type = eventString;\n\n      displayObject.emit(eventString, eventData);\n\n      if (displayObject[eventString]) {\n        displayObject[eventString](eventData);\n      }\n    }\n  }\n\n  /**\n   * This function is provides a neat way of crawling through the scene graph and running a\n   * specified function on all interactive objects it finds. It will also take care of hit\n   * testing the interactive objects and passes the hit across in the function.\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - event containing the point that\n   *  is tested for collision\n   * @param {Object3D} displayObject - the displayObject\n   *  that will be hit test (recursively crawls its children)\n   * @param {Function} [func] - the function that will be called on each interactive object. The\n   *  interactionEvent, displayObject and hit will be passed to the function\n   * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n   * @param {boolean} [interactive] - Whether the displayObject is interactive\n   * @return {boolean} returns true if the displayObject hit the point\n   */\n  processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n    if (!displayObject || !displayObject.visible) {\n      return false;\n    }\n\n    // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n    //\n    // This function will now loop through all objects and then only hit test the objects it HAS\n    // to, not all of them. MUCH faster..\n    // An object will be hit test if the following is true:\n    //\n    // 1: It is interactive.\n    // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n    //\n    // As another little optimisation once an interactive object has been hit we can carry on\n    // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n    // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n    interactive = displayObject.interactive || interactive;\n\n    let hit = false;\n    let interactiveParent = interactive;\n\n    if (displayObject.interactiveChildren && displayObject.children) {\n      const children = displayObject.children;\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n\n        // time to get recursive.. if this function will return if something is hit..\n        const childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n\n        if (childHit) {\n          // its a good idea to check if a child has lost its parent.\n          // this means it has been removed whilst looping so its best\n          if (!child.parent) {\n            continue;\n          }\n\n          // we no longer need to hit test any more objects in this container as we we\n          // now know the parent has been hit\n          interactiveParent = false;\n\n          // If the child is interactive , that means that the object hit was actually\n          // interactive and not just the child of an interactive object.\n          // This means we no longer need to hit test anything else. We still need to run\n          // through all objects, but we don't need to perform any hit tests.\n\n          if (childHit) {\n            if (interactionEvent.target) {\n              hitTest = false;\n            }\n            hit = true;\n          }\n        }\n      }\n    }\n\n    // no point running this if the item is not interactive or does not have an interactive parent.\n    if (interactive) {\n      // if we are hit testing (as in we have no hit any objects yet)\n      // We also don't need to worry about hit testing if once of the displayObjects children\n      // has already been hit - but only if it was interactive, otherwise we need to keep\n      // looking for an interactive child, just in case we hit one\n      if (hitTest && !interactionEvent.target) {\n        if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {\n          hit = true;\n        }\n      }\n\n      if (displayObject.interactive) {\n        if (hit && !interactionEvent.target) {\n          interactionEvent.data.target = interactionEvent.target = displayObject;\n        }\n\n        if (func) {\n          func(interactionEvent, displayObject, !!hit);\n        }\n      }\n    }\n\n    return hit;\n  }\n\n\n  /**\n   * Is called when the click is pressed down on the renderer element\n   *\n   * @private\n   * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down\n   */\n  onClick(originalEvent) {\n    if (originalEvent.type !== 'click') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(events[0]);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);\n\n    interactionEvent.data.originalEvent = originalEvent;\n\n    this.processInteractive(interactionEvent, this.scene, this.processClick, true);\n\n    this.emit('click', interactionEvent);\n  }\n\n  /**\n   * Processes the result of the click check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processClick(interactionEvent, displayObject, hit) {\n    if (hit) {\n      this.triggerEvent(displayObject, 'click', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer button is pressed down on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n   */\n  onPointerDown(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    /**\n     * No need to prevent default on natural pointer events, as there are no side effects\n     * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n     * so still need to be prevented.\n     */\n\n    // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      this.processInteractive(interactionEvent, this.scene, this.processPointerDown, true);\n\n      this.emit('pointerdown', interactionEvent);\n      if (event.pointerType === 'touch') {\n        this.emit('touchstart', interactionEvent);\n      } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n      }\n    }\n  }\n\n  /**\n   * Processes the result of the pointer down check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerDown(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n    const id = interactionEvent.data.identifier;\n\n    if (hit) {\n      if (!displayObject.trackedPointers[id]) {\n        displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n      this.triggerEvent(displayObject, 'pointerdown', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        displayObject.started = true;\n        this.triggerEvent(displayObject, 'touchstart', interactionEvent);\n      } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n        const isRightButton = data.button === 2;\n\n        if (isRightButton) {\n          displayObject.trackedPointers[id].rightDown = true;\n        } else {\n          displayObject.trackedPointers[id].leftDown = true;\n        }\n\n        this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n   * @param {boolean} cancelled - true if the pointer is cancelled\n   * @param {Function} func - Function passed to {@link processInteractive}\n   */\n  onPointerComplete(originalEvent, cancelled, func) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    const eventLen = events.length;\n\n    // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n    // in all cases (unless it was a pointercancel)\n    const eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      // perform hit testing for events targeting our canvas or cancel events\n      this.processInteractive(interactionEvent, this.scene, func, cancelled || !eventAppend);\n\n      this.emit(cancelled ? 'pointercancel' : `pointerup${eventAppend}`, interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? `rightup${eventAppend}` : `mouseup${eventAppend}`, interactionEvent);\n      } else if (event.pointerType === 'touch') {\n        this.emit(cancelled ? 'touchcancel' : `touchend${eventAppend}`, interactionEvent);\n        this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is cancelled\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerCancel(event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, true, this.processPointerCancel);\n  }\n\n  /**\n   * Processes the result of the pointer cancel check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   */\n  processPointerCancel(interactionEvent, displayObject) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    if (displayObject.trackedPointers[id] !== undefined) {\n      delete displayObject.trackedPointers[id];\n      this.triggerEvent(displayObject, 'pointercancel', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        this.triggerEvent(displayObject, 'touchcancel', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerUp(event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, false, this.processPointerUp);\n  }\n\n  /**\n   * Processes the result of the pointer up check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerUp(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const trackingData = displayObject.trackedPointers[id];\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    // Mouse only\n    if (isMouse) {\n      const isRightButton = data.button === 2;\n\n      const flags = InteractionTrackingData.FLAGS;\n\n      const test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n\n      const isDown = trackingData !== undefined && (trackingData.flags & test);\n\n      if (hit) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n        if (isDown) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);\n        }\n      } else if (isDown) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n      }\n      // update the down state of the tracking data\n      if (trackingData) {\n        if (isRightButton) {\n          trackingData.rightDown = false;\n        } else {\n          trackingData.leftDown = false;\n        }\n      }\n    }\n\n    // Pointers and Touches, and Mouse\n    if (isTouch && displayObject.started) {\n      displayObject.started = false;\n      this.triggerEvent(displayObject, 'touchend', interactionEvent);\n    }\n    if (hit) {\n      this.triggerEvent(displayObject, 'pointerup', interactionEvent);\n\n      if (trackingData) {\n        this.triggerEvent(displayObject, 'pointertap', interactionEvent);\n        if (isTouch) {\n          this.triggerEvent(displayObject, 'tap', interactionEvent);\n          // touches are no longer over (if they ever were) when we get the touchend\n          // so we should ensure that we don't keep pretending that they are\n          trackingData.over = false;\n        }\n      }\n    } else if (trackingData) {\n      this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);\n      if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);\n    }\n    // Only remove the tracking data if there is no over/down state still associated with it\n    if (trackingData && trackingData.none) {\n      delete displayObject.trackedPointers[id];\n    }\n  }\n\n  /**\n   * Is called when the pointer moves across the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n   */\n  onPointerMove(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (events[0].pointerType === 'mouse') {\n      this.didMove = true;\n\n      this.cursor = null;\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      const interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n\n      this.processInteractive(\n        interactionEvent,\n        this.scene,\n        this.processPointerMove,\n        interactive\n      );\n      this.emit('pointermove', interactionEvent);\n      if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n    }\n\n    if (events[0].pointerType === 'mouse') {\n      this.setCursorMode(this.cursor);\n\n      // TODO BUG for parents interactive object (border order issue)\n    }\n  }\n\n  /**\n   * Processes the result of the pointer move check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerMove(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    if (isMouse) {\n      this.processPointerOverOut(interactionEvent, displayObject, hit);\n    }\n\n    if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);\n    if (!this.moveWhenInside || hit) {\n      this.triggerEvent(displayObject, 'pointermove', interactionEvent);\n      if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved out of the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n   */\n  onPointerOut(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOut, so events will always be length 1\n    const event = events[0];\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = false;\n      this.setCursorMode(null);\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    this.processInteractive(interactionEvent, this.scene, this.processPointerOverOut, false);\n\n    this.emit('pointerout', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseout', interactionEvent);\n    } else {\n      // we can get touchleave events after touchend, so we want to make sure we don't\n      // introduce memory leaks\n      this.releaseInteractionDataForPointerId(interactionData.identifier);\n    }\n  }\n\n  /**\n   * Processes the result of the pointer over/out check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerOverOut(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    let trackingData = displayObject.trackedPointers[id];\n\n    // if we just moused over the display object, then we need to track that state\n    if (hit && !trackingData) {\n      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n    }\n\n    if (trackingData === undefined) return;\n\n    if (hit && this.mouseOverRenderer) {\n      if (!trackingData.over) {\n        trackingData.over = true;\n        this.triggerEvent(displayObject, 'pointerover', interactionEvent);\n        if (isMouse) {\n          this.triggerEvent(displayObject, 'mouseover', interactionEvent);\n        }\n      }\n\n      // only change the cursor if it has not already been changed (by something deeper in the\n      // display tree)\n      if (isMouse && this.cursor === null) {\n        this.cursor = displayObject.cursor;\n      }\n    } else if (trackingData.over) {\n      trackingData.over = false;\n      this.triggerEvent(displayObject, 'pointerout', this.eventData);\n      if (isMouse) {\n        this.triggerEvent(displayObject, 'mouseout', interactionEvent);\n      }\n      // if there is no mouse down information for the pointer, then it is safe to delete\n      if (trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved into the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n   */\n  onPointerOver(originalEvent) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOver, so events will always be length 1\n    const event = events[0];\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = true;\n    }\n\n    this.emit('pointerover', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseover', interactionEvent);\n    }\n  }\n\n  /**\n   * Get InteractionData for a given pointerId. Store that data as well\n   *\n   * @private\n   * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n   * @return {InteractionData} - Interaction data for the given pointer identifier\n   */\n  getInteractionDataForPointerId(event) {\n    const pointerId = event.pointerId;\n\n    let interactionData;\n\n    if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {\n      interactionData = this.mouse;\n    } else if (this.activeInteractionData[pointerId]) {\n      interactionData = this.activeInteractionData[pointerId];\n    } else {\n      interactionData = this.interactionDataPool.pop() || new InteractionData();\n      interactionData.identifier = pointerId;\n      this.activeInteractionData[pointerId] = interactionData;\n    }\n    // copy properties from the event, so that we can make sure that touch/pointer specific\n    // data is available\n    interactionData._copyEvent(event);\n\n    return interactionData;\n  }\n\n  /**\n   * Return unused InteractionData to the pool, for a given pointerId\n   *\n   * @private\n   * @param {number} pointerId - Identifier from a pointer event\n   */\n  releaseInteractionDataForPointerId(pointerId) {\n    const interactionData = this.activeInteractionData[pointerId];\n\n    if (interactionData) {\n      delete this.activeInteractionData[pointerId];\n      interactionData._reset();\n      this.interactionDataPool.push(interactionData);\n    }\n  }\n\n  /**\n   * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n   * resulting value is stored in the point. This takes into account the fact that the DOM\n   * element could be scaled and positioned anywhere on the screen.\n   *\n   * @param  {Vector2} point - the point that the result will be stored in\n   * @param  {number} x - the x coord of the position to map\n   * @param  {number} y - the y coord of the position to map\n   */\n  mapPositionToPoint(point, x, y) {\n    let rect;\n\n    // IE 11 fix\n    if (!this.interactionDOMElement.parentElement) {\n      rect = {\n        x: 0,\n        y: 0,\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n      };\n    } else {\n      rect = this.interactionDOMElement.getBoundingClientRect();\n    }\n\n    point.x = ((x - rect.left) / rect.width) * 2 - 1;\n    point.y = -((y - rect.top) / rect.height) * 2 + 1;\n  }\n\n  /**\n   * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The event to be configured\n   * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n   * @param {InteractionData} interactionData - The InteractionData that will be paired\n   *        with the InteractionEvent\n   * @return {InteractionEvent} the interaction event that was passed in\n   */\n  configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n    interactionEvent.data = interactionData;\n\n    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n\n    this.raycaster.setFromCamera(interactionData.global, this.camera);\n\n    // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n    if (pointerEvent.pointerType === 'touch') {\n      pointerEvent.globalX = interactionData.global.x;\n      pointerEvent.globalY = interactionData.global.y;\n    }\n\n    interactionData.originalEvent = pointerEvent;\n    interactionEvent._reset();\n    interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);\n\n    return interactionEvent;\n  }\n\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   *\n   * @private\n   * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n   * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n  normalizeToPointerData(event) {\n    const normalizedEvents = [];\n\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n\n        if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n        if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n        if (typeof touch.isPrimary === 'undefined') {\n          touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n        }\n        if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n        if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n        if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n        if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n        if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n        touch.twist = 0;\n        touch.tangentialPressure = 0;\n        // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n        // support, and the fill ins are not quite the same\n        // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n        // left is not 0,0 on the page\n        if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n        // mark the touch as normalized, just so that we know we did it\n        touch.isNormalized = true;\n\n        normalizedEvents.push(touch);\n      }\n    } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n      if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n      if (typeof event.width === 'undefined') event.width = 1;\n      if (typeof event.height === 'undefined') event.height = 1;\n      if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n      if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n      if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n      if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;\n      if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n      event.twist = 0;\n      event.tangentialPressure = 0;\n\n      // mark the mouse event as normalized, just so that we know we did it\n      event.isNormalized = true;\n\n      normalizedEvents.push(event);\n    } else {\n      normalizedEvents.push(event);\n    }\n\n    return normalizedEvents;\n  }\n\n  /**\n   * Destroys the interaction manager\n   *\n   */\n  destroy() {\n    this.removeEvents();\n\n    this.removeAllListeners();\n\n    this.renderer = null;\n\n    this.mouse = null;\n\n    this.eventData = null;\n\n    this.interactionDOMElement = null;\n\n    this.onPointerDown = null;\n    this.processPointerDown = null;\n\n    this.onPointerUp = null;\n    this.processPointerUp = null;\n\n    this.onPointerCancel = null;\n    this.processPointerCancel = null;\n\n    this.onPointerMove = null;\n    this.processPointerMove = null;\n\n    this.onPointerOut = null;\n    this.processPointerOverOut = null;\n\n    this.onPointerOver = null;\n\n    this._tempPoint = null;\n  }\n}\n\nexport default InteractionManager;\n","import '../patch/EventDispatcher';\nimport '../patch/Object3D';\n\nimport { EventDispatcher, Raycaster } from 'three';\nimport InteractionData from './InteractionData';\nimport InteractionEvent from './InteractionEvent';\nimport InteractionTrackingData from './InteractionTrackingData';\n\nconst MOUSE_POINTER_ID = 'MOUSE';\n\n// helpers for hitTest() - only used inside hitTest()\nconst hitTestEvent = {\n  target: null,\n  data: {\n    global: null,\n  },\n};\n\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @private\n * @class\n * @extends EventDispatcher\n */\nclass InteractionLayer extends EventDispatcher {\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n  constructor(renderer, options) {\n    super();\n\n    options = options || {};\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Layer}\n     */\n    this.layer = null;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Scene}\n     */\n    // this.scene = scene;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Camera}\n     */\n    // this.camera = camera;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.autoPreventDefault = options.autoPreventDefault || false;\n\n    /**\n     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n     *\n     * @member {number}\n     * @default 10\n     */\n    this.interactionFrequency = options.interactionFrequency || 10;\n\n    /**\n     * The mouse data\n     *\n     * @member {InteractionData}\n     */\n    this.mouse = new InteractionData();\n    this.mouse.identifier = MOUSE_POINTER_ID;\n\n    // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n    this.mouse.global.set(-999999);\n\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,InteractionData>}\n     */\n    this.activeInteractionData = {};\n    this.activeInteractionData[MOUSE_POINTER_ID] = this.mouse;\n\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {InteractionData[]}\n     */\n    this.interactionDataPool = [];\n\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n    this.eventData = new InteractionEvent();\n\n    /**\n     * The DOM element to bind to.\n     *\n     * @private\n     * @member {HTMLElement}\n     */\n    this.interactionDOMElement = null;\n\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM verison works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how three.js used to work.\n     *\n     * @member {boolean}\n     * @default true\n     */\n    this.moveWhenInside = true;\n\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.eventsAdded = false;\n\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.mouseOverRenderer = false;\n\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsTouchEvents = 'ontouchstart' in window;\n\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsPointerEvents = !!window.PointerEvent;\n\n    // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onClick = this.onClick.bind(this);\n    this.processClick = this.processClick.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.processPointerUp = this.processPointerUp.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerCancel = this.onPointerCancel.bind(this);\n    this.processPointerCancel = this.processPointerCancel.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.processPointerDown = this.processPointerDown.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.processPointerMove = this.processPointerMove.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOut = this.onPointerOut.bind(this);\n    this.processPointerOverOut = this.processPointerOverOut.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOver = this.onPointerOver.bind(this);\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, (string|Function|Object.<string, string>)>}\n     */\n    this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer',\n    };\n\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n    this.currentCursorMode = null;\n\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n    this.cursor = null;\n\n    /**\n     * ray caster, for survey intersects from 3d-scene\n     *\n     * @private\n     * @member {Raycaster}\n     */\n    this.raycaster = new Raycaster();\n\n    /**\n     * snippet time\n     *\n     * @private\n     * @member {Number}\n     */\n    this._deltaTime = 0;\n\n    this.setTargetElement(this.renderer.domElement);\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event InteractionLayer#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event InteractionLayer#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event InteractionLayer#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event InteractionLayer#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event InteractionLayer#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event InteractionLayer#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link InteractionLayer#event:mousedown}.\n     *\n     * @event InteractionLayer#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link InteractionLayer#event:rightdown}.\n     *\n     * @event InteractionLayer#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event InteractionLayer#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event InteractionLayer#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event InteractionLayer#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event InteractionLayer#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     *\n     * @event InteractionLayer#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event InteractionLayer#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event InteractionLayer#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link InteractionLayer#event:pointerdown}.\n     *\n     * @event InteractionLayer#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event InteractionLayer#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event InteractionLayer#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event InteractionLayer#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event InteractionLayer#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event InteractionLayer#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event InteractionLayer#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event InteractionLayer#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link InteractionLayer#event:touchstart}.\n     *\n     * @event InteractionLayer#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event InteractionLayer#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link Object3D#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link Object3D#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link Object3D#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isAble() {\n    return this.layer && this.layer.interactive;\n  }\n\n  /**\n   * set layer\n   * @param {Layer} layer layer\n   */\n  setLayer(layer) {\n    this.layer = layer;\n  }\n\n  /**\n   * Hit tests a point against the display tree, returning the first interactive object that is hit.\n   *\n   * @param {Point} globalPoint - A point to hit test with, in global space.\n   * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n   * to the last rendered root of the associated renderer.\n   * @return {Object3D} The hit display object, if any.\n   */\n  hitTest(globalPoint, root) {\n    if (!this.isAble()) return null;\n    // clear the target for our hit test\n    hitTestEvent.target = null;\n    // assign the global point\n    hitTestEvent.data.global = globalPoint;\n    // ensure safety of the root\n    if (!root) {\n      root = this.layer.scene;\n    }\n    // run the hit test\n    this.processInteractive(hitTestEvent, root, null, true);\n    // return our found object - it'll be null if we didn't hit anything\n\n    return hitTestEvent.target;\n  }\n\n  /**\n   * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n   * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n   * another DOM element to receive those events.\n   *\n   * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n   */\n  setTargetElement(element) {\n    this.removeEvents();\n\n    this.interactionDOMElement = element;\n\n    this.addEvents();\n  }\n\n  /**\n   * Registers all the DOM events\n   *\n   * @private\n   */\n  addEvents() {\n    if (!this.interactionDOMElement || this.eventsAdded) {\n      return;\n    }\n\n    this.emit('addevents');\n\n    this.interactionDOMElement.addEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n      this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = 'none';\n    }\n\n    /**\n     * These events are added first, so that if pointer events are normalised, they are fired\n     * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n     */\n    if (this.supportsPointerEvents) {\n      window.document.addEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);\n      // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n      // we already handle those, so for the purposes of what we do in onPointerOut, we only\n      // care about the pointerleave event\n      this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n      window.addEventListener('pointercancel', this.onPointerCancel, true);\n      window.addEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.addEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n      window.addEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    // always look directly for touch events so that we can provide original data\n    // In a future version we should change this to being just a fallback and rely solely on\n    // PointerEvents whenever available\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.eventsAdded = true;\n  }\n\n  /**\n   * Removes all the DOM events that were previously registered\n   *\n   * @private\n   */\n  removeEvents() {\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    this.emit('removeevents');\n\n    this.interactionDOMElement.removeEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = '';\n      this.interactionDOMElement.style['-ms-touch-action'] = '';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = '';\n    }\n\n    if (this.supportsPointerEvents) {\n      window.document.removeEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n      window.removeEventListener('pointercancel', this.onPointerCancel, true);\n      window.removeEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.removeEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n      window.removeEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.interactionDOMElement = null;\n\n    this.eventsAdded = false;\n  }\n\n  /**\n   * Updates the state of interactive objects.\n   * Invoked by a throttled ticker.\n   *\n   * @param {number} deltaTime - time delta since last tick\n   */\n  update({ snippet }) {\n    if (!this.isAble()) return;\n    this._deltaTime += snippet;\n\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n\n    this._deltaTime = 0;\n\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    // if the user move the mouse this check has already been done using the mouse move!\n    if (this.didMove) {\n      this.didMove = false;\n\n      return;\n    }\n\n    this.cursor = null;\n\n    // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n    // but there was a scenario of a display object moving under a static mouse cursor.\n    // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function\n    for (const k in this.activeInteractionData) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.activeInteractionData.hasOwnProperty(k)) {\n        const interactionData = this.activeInteractionData[k];\n\n        if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n          const interactionEvent = this.configureInteractionEventForDOMEvent(\n            this.eventData,\n            interactionData.originalEvent,\n            interactionData\n          );\n\n          this.processInteractive(\n            interactionEvent,\n            this.layer.scene,\n            this.processPointerOverOut,\n            true\n          );\n        }\n      }\n    }\n\n    this.setCursorMode(this.cursor);\n\n    // TODO\n  }\n\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   *\n   * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n   */\n  setCursorMode(mode) {\n    mode = mode || 'default';\n    // if the mode didn't actually change, bail early\n    if (this.currentCursorMode === mode) {\n      return;\n    }\n    this.currentCursorMode = mode;\n    const style = this.cursorStyles[mode];\n\n    // only do things if there is a cursor style for it\n    if (style) {\n      switch (typeof style) {\n        case 'string':\n          // string styles are handled as cursor CSS\n          this.interactionDOMElement.style.cursor = style;\n          break;\n        case 'function':\n          // functions are just called, and passed the cursor mode\n          style(mode);\n          break;\n        case 'object':\n          // if it is an object, assume that it is a dictionary of CSS styles,\n          // apply it to the interactionDOMElement\n          Object.assign(this.interactionDOMElement.style, style);\n          break;\n        default:\n          break;\n      }\n    } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n      // for the mode, then assume that the dev wants it to be CSS for the cursor.\n      this.interactionDOMElement.style.cursor = mode;\n    }\n  }\n\n  /**\n   * Dispatches an event on the display object that was interacted with\n   *\n   * @param {Object3D} displayObject - the display object in question\n   * @param {string} eventString - the name of the event (e.g, mousedown)\n   * @param {object} eventData - the event data object\n   * @private\n   */\n  triggerEvent(displayObject, eventString, eventData) {\n    if (!eventData.stopped) {\n      eventData.currentTarget = displayObject;\n      eventData.type = eventString;\n\n      displayObject.emit(eventString, eventData);\n\n      if (displayObject[eventString]) {\n        displayObject[eventString](eventData);\n      }\n    }\n  }\n\n  /**\n   * This function is provides a neat way of crawling through the scene graph and running a\n   * specified function on all interactive objects it finds. It will also take care of hit\n   * testing the interactive objects and passes the hit across in the function.\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - event containing the point that\n   *  is tested for collision\n   * @param {Object3D} displayObject - the displayObject\n   *  that will be hit test (recursively crawls its children)\n   * @param {Function} [func] - the function that will be called on each interactive object. The\n   *  interactionEvent, displayObject and hit will be passed to the function\n   * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n   * @param {boolean} [interactive] - Whether the displayObject is interactive\n   * @return {boolean} returns true if the displayObject hit the point\n   */\n  processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n    if (!displayObject || !displayObject.visible) {\n      return false;\n    }\n\n    // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n    //\n    // This function will now loop through all objects and then only hit test the objects it HAS\n    // to, not all of them. MUCH faster..\n    // An object will be hit test if the following is true:\n    //\n    // 1: It is interactive.\n    // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n    //\n    // As another little optimisation once an interactive object has been hit we can carry on\n    // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n    // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n    interactive = displayObject.interactive || interactive;\n\n    let hit = false;\n    let interactiveParent = interactive;\n\n    if (displayObject.interactiveChildren && displayObject.children) {\n      const children = displayObject.children;\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n\n        // time to get recursive.. if this function will return if something is hit..\n        const childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n\n        if (childHit) {\n          // its a good idea to check if a child has lost its parent.\n          // this means it has been removed whilst looping so its best\n          if (!child.parent) {\n            continue;\n          }\n\n          // we no longer need to hit test any more objects in this container as we we\n          // now know the parent has been hit\n          interactiveParent = false;\n\n          // If the child is interactive , that means that the object hit was actually\n          // interactive and not just the child of an interactive object.\n          // This means we no longer need to hit test anything else. We still need to run\n          // through all objects, but we don't need to perform any hit tests.\n\n          if (childHit) {\n            if (interactionEvent.target) {\n              hitTest = false;\n            }\n            hit = true;\n          }\n        }\n      }\n    }\n\n    // no point running this if the item is not interactive or does not have an interactive parent.\n    if (interactive) {\n      // if we are hit testing (as in we have no hit any objects yet)\n      // We also don't need to worry about hit testing if once of the displayObjects children\n      // has already been hit - but only if it was interactive, otherwise we need to keep\n      // looking for an interactive child, just in case we hit one\n      if (hitTest && !interactionEvent.target) {\n        if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {\n          hit = true;\n        }\n      }\n\n      if (displayObject.interactive) {\n        if (hit && !interactionEvent.target) {\n          interactionEvent.data.target = interactionEvent.target = displayObject;\n        }\n\n        if (func) {\n          func(interactionEvent, displayObject, !!hit);\n        }\n      }\n    }\n\n    return hit;\n  }\n\n\n  /**\n   * Is called when the click is pressed down on the renderer element\n   *\n   * @private\n   * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down\n   */\n  onClick(originalEvent) {\n    if (!this.isAble()) return;\n    if (originalEvent.type !== 'click') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(events[0]);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);\n\n    interactionEvent.data.originalEvent = originalEvent;\n\n    this.processInteractive(interactionEvent, this.layer.scene, this.processClick, true);\n\n    this.emit('click', interactionEvent);\n  }\n\n  /**\n   * Processes the result of the click check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processClick(interactionEvent, displayObject, hit) {\n    if (hit) {\n      this.triggerEvent(displayObject, 'click', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer button is pressed down on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n   */\n  onPointerDown(originalEvent) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    /**\n     * No need to prevent default on natural pointer events, as there are no side effects\n     * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n     * so still need to be prevented.\n     */\n\n    // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      this.processInteractive(interactionEvent, this.layer.scene, this.processPointerDown, true);\n\n      this.emit('pointerdown', interactionEvent);\n      if (event.pointerType === 'touch') {\n        this.emit('touchstart', interactionEvent);\n      } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n      }\n    }\n  }\n\n  /**\n   * Processes the result of the pointer down check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerDown(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n    const id = interactionEvent.data.identifier;\n\n    if (hit) {\n      if (!displayObject.trackedPointers[id]) {\n        displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n      this.triggerEvent(displayObject, 'pointerdown', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        displayObject.started = true;\n        this.triggerEvent(displayObject, 'touchstart', interactionEvent);\n      } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n        const isRightButton = data.button === 2;\n\n        if (isRightButton) {\n          displayObject.trackedPointers[id].rightDown = true;\n        } else {\n          displayObject.trackedPointers[id].leftDown = true;\n        }\n\n        this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n   * @param {boolean} cancelled - true if the pointer is cancelled\n   * @param {Function} func - Function passed to {@link processInteractive}\n   */\n  onPointerComplete(originalEvent, cancelled, func) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    const eventLen = events.length;\n\n    // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n    // in all cases (unless it was a pointercancel)\n    const eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      // perform hit testing for events targeting our canvas or cancel events\n      this.processInteractive(interactionEvent, this.layer.scene, func, cancelled || !eventAppend);\n\n      this.emit(cancelled ? 'pointercancel' : `pointerup${eventAppend}`, interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? `rightup${eventAppend}` : `mouseup${eventAppend}`, interactionEvent);\n      } else if (event.pointerType === 'touch') {\n        this.emit(cancelled ? 'touchcancel' : `touchend${eventAppend}`, interactionEvent);\n        this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is cancelled\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerCancel(event) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, true, this.processPointerCancel);\n  }\n\n  /**\n   * Processes the result of the pointer cancel check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   */\n  processPointerCancel(interactionEvent, displayObject) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    if (displayObject.trackedPointers[id] !== undefined) {\n      delete displayObject.trackedPointers[id];\n      this.triggerEvent(displayObject, 'pointercancel', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        this.triggerEvent(displayObject, 'touchcancel', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerUp(event) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, false, this.processPointerUp);\n  }\n\n  /**\n   * Processes the result of the pointer up check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerUp(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const trackingData = displayObject.trackedPointers[id];\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    // Mouse only\n    if (isMouse) {\n      const isRightButton = data.button === 2;\n\n      const flags = InteractionTrackingData.FLAGS;\n\n      const test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n\n      const isDown = trackingData !== undefined && (trackingData.flags & test);\n\n      if (hit) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n        if (isDown) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);\n        }\n      } else if (isDown) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n      }\n      // update the down state of the tracking data\n      if (trackingData) {\n        if (isRightButton) {\n          trackingData.rightDown = false;\n        } else {\n          trackingData.leftDown = false;\n        }\n      }\n    }\n\n    // Pointers and Touches, and Mouse\n    if (isTouch && displayObject.started) {\n      displayObject.started = false;\n      this.triggerEvent(displayObject, 'touchend', interactionEvent);\n    }\n    if (hit) {\n      this.triggerEvent(displayObject, 'pointerup', interactionEvent);\n\n      if (trackingData) {\n        this.triggerEvent(displayObject, 'pointertap', interactionEvent);\n        if (isTouch) {\n          this.triggerEvent(displayObject, 'tap', interactionEvent);\n          // touches are no longer over (if they ever were) when we get the touchend\n          // so we should ensure that we don't keep pretending that they are\n          trackingData.over = false;\n        }\n      }\n    } else if (trackingData) {\n      this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);\n      if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);\n    }\n    // Only remove the tracking data if there is no over/down state still associated with it\n    if (trackingData && trackingData.none) {\n      delete displayObject.trackedPointers[id];\n    }\n  }\n\n  /**\n   * Is called when the pointer moves across the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n   */\n  onPointerMove(originalEvent) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (events[0].pointerType === 'mouse') {\n      this.didMove = true;\n\n      this.cursor = null;\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      const interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n\n      this.processInteractive(\n        interactionEvent,\n        this.layer.scene,\n        this.processPointerMove,\n        interactive\n      );\n      this.emit('pointermove', interactionEvent);\n      if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n    }\n\n    if (events[0].pointerType === 'mouse') {\n      this.setCursorMode(this.cursor);\n\n      // TODO BUG for parents interactive object (border order issue)\n    }\n  }\n\n  /**\n   * Processes the result of the pointer move check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerMove(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    if (isMouse) {\n      this.processPointerOverOut(interactionEvent, displayObject, hit);\n    }\n\n    if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);\n    if (!this.moveWhenInside || hit) {\n      this.triggerEvent(displayObject, 'pointermove', interactionEvent);\n      if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved out of the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n   */\n  onPointerOut(originalEvent) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOut, so events will always be length 1\n    const event = events[0];\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = false;\n      this.setCursorMode(null);\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    this.processInteractive(interactionEvent, this.layer.scene, this.processPointerOverOut, false);\n\n    this.emit('pointerout', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseout', interactionEvent);\n    } else {\n      // we can get touchleave events after touchend, so we want to make sure we don't\n      // introduce memory leaks\n      this.releaseInteractionDataForPointerId(interactionData.identifier);\n    }\n  }\n\n  /**\n   * Processes the result of the pointer over/out check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerOverOut(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    let trackingData = displayObject.trackedPointers[id];\n\n    // if we just moused over the display object, then we need to track that state\n    if (hit && !trackingData) {\n      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n    }\n\n    if (trackingData === undefined) return;\n\n    if (hit && this.mouseOverRenderer) {\n      if (!trackingData.over) {\n        trackingData.over = true;\n        this.triggerEvent(displayObject, 'pointerover', interactionEvent);\n        if (isMouse) {\n          this.triggerEvent(displayObject, 'mouseover', interactionEvent);\n        }\n      }\n\n      // only change the cursor if it has not already been changed (by something deeper in the\n      // display tree)\n      if (isMouse && this.cursor === null) {\n        this.cursor = displayObject.cursor;\n      }\n    } else if (trackingData.over) {\n      trackingData.over = false;\n      this.triggerEvent(displayObject, 'pointerout', this.eventData);\n      if (isMouse) {\n        this.triggerEvent(displayObject, 'mouseout', interactionEvent);\n      }\n      // if there is no mouse down information for the pointer, then it is safe to delete\n      if (trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved into the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n   */\n  onPointerOver(originalEvent) {\n    if (!this.isAble()) return;\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOver, so events will always be length 1\n    const event = events[0];\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = true;\n    }\n\n    this.emit('pointerover', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseover', interactionEvent);\n    }\n  }\n\n  /**\n   * Get InteractionData for a given pointerId. Store that data as well\n   *\n   * @private\n   * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n   * @return {InteractionData} - Interaction data for the given pointer identifier\n   */\n  getInteractionDataForPointerId(event) {\n    const pointerId = event.pointerId;\n\n    let interactionData;\n\n    if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {\n      interactionData = this.mouse;\n    } else if (this.activeInteractionData[pointerId]) {\n      interactionData = this.activeInteractionData[pointerId];\n    } else {\n      interactionData = this.interactionDataPool.pop() || new InteractionData();\n      interactionData.identifier = pointerId;\n      this.activeInteractionData[pointerId] = interactionData;\n    }\n    // copy properties from the event, so that we can make sure that touch/pointer specific\n    // data is available\n    interactionData._copyEvent(event);\n\n    return interactionData;\n  }\n\n  /**\n   * Return unused InteractionData to the pool, for a given pointerId\n   *\n   * @private\n   * @param {number} pointerId - Identifier from a pointer event\n   */\n  releaseInteractionDataForPointerId(pointerId) {\n    const interactionData = this.activeInteractionData[pointerId];\n\n    if (interactionData) {\n      delete this.activeInteractionData[pointerId];\n      interactionData._reset();\n      this.interactionDataPool.push(interactionData);\n    }\n  }\n\n  /**\n   * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n   * resulting value is stored in the point. This takes into account the fact that the DOM\n   * element could be scaled and positioned anywhere on the screen.\n   *\n   * @param  {Vector2} point - the point that the result will be stored in\n   * @param  {number} x - the x coord of the position to map\n   * @param  {number} y - the y coord of the position to map\n   */\n  mapPositionToPoint(point, x, y) {\n    let rect;\n\n    // IE 11 fix\n    if (!this.interactionDOMElement.parentElement) {\n      rect = {\n        x: 0,\n        y: 0,\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n      };\n    } else {\n      rect = this.interactionDOMElement.getBoundingClientRect();\n    }\n\n    point.x = ((x - rect.left) / rect.width) * 2 - 1;\n    point.y = -((y - rect.top) / rect.height) * 2 + 1;\n  }\n\n  /**\n   * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The event to be configured\n   * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n   * @param {InteractionData} interactionData - The InteractionData that will be paired\n   *        with the InteractionEvent\n   * @return {InteractionEvent} the interaction event that was passed in\n   */\n  configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n    interactionEvent.data = interactionData;\n\n    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n\n    if (this.layer && this.layer.interactive) this.raycaster.setFromCamera(interactionData.global, this.layer.camera);\n\n    // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n    if (pointerEvent.pointerType === 'touch') {\n      pointerEvent.globalX = interactionData.global.x;\n      pointerEvent.globalY = interactionData.global.y;\n    }\n\n    interactionData.originalEvent = pointerEvent;\n    interactionEvent._reset();\n    interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);\n\n    return interactionEvent;\n  }\n\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   *\n   * @private\n   * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n   * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n  normalizeToPointerData(event) {\n    const normalizedEvents = [];\n\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n\n        if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n        if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n        if (typeof touch.isPrimary === 'undefined') {\n          touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n        }\n        if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n        if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n        if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n        if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n        if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n        touch.twist = 0;\n        touch.tangentialPressure = 0;\n        // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n        // support, and the fill ins are not quite the same\n        // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n        // left is not 0,0 on the page\n        if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n        // mark the touch as normalized, just so that we know we did it\n        touch.isNormalized = true;\n\n        normalizedEvents.push(touch);\n      }\n    } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n      if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n      if (typeof event.width === 'undefined') event.width = 1;\n      if (typeof event.height === 'undefined') event.height = 1;\n      if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n      if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n      if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n      if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;\n      if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n      event.twist = 0;\n      event.tangentialPressure = 0;\n\n      // mark the mouse event as normalized, just so that we know we did it\n      event.isNormalized = true;\n\n      normalizedEvents.push(event);\n    } else {\n      normalizedEvents.push(event);\n    }\n\n    return normalizedEvents;\n  }\n\n  /**\n   * Destroys the interaction manager\n   *\n   */\n  destroy() {\n    this.removeEvents();\n\n    this.removeAllListeners();\n\n    this.renderer = null;\n\n    this.mouse = null;\n\n    this.eventData = null;\n\n    this.interactionDOMElement = null;\n\n    this.onPointerDown = null;\n    this.processPointerDown = null;\n\n    this.onPointerUp = null;\n    this.processPointerUp = null;\n\n    this.onPointerCancel = null;\n    this.processPointerCancel = null;\n\n    this.onPointerMove = null;\n    this.processPointerMove = null;\n\n    this.onPointerOut = null;\n    this.processPointerOverOut = null;\n\n    this.onPointerOver = null;\n\n    this._tempPoint = null;\n  }\n}\n\nexport default InteractionLayer;\n","(function() {\n  let lastTime = 0;\n  let vendors = ['ms', 'moz', 'webkit', 'o'];\n  for (let x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||\n            window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = function(callback) {\n      let currTime = new Date().getTime();\n      let timeToCall = Math.max(0, 16 - (currTime - lastTime));\n      let id = window.setTimeout(function() {\n        callback(currTime + timeToCall);\n      }, timeToCall);\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n  }\n\n  if (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = function(id) {\n      clearTimeout(id);\n    };\n  }\n\n  window.RAF = window.requestAnimationFrame;\n  window.CAF = window.cancelAnimationFrame;\n})();\n","import './Raf';\nimport { EventDispatcher } from 'three';\n\n/**\n * @extends EventDispatcher\n */\nclass Ticker extends EventDispatcher {\n  /**\n   *\n   */\n  constructor() {\n    super();\n    this.timer = null;\n    this.started = false;\n\n    /**\n     * pre-time cache\n     *\n     * @member {Number}\n     * @private\n     */\n    this.pt = 0;\n\n    /**\n     * how long the time through, at this tick\n     *\n     * @member {Number}\n     * @private\n     */\n    this.snippet = 0;\n\n    this.start();\n  }\n\n  /**\n   * start tick loop\n   */\n  start() {\n    if (this.started) return;\n    const loop = () => {\n      this.timeline();\n      this.emit('tick', { snippet: this.snippet });\n      this.timer = RAF(loop);\n    };\n    loop();\n  }\n\n  /**\n   * stop tick loop\n   */\n  stop() {\n    CAF(this.timer);\n    this.started = false;\n  }\n\n  /**\n   * get timeline snippet\n   *\n   * @private\n   */\n  timeline() {\n    this.snippet = Date.now() - this.pt;\n    if (this.pt === 0 || this.snippet > 200) {\n      this.pt = Date.now();\n      this.snippet = Date.now() - this.pt;\n    }\n\n    this.pt += this.snippet;\n  }\n}\n\nexport default Ticker;\n","import Ticker from '../utils/Ticker';\nimport InteractionManager from './InteractionManager';\n\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @example\n * import { Scene, PerspectiveCamera, WebGLRenderer, Mesh, BoxGeometry, MeshBasicMaterial } from 'three';\n * import { Interaction } from 'three.interaction';\n * const renderer = new WebGLRenderer({ canvas: canvasElement });\n * const scene = new Scene();\n * const camera = new PerspectiveCamera(60, width / height, 0.1, 100);\n *\n * const interaction = new Interaction(renderer, scene, camera);\n * // then you can bind every interaction event with any mesh which you had `add` into `scene` before\n * const cube = new Mesh(\n *   new BoxGeometry(1, 1, 1),\n *   new MeshBasicMaterial({ color: 0xffffff }),\n * );\n * scene.add(cube);\n * cube.on('touchstart', ev => {\n *   console.log(ev);\n * });\n *\n * cube.on('mousedown', ev => {\n *   console.log(ev);\n * });\n *\n * cube.on('pointerdown', ev => {\n *   console.log(ev);\n * });\n * // and so on ...\n *\n * // you can also listen on parent-node or any display-tree node,\n * // source event will bubble up along with display-tree.\n * // you can stop the bubble-up by invoke ev.stopPropagation function.\n * scene.on('touchstart', ev => {\n *   console.log(ev);\n * })\n *\n * @class\n * @extends InteractionManager\n */\nclass Interaction extends InteractionManager {\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Scene} scene - A reference to the current scene\n   * @param {Camera} camera - A reference to the current camera\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=false] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n  constructor(renderer, scene, camera, options) {\n    options = Object.assign({ autoAttach: false }, options);\n    super(renderer, scene, camera, options);\n\n    /**\n     * a ticker\n     *\n     * @private\n     * @member {Ticker}\n     */\n    this.ticker = new Ticker();\n\n    /**\n     * update for some over event\n     *\n     * @private\n     */\n    this.update = this.update.bind(this);\n\n    this.on('addevents', () => {\n      this.ticker.on('tick', this.update);\n    });\n\n    this.on('removeevents', () => {\n      this.ticker.off('tick', this.update);\n    });\n\n    this.setTargetElement(this.renderer.domElement);\n  }\n}\n\nexport default Interaction;\n"]},"metadata":{},"sourceType":"module"}