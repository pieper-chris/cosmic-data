{"ast":null,"code":"/**\r\n * Map module.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { SerialChart, SerialChartDataItem } from \"./SerialChart\";\nimport { Disposer } from \"../../core/utils/Disposer\";\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\nimport { MapSeries } from \"../map/MapSeries\";\nimport { MapImage } from \"../map/MapImage\";\nimport { MapPolygon } from \"../map/MapPolygon\";\nimport { MapPolygonSeries } from \"../map/MapPolygonSeries\";\nimport { Projection } from \"../map/projections/Projection\";\nimport { Circle } from \"../../core/elements/Circle\";\nimport { SmallMap } from \"../map/SmallMap\";\nimport * as $mapUtils from \"../map/MapUtils\";\nimport { keyboard } from \"../../core/utils/Keyboard\";\nimport { registry } from \"../../core/Registry\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as $utils from \"../../core/utils/Utils\";\nimport * as $ease from \"../../core/utils/Ease\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $geo from \"../map/Geo\";\nimport { GraticuleSeries } from \"../map/GraticuleSeries\";\nimport { getInteraction } from \"../../core/interaction/Interaction\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Defines a [[DataItem]] for [[MapChart]].\r\n *\r\n * @see {@link DataItem}\r\n */\n\nvar MapChartDataItem =\n/** @class */\nfunction (_super) {\n  __extends(MapChartDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function MapChartDataItem() {\n    var _this = _super.call(this) || this;\n\n    _this.className = \"MapChartDataItem\";\n\n    _this.applyTheme();\n\n    return _this;\n  }\n\n  return MapChartDataItem;\n}(SerialChartDataItem);\n\nexport { MapChartDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n\n/**\r\n * Creates a map.\r\n *\r\n * @see {@link IMapChartEvents} for a list of available Events\r\n * @see {@link IMapChartAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/chart-types/map/} for documentation\r\n */\n\nvar MapChart =\n/** @class */\nfunction (_super) {\n  __extends(MapChart, _super);\n  /**\r\n   * Constructor\r\n   */\n\n\n  function MapChart() {\n    var _this = // Init\n    _super.call(this) || this;\n    /**\r\n     * A ratio to be used when scaling the map shapes.\r\n     *\r\n     * @readonly\r\n     */\n\n\n    _this.scaleRatio = 1;\n    /**\r\n     * Default duration of zoom animations (ms).\r\n     */\n\n    _this.zoomDuration = 1000;\n    /**\r\n     * Default zooming animation easing function.\r\n     */\n\n    _this.zoomEasing = $ease.cubicOut;\n    /**\r\n     * Smallest available zoom level. The map will not allow to zoom out past\r\n     * this setting.\r\n     *\r\n     * NOTE: Should be power of 2.\r\n     *\r\n     * @default 1\r\n     */\n\n    _this.minZoomLevel = 1;\n    /**\r\n     * Biggest available zoom level. The map will not allow to zoom in past\r\n     * this setting.\r\n     *\r\n     * NOTE: Should be power of 2.\r\n     *\r\n     * @default 32\r\n     */\n\n    _this.maxZoomLevel = 32;\n    /**\r\n     * [_prevZoomGeoPoint description]\r\n     *\r\n     * @todo Description\r\n     */\n\n    _this._prevZoomGeoPoint = {\n      latitude: 0,\n      longitude: 0\n    };\n    _this.className = \"MapChart\"; // Set default projection\n\n    _this.projection = new Projection();\n\n    _this.setPropertyValue(\"deltaLatitude\", 0);\n\n    _this.setPropertyValue(\"deltaLongitude\", 0);\n\n    _this.setPropertyValue(\"deltaGamma\", 0);\n\n    _this.maxPanOut = 0.7;\n    _this.homeZoomLevel = 1;\n    _this.zoomStep = 2;\n    _this.layout = \"absolute\";\n    _this.centerMapOnZoomOut = true; // Set padding\n\n    _this.padding(0, 0, 0, 0);\n\n    $utils.used(_this.backgroundSeries); // so that the map would render in a hidden div too\n\n    _this.minWidth = 10;\n    _this.minHeight = 10;\n\n    _this.events.once(\"inited\", _this.handleAllInited, _this, false); // Create a container for map series\n\n\n    var seriesContainer = _this.seriesContainer;\n    seriesContainer.visible = false;\n    seriesContainer.inert = true;\n    seriesContainer.resizable = true;\n    seriesContainer.events.on(\"transformed\", _this.handleMapTransform, _this, false);\n    seriesContainer.events.on(\"doublehit\", _this.handleDoubleHit, _this, false);\n    seriesContainer.events.on(\"dragged\", _this.handleDrag, _this, false);\n    seriesContainer.zIndex = 0;\n    seriesContainer.dragWhileResize = true; //seriesContainer.background.fillOpacity = 0;\n\n    seriesContainer.adapter.add(\"scale\", function (scale, target) {\n      return $math.fitToRange(scale, _this.minZoomLevel, _this.maxZoomLevel);\n    }); // Set up events\n    //this.events.on(\"validated\", this.updateExtremes, this);\n    //this.events.on(\"datavalidated\", this.handleAllValidated, this, false);\n    //this.events.on(\"datavalidated\", this.updateExtremes, this, false);\n\n    _this.events.on(\"maxsizechanged\", function (event) {\n      if (event.previousWidth == 0 || event.previousHeight == 0) {\n        _this.updateExtremes();\n\n        _this.updateCenterGeoPoint();\n      }\n    }, undefined, false); // Set up main chart container, e.g. set backgrounds and events to monitor\n    // size changes, etc.\n\n\n    var chartContainer = _this.chartContainer;\n    chartContainer.parent = _this;\n    chartContainer.zIndex = -1;\n\n    _this._disposers.push(_this.events.on(\"maxsizechanged\", function () {\n      if (_this.inited) {\n        if (_this._mapAnimation) {\n          _this._mapAnimation.stop();\n        }\n\n        var allInited_1 = true;\n\n        _this.series.each(function (series) {\n          series.updateTooltipBounds();\n\n          if (!series.inited || series.dataInvalid) {\n            allInited_1 = false;\n          }\n        });\n\n        if (allInited_1) {\n          _this.updateScaleRatio();\n        }\n\n        _this.zoomToGeoPoint(_this._zoomGeoPointReal, _this.zoomLevel, true, 0);\n      }\n    }, undefined, false));\n\n    var chartContainerBg = chartContainer.background;\n    chartContainerBg.fillOpacity = 0;\n    chartContainerBg.events.on(\"down\", function (e) {\n      _this.seriesContainer.dragStart(e.target.interactions.downPointers.getIndex(0));\n    }, _this);\n    chartContainerBg.events.on(\"up\", function (e) {\n      _this.seriesContainer.dragStop();\n    }, _this);\n    chartContainerBg.events.on(\"doublehit\", _this.handleDoubleHit, _this);\n    chartContainerBg.focusable = true;\n    chartContainer.events.on(\"down\", _this.handleMapDown, _this, false);\n\n    _this.addDisposer(seriesContainer.events.on(\"down\", function () {\n      // Cancel any move inertia if there is one\n      var inertia = _this.seriesContainer.interactions.inertias.getKey(\"move\");\n\n      if (inertia) {\n        inertia.done();\n      }\n    })); // Add description to background\n\n\n    _this.background.fillOpacity = 0; // Add keyboard events for panning\n\n    _this._disposers.push(getInteraction().body.events.on(\"keyup\", function (ev) {\n      if (_this.topParent.hasFocused) {\n        var key = keyboard.getEventKey(ev.event);\n\n        if (!_this._zoomControl || !_this._zoomControl.thumb.isFocused) {\n          switch (key) {\n            case \"up\":\n              _this.pan({\n                x: 0,\n                y: 0.1\n              });\n\n              break;\n\n            case \"down\":\n              _this.pan({\n                x: 0,\n                y: -0.1\n              });\n\n              break;\n\n            case \"left\":\n              _this.pan({\n                x: 0.1,\n                y: 0\n              });\n\n              break;\n\n            case \"right\":\n              _this.pan({\n                x: -0.1,\n                y: 0\n              });\n\n              break;\n          }\n        }\n      }\n    }, _this));\n\n    _this.mouseWheelBehavior = \"zoom\";\n    var interaction = getInteraction();\n\n    _this._disposers.push(interaction.body.events.on(\"down\", _this.handlePanDown, _this));\n\n    _this._disposers.push(interaction.body.events.on(\"up\", _this.handlePanUp, _this)); //this._disposers.push(interaction.body.events.on(\"track\", this.handlePanMove, this));\n\n\n    var panSprite = _this.seriesContainer.createChild(Circle);\n\n    panSprite.radius = 10;\n    panSprite.inert = true;\n    panSprite.isMeasured = false;\n    panSprite.events.on(\"transformed\", _this.handlePanMove, _this, false);\n    panSprite.interactionsEnabled = false;\n    panSprite.opacity = 0;\n    panSprite.x = 0;\n    panSprite.y = 0;\n    _this.panSprite = panSprite;\n    _this.panBehavior = \"move\";\n    /*\r\n            this.panSprite.inertiaOptions.setKey(\"move\", {\r\n                \"time\": 100,\r\n                \"duration\": 1000,\r\n                \"factor\": 3,\r\n                \"easing\": $ease.sinOut\r\n            });*/\n    // Apply theme\n\n    _this.applyTheme();\n\n    return _this;\n  }\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapChart.prototype.handlePanDown = function (event) {\n    var svgPoint = $utils.documentPointToSvg(event.pointer.point, this.htmlContainer);\n\n    if (svgPoint.x > 0 && svgPoint.y > 0 && svgPoint.x < this.svgContainer.width && svgPoint.y < this.svgContainer.height) {\n      // Get local point\n      this._downPointOrig = $utils.documentPointToSprite(event.pointer.point, this.seriesContainer);\n      this.panSprite.moveTo(this._downPointOrig);\n      this.panSprite.dragStart(event.pointer);\n      this._downDeltaLongitude = this.deltaLongitude;\n      this._downDeltaLatitude = this.deltaLatitude;\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapChart.prototype.handlePanUp = function (event) {\n    if (this._downPointOrig) {\n      this.panSprite.dragStop(event.pointer, true);\n    }\n\n    this._downPointOrig = undefined;\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapChart.prototype.handlePanMove = function () {\n    if (!this.seriesContainer.isResized) {\n      if (getInteraction().areTransformed([this.panSprite.interactions, this.seriesContainer.interactions])) {\n        return;\n      }\n\n      var d3Projection = this.projection.d3Projection;\n      var panBehavior = this.panBehavior;\n\n      if (panBehavior != \"move\" && panBehavior != \"none\" && this._downPointOrig && d3Projection.rotate) {\n        var rotation = d3Projection.rotate();\n        var dln = rotation[0];\n        var dlt = rotation[1];\n        var dlg = rotation[2];\n        d3Projection.rotate([0, 0, 0]);\n        var downGeoLocal = this.projection.invert(this._downPointOrig);\n        var local = {\n          x: this.panSprite.pixelX,\n          y: this.panSprite.pixelY\n        };\n        var geoLocal = void 0;\n\n        if (local) {\n          geoLocal = this.projection.invert(local);\n        }\n\n        d3Projection.rotate([dln, dlt, dlg]);\n\n        if (geoLocal) {\n          if (panBehavior == \"rotateLat\" || panBehavior == \"rotateLongLat\") {\n            this.deltaLatitude = this._downDeltaLatitude + geoLocal.latitude - downGeoLocal.latitude;\n          }\n\n          if (panBehavior == \"rotateLong\" || panBehavior == \"rotateLongLat\") {\n            this.deltaLongitude = this._downDeltaLongitude + geoLocal.longitude - downGeoLocal.longitude;\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapChart.prototype.handleAllInited = function () {\n    var _this = this;\n\n    var inited = true;\n    this.seriesContainer.visible = true;\n    this.series.each(function (series) {\n      if (!series.inited || series.dataInvalid) {\n        inited = false;\n      }\n    });\n\n    if (inited) {\n      this.updateCenterGeoPoint();\n      this.updateScaleRatio();\n      this.goHome(0);\n    } else {\n      // TODO verify that this is correct\n      var disposer_1 = registry.events.once(\"exitframe\", function () {\n        _this.removeDispose(disposer_1);\n\n        _this.handleAllInited();\n      }, this, false);\n      this.addDisposer(disposer_1);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapChart.prototype.updateZoomGeoPoint = function () {\n    var seriesPoint = $utils.svgPointToSprite({\n      x: this.innerWidth / 2 + this.pixelPaddingLeft,\n      y: this.innerHeight / 2 + this.pixelPaddingTop\n    }, this.series.getIndex(0));\n    var geoPoint = this.projection.invert(seriesPoint);\n    this._zoomGeoPointReal = geoPoint;\n  };\n  /**\r\n   * @ignore\r\n   */\n\n\n  MapChart.prototype.updateCenterGeoPoint = function () {\n    var maxLeft;\n    var maxRight;\n    var maxTop;\n    var maxBottom;\n\n    if (this.backgroundSeries) {\n      var features = this.backgroundSeries.getFeatures();\n\n      if (features.length > 0) {\n        var bounds = this.projection.d3Path.bounds(features[0].geometry);\n        maxLeft = bounds[0][0];\n        maxTop = bounds[0][1];\n        maxRight = bounds[1][0];\n        maxBottom = bounds[1][1];\n      }\n    } else {\n      this.series.each(function (series) {\n        var bbox = series.group.node.getBBox();\n\n        if (maxLeft > bbox.x || !$type.isNumber(maxLeft)) {\n          maxLeft = bbox.x;\n        }\n\n        if (maxRight < bbox.x + bbox.width || !$type.isNumber(maxRight)) {\n          maxRight = bbox.x + bbox.width;\n        }\n\n        if (maxTop > bbox.y || !$type.isNumber(maxTop)) {\n          maxTop = bbox.y;\n        }\n\n        if (maxBottom < bbox.y + bbox.height || !$type.isNumber(maxBottom)) {\n          maxBottom = bbox.y + bbox.height;\n        }\n      });\n    }\n\n    this.seriesMaxLeft = maxLeft;\n    this.seriesMaxRight = maxRight;\n    this.seriesMaxTop = maxTop;\n    this.seriesMaxBottom = maxBottom;\n    this.seriesWidth = maxRight - maxLeft;\n    this.seriesHeight = maxBottom - maxTop;\n\n    if (this.seriesWidth > 0 && this.seriesHeight > 0) {\n      this.chartContainer.visible = true;\n      this._centerGeoPoint = this.projection.invert({\n        x: maxLeft + (maxRight - maxLeft) / 2,\n        y: maxTop + (maxBottom - maxTop) / 2\n      });\n\n      if (!this._zoomGeoPointReal || !$type.isNumber(this._zoomGeoPointReal.latitude)) {\n        this._zoomGeoPointReal = this._centerGeoPoint;\n      }\n    } else {\n      this.chartContainer.visible = false;\n    }\n  };\n  /**\r\n   * Prevents map to be dragged out of the container area\r\n   * @ignore\r\n   */\n\n\n  MapChart.prototype.handleDrag = function () {\n    var d = this.zoomLevel * this.scaleRatio;\n    var ww = this.seriesWidth * d;\n    var hh = this.seriesHeight * d;\n    var seriesContainer = this.seriesContainer;\n    var maxLeft = this.seriesMaxLeft * d;\n    var maxRight = this.seriesMaxRight * d;\n    var maxTop = this.seriesMaxTop * d;\n    var maxBottom = this.seriesMaxBottom * d;\n    var x = seriesContainer.pixelX;\n    var y = seriesContainer.pixelY;\n    var maxPanOut = this.maxPanOut;\n    var minX = Math.min(this.maxWidth * (1 - maxPanOut) - ww - maxLeft, -maxLeft);\n\n    if (x < minX) {\n      x = minX;\n    }\n\n    var maxX = Math.max(this.maxWidth * maxPanOut - maxLeft, this.maxWidth - maxRight);\n\n    if (x > maxX) {\n      x = maxX;\n    }\n\n    var minY = Math.min(this.maxHeight * (1 - maxPanOut) - hh - maxTop, -maxTop);\n\n    if (y < minY) {\n      y = minY;\n    }\n\n    var maxY = Math.max(this.maxHeight * maxPanOut - maxTop, this.maxHeight - maxBottom);\n\n    if (y > maxY) {\n      y = maxY;\n    }\n\n    seriesContainer.moveTo({\n      x: x,\n      y: y\n    }, undefined, undefined, true);\n    this._zoomGeoPointReal = this.zoomGeoPoint;\n  };\n  /**\r\n   * Sets defaults that instantiate some objects that rely on parent, so they\r\n   * cannot be set in constructor.\r\n   */\n\n\n  MapChart.prototype.applyInternalDefaults = function () {\n    _super.prototype.applyInternalDefaults.call(this); // Add a default screen reader title for accessibility\n    // This will be overridden in screen reader if there are any `titles` set\n\n\n    if (!$type.hasValue(this.readerTitle)) {\n      this.readerTitle = this.language.translate(\"Map\");\n    }\n\n    if (!$type.hasValue(this.background.readerTitle)) {\n      this.background.readerTitle = this.language.translate(\"Use plus and minus keys on your keyboard to zoom in and out\");\n    }\n  };\n  /**\r\n   * Handles event when a pointer presses down on the map, e.g. user presses\r\n   * down mouse or touches the map on a screen.\r\n   *\r\n   * Stops all animations currently going on.\r\n   */\n\n\n  MapChart.prototype.handleMapDown = function () {\n    if (this._mapAnimation) {\n      this._mapAnimation.stop();\n    }\n  };\n  /**\r\n   * Handles the event when user doubleclicks or dooubletaps the map: zooms\r\n   * in on the reference point.\r\n   *\r\n   * @param event  Original event\r\n   */\n\n\n  MapChart.prototype.handleDoubleHit = function (event) {\n    var svgPoint = $utils.documentPointToSvg(event.point, this.htmlContainer, this.svgContainer.cssScale);\n    var geoPoint = this.svgPointToGeo(svgPoint);\n    this.zoomIn(geoPoint);\n  };\n  /**\r\n   * Handles mouse wheel event, e.g. user rotates mouse wheel while over the\r\n   * map: zooms in or out depending on the direction of the wheel turn.\r\n   *\r\n   * @param event  Original event\r\n   */\n\n\n  MapChart.prototype.handleWheel = function (event) {\n    // Cancel any move inertia if there is one\n    var inertia = this.seriesContainer.interactions.inertias.getKey(\"move\");\n\n    if (inertia) {\n      inertia.done();\n    }\n\n    var svgPoint = $utils.documentPointToSvg(event.point, this.htmlContainer, this.svgContainer.cssScale);\n    var geoPoint = this.svgPointToGeo(svgPoint);\n\n    if (event.shift.y < 0) {\n      this.zoomIn(geoPoint, undefined, this.interactions.mouseOptions.sensitivity);\n    } else {\n      this.zoomOut(geoPoint, undefined, this.interactions.mouseOptions.sensitivity);\n    }\n  };\n\n  Object.defineProperty(MapChart.prototype, \"mouseWheelBehavior\", {\n    /**\r\n     * @return mouse wheel behavior\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"mouseWheelBehavior\");\n    },\n\n    /**\r\n     * Specifies what should chart do if when mouse wheel is rotated.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/reference/sprite/#mouseOptions_property} More information about `mouseOptions`\r\n     * @param mouse wheel behavior\r\n     * @default zoomX\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"mouseWheelBehavior\", value)) {\n        if (value != \"none\") {\n          this._mouseWheelDisposer = this.chartContainer.events.on(\"wheel\", this.handleWheel, this, false);\n\n          this._disposers.push(this._mouseWheelDisposer);\n        } else {\n          if (this._mouseWheelDisposer) {\n            this._mouseWheelDisposer.dispose();\n          }\n\n          this.chartContainer.wheelable = false;\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapChart.prototype, \"panBehavior\", {\n    /**\r\n     * @returns Behavior\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"panBehavior\");\n    },\n\n    /**\r\n     * What \"dragging\" map does.\r\n     *\r\n     * Available values:\r\n     * * `\"move\"` (default): changes position of the map.\r\n     * * `\"rotateLat\"`: changes `deltaLatitude` (rotates the globe vertically).\r\n     * * `\"rotateLong\"`: changes `deltaLongitude` (rotates the globe horizontally).\r\n     * * `\"rotateLongLat\"`: changes both `deltaLongitude` and `deltaLatitude` (rotates the globe in any direction).\r\n     *\r\n     * @default \"move\"\r\n     * @since 4.3.0\r\n     * @param  value  Behavior\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"panBehavior\", value)) {\n        var seriesContainer = this.seriesContainer;\n        this.panSprite.draggable = false;\n        seriesContainer.draggable = false;\n\n        switch (value) {\n          case \"move\":\n            seriesContainer.draggable = true;\n            break;\n\n          default:\n            this.panSprite.draggable = true;\n            break;\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapChart.prototype, \"centerMapOnZoomOut\", {\n    /**\r\n     * @returns If the map should be centered when zooming out.\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"centerMapOnZoomOut\");\n    },\n\n    /**\r\n     * Specifies if the map should be centered when zooming out\r\n     * @default true\r\n     * @since 4.7.12\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"centerMapOnZoomOut\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapChart.prototype, \"projection\", {\n    /**\r\n     * @return Projection\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"projection\");\n    },\n\n    /**\r\n     * Projection to use for the map.\r\n     *\r\n     * Available projections:\r\n     * * Albers\r\n     * * AlbersUSA\r\n     * * AzimuthalEqualArea\r\n     * * Eckert6\r\n     * * EqualEarth\r\n     * * Mercator\r\n     * * Miller\r\n     * * NaturalEarth\r\n     * * Orthographic\r\n     * * Stereographic\r\n     *\r\n     * ```TypeScript\r\n     * map.projection = new am4maps.projections.Mercator();\r\n     * ```\r\n     * ```JavaScript\r\n     * map.projection = new am4maps.projections.Mercator();\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"projection\": \"Mercator\"\r\n     *   // ...\r\n     * }\r\n     * ```\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/chart-types/map/#Setting_projection} More about projections\r\n     * @param projection  Projection\r\n     */\n    set: function (projection) {\n      var _this = this;\n\n      if (this.setPropertyValue(\"projection\", projection)) {\n        this.invalidateProjection();\n        projection.chart = this;\n\n        if (this._backgroundSeries) {\n          this._backgroundSeries.invalidate();\n        }\n\n        if (this.inited) {\n          this.updateExtremes();\n        }\n\n        this.series.each(function (series) {\n          series.events.once(\"validated\", function () {\n            _this.updateCenterGeoPoint();\n\n            _this.updateScaleRatio();\n\n            _this.goHome(0);\n          });\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Validates (processes) data items.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n  MapChart.prototype.validateDataItems = function () {\n    _super.prototype.validateDataItems.call(this);\n\n    this.updateExtremes();\n  };\n  /**\r\n   * Calculates the longitudes and latitudes of the most distant points from\r\n   * the center in all four directions: West, East, North, and South.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n\n\n  MapChart.prototype.updateExtremes = function () {\n    var east;\n    var north;\n    var west;\n    var south;\n    this.series.each(function (series) {\n      if (series.ignoreBounds || series instanceof GraticuleSeries && series.fitExtent) {} else {\n        if (series.north > north || !$type.isNumber(north)) {\n          north = series.north;\n        }\n\n        if (series.south < south || !$type.isNumber(south)) {\n          south = series.south;\n        }\n\n        if (series.west < west || !$type.isNumber(west)) {\n          west = series.west;\n        }\n\n        if (series.east > east || !$type.isNumber(east)) {\n          east = series.east;\n        }\n      }\n    });\n    var features = [];\n    var foundGraticule = false; // if we gave graticule, get features of these series only for faster fitSize\n\n    this.series.each(function (series) {\n      if (series instanceof GraticuleSeries && !series.fitExtent) {\n        features = series.getFeatures();\n        foundGraticule = true;\n      }\n    });\n\n    if (!foundGraticule) {\n      this.series.each(function (series) {\n        if (series.ignoreBounds || series instanceof GraticuleSeries && series.fitExtent) {} else {\n          features = features.concat(series.getFeatures());\n        }\n      });\n    }\n\n    var w = $math.max(50, this.innerWidth);\n    var h = $math.max(50, this.innerHeight);\n    var d3Projection = this.projection.d3Projection;\n\n    if (features.length > 0 && d3Projection && (this.east != east || this.west != west || this.north != north || this.south != south)) {\n      this.east = east;\n      this.west = west;\n      this.north = north;\n      this.south = south;\n\n      if (d3Projection.rotate) {\n        var rotation = d3Projection.rotate();\n        var deltaLong = rotation[0];\n        var deltaLat = rotation[1];\n        var deltaGamma = rotation[2];\n        this.deltaLongitude = deltaLong;\n        this.deltaLatitude = deltaLat;\n        this.deltaGamma = deltaGamma;\n      }\n\n      var geoJSON = {\n        \"type\": \"FeatureCollection\",\n        features: features\n      };\n      var initialScale = d3Projection.scale();\n      d3Projection.fitSize([w, h], geoJSON);\n\n      if (d3Projection.scale() != initialScale) {\n        this.invalidateDataUsers();\n      }\n\n      this.series.each(function (series) {\n        if (series instanceof GraticuleSeries) {\n          series.invalidateData();\n        }\n      });\n\n      if (this._backgroundSeries) {\n        var polygon = this._backgroundSeries.mapPolygons.getIndex(0);\n\n        if (polygon) {\n          polygon.multiPolygon = $mapUtils.getBackground(this.north, this.east, this.south, this.west);\n        }\n      }\n\n      this._fitWidth = w;\n      this._fitHeight = h;\n    }\n\n    if (!this._zoomGeoPointReal || !$type.isNumber(this._zoomGeoPointReal.latitude)) {\n      this.goHome(0);\n    }\n  };\n  /**\r\n   * (Re)calculates a ratio which should be used to scale the actual map so\r\n   * that it fits perfectly into available space. Helps to avoid redrawing of all the map if container size changes\r\n   * @ignore\r\n   */\n\n\n  MapChart.prototype.updateScaleRatio = function () {\n    var scaleRatio;\n    this.updateCenterGeoPoint();\n    var hScale = this.innerWidth / this.seriesWidth;\n    var vScale = this.innerHeight / this.seriesHeight;\n    scaleRatio = $math.min(hScale, vScale);\n\n    if ($type.isNaN(scaleRatio) || scaleRatio == Infinity) {\n      scaleRatio = 1;\n    }\n\n    if (scaleRatio != this.scaleRatio) {\n      this.scaleRatio = scaleRatio;\n      $iter.each(this.series.iterator(), function (series) {\n        series.scale = scaleRatio;\n        series.updateTooltipBounds();\n      });\n      this.backgroundSeries.scale = scaleRatio;\n      this.dispatch(\"scaleratiochanged\");\n    }\n  };\n  /**\r\n   * Converts a point within map container to geographical (lat/long)\r\n   * coordinates.\r\n   *\r\n   * @param point  Source point\r\n   * @return Geo-point\r\n   */\n\n\n  MapChart.prototype.svgPointToGeo = function (point) {\n    var series = this.series.getIndex(0);\n\n    if (series) {\n      var seriesPoint = $utils.svgPointToSprite(point, series);\n      return this.seriesPointToGeo(seriesPoint);\n    }\n  };\n  /**\r\n   * Converts geographical (lat/long) coordinates to an X/Y point within map's\r\n   * container.\r\n   *\r\n   * @param point  Source geo-point\r\n   * @return Point\r\n   */\n\n\n  MapChart.prototype.geoPointToSVG = function (point) {\n    var series = this.series.getIndex(0);\n\n    if (series) {\n      var seriesPoint = this.geoPointToSeries(point);\n      return $utils.spritePointToSvg(seriesPoint, series);\n    }\n  };\n  /**\r\n   * Converts a point (X/Y) within actual objects of the map to geographical\r\n   * (lat/long) coordinates.\r\n   *\r\n   * @param point  Source point\r\n   * @return Geo-point\r\n   */\n\n\n  MapChart.prototype.seriesPointToGeo = function (point) {\n    return this.projection.invert(point);\n  };\n  /**\r\n   * Converts geographical (lat/long) coordinates to an X/Y point within\r\n   * actual elements/objects of the maps.\r\n   *\r\n   * @param point  Source geo-point\r\n   * @return Point\r\n   */\n\n\n  MapChart.prototype.geoPointToSeries = function (point) {\n    return this.projection.convert(point);\n  };\n\n  Object.defineProperty(MapChart.prototype, \"geodata\", {\n    /**\r\n     * @return GeoJSON data\r\n     */\n    get: function () {\n      return this._geodata;\n    },\n\n    /**\r\n     * Map data in GeoJSON format.\r\n     *\r\n     * The Map supports the following GeoJSON objects: `Point`, `LineString`,\r\n     * `Polygon`, `MultiPoint`, `MultiLineString`, and `MultiPolygon`.\r\n     *\r\n     * @see {@link http://geojson.org/} Official GeoJSON format specification\r\n     * @param geoJSON GeoJSON data\r\n     */\n    set: function (geodata) {\n      if (geodata != this._geodata) {\n        this._geodata = geodata;\n        this.invalidateData();\n        this.dataUsers.each(function (dataUser) {\n          for (var i = dataUser.data.length - 1; i >= 0; i--) {\n            if (dataUser.data[i].madeFromGeoData == true) {\n              dataUser.data.splice(i, 1);\n            }\n          }\n\n          dataUser.disposeData();\n          dataUser.invalidateData();\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Zooms the map to particular zoom level and centers on a latitude/longitude\r\n   * coordinate.\r\n   *\r\n   * @param point      Center coordinate\r\n   * @param zoomLevel  Zoom level\r\n   * @param center     Center on the given coordinate?\r\n   * @param duration   Duration for zoom animation (ms)\r\n   * @return Zoom animation\r\n   */\n\n  MapChart.prototype.zoomToGeoPoint = function (point, zoomLevel, center, duration, mapObject) {\n    var _this = this;\n\n    if (!point) {\n      var hasData_1 = false;\n      this.series.each(function (series) {\n        if (series.dataItems.length > 0) {\n          hasData_1 = true;\n        }\n      });\n\n      if (hasData_1) {\n        point = this.zoomGeoPoint;\n      } else {\n        return;\n      }\n    }\n\n    if (!point || !$type.isNumber(point.longitude) || !$type.isNumber(point.latitude)) {\n      return;\n    }\n\n    this._zoomGeoPointReal = point;\n    zoomLevel = $math.fitToRange(zoomLevel, this.minZoomLevel, this.maxZoomLevel);\n    var seriesPoint = this.projection.convert(point);\n\n    if (seriesPoint) {\n      var svgPoint = this.geoPointToSVG(point);\n      var mapPoint = $utils.svgPointToSprite(svgPoint, this);\n\n      if (center) {\n        mapPoint = {\n          x: this.innerWidth / 2,\n          y: this.innerHeight / 2\n        };\n      }\n\n      if (!$type.isNumber(duration)) {\n        duration = this.zoomDuration;\n      }\n\n      var x = mapPoint.x - seriesPoint.x * zoomLevel * this.scaleRatio;\n      var y = mapPoint.y - seriesPoint.y * zoomLevel * this.scaleRatio;\n\n      if (!mapObject && zoomLevel < this.zoomLevel && this.centerMapOnZoomOut && zoomLevel < 1.5) {\n        x = this.innerWidth / 2 - (this.seriesMaxLeft + (this.seriesMaxRight - this.seriesMaxLeft) / 2) * zoomLevel * this.scaleRatio;\n        y = this.innerHeight / 2 - (this.seriesMaxTop + (this.seriesMaxBottom - this.seriesMaxTop) / 2) * zoomLevel * this.scaleRatio;\n      }\n\n      this._mapAnimation = this.seriesContainer.animate([{\n        property: \"scale\",\n        to: zoomLevel\n      }, {\n        property: \"x\",\n        from: this.seriesContainer.pixelX,\n        to: x\n      }, {\n        property: \"y\",\n        from: this.seriesContainer.pixelY,\n        to: y\n      }], duration, this.zoomEasing);\n\n      this._disposers.push(this._mapAnimation.events.on(\"animationended\", function () {\n        _this._zoomGeoPointReal = _this.zoomGeoPoint;\n      }));\n\n      this.seriesContainer.validatePosition();\n      return this._mapAnimation;\n    }\n  };\n  /**\r\n   * Zooms the map to a particular map object.\r\n   *\r\n   * @param mapObject  Target map object\r\n   * @param zoomLevel  Zoom level\r\n   * @param center     Center on the given coordinate?\r\n   * @param duration   Duration for zoom animation (ms)\r\n   * @return Zoom animation\r\n   */\n\n\n  MapChart.prototype.zoomToMapObject = function (mapObject, zoomLevel, center, duration) {\n    if (center == undefined) {\n      center = true;\n    }\n\n    var inertia = this.seriesContainer.interactions.inertias.getKey(\"move\");\n\n    if (inertia) {\n      inertia.done();\n    }\n\n    if (mapObject instanceof MapImage) {\n      if ($type.isNaN(zoomLevel)) {\n        zoomLevel = 5;\n      }\n\n      return this.zoomToGeoPoint({\n        latitude: mapObject.latitude,\n        longitude: mapObject.longitude\n      }, zoomLevel, center, duration, true);\n    }\n\n    var dataItem = mapObject.dataItem;\n\n    if (dataItem && $type.isNumber(dataItem.zoomLevel)) {\n      zoomLevel = dataItem.zoomLevel;\n    }\n\n    if (mapObject instanceof MapPolygon) {\n      var dataItem_1 = mapObject.dataItem;\n      var bbox = mapObject.polygon.bbox;\n\n      if (bbox.width == 0 || bbox.height == 0) {\n        bbox = mapObject.polygon.group.getBBox();\n      }\n\n      if (!$type.isNumber(zoomLevel)) {\n        zoomLevel = Math.min(this.seriesWidth / bbox.width, this.seriesHeight / bbox.height);\n      }\n\n      var geoPoint = void 0;\n\n      if (dataItem_1 && $type.hasValue(dataItem_1.zoomGeoPoint)) {\n        geoPoint = dataItem_1.zoomGeoPoint;\n      } else {\n        // this is more accurate\n        var polygonPoint = {\n          x: bbox.x + bbox.width / 2,\n          y: bbox.y + bbox.height / 2\n        };\n        var seriesPoint = $utils.spritePointToSprite(polygonPoint, mapObject.polygon, mapObject.series);\n        geoPoint = this.seriesPointToGeo(seriesPoint);\n      }\n\n      return this.zoomToGeoPoint(geoPoint, zoomLevel, true, duration, true);\n    }\n  };\n  /**\r\n   * Zooms the map to a particular viewport.\r\n   *\r\n   * The `north`, `east`, `south`, and `west` define boundaries of the\r\n   * imaginary viewort we want to zoom the map to.\r\n   *\r\n   * `level` is not actual zoom level. The map will determine the zoom level\r\n   * required to accommodated such zoom, and will adjust it by `level` if set.\r\n   *\r\n   * @param north     Latitude of the North-most boundary\r\n   * @param east      Longitude of the East-most boundary\r\n   * @param south     Latitude of the South-most boundary\r\n   * @param west      Longitude of the West-most boundary\r\n   * @param level     Adjust zoom level\r\n   * @param center    Center on the given coordinate?\r\n   * @param duration  Duration for zoom animation (ms)\r\n   * @return Zoom animation\r\n   */\n\n\n  MapChart.prototype.zoomToRectangle = function (north, east, south, west, level, center, duration) {\n    if ($type.isNaN(level)) {\n      level = 1;\n    }\n\n    var w = $math.min(west, east);\n    var e = $math.max(west, east);\n    west = w;\n    east = e;\n    var splitLongitude = $math.normalizeAngle(180 - this.deltaLongitude);\n\n    if (splitLongitude > 180) {\n      splitLongitude -= 360;\n    }\n\n    var newLong = west + (east - west) / 2;\n    var d = west - east;\n\n    if (west < splitLongitude && east > splitLongitude) {\n      newLong += 180;\n      d = $math.normalizeAngle(east - west - 360);\n    }\n\n    var zoomLevel = level * Math.min((this.south - this.north) / (south - north), Math.abs((this.west - this.east) / d));\n    return this.zoomToGeoPoint({\n      latitude: north + (south - north) / 2,\n      longitude: newLong\n    }, zoomLevel, center, duration, true);\n  };\n  /**\r\n   * Zooms in the map, optionally centering on particular latitude/longitude\r\n   * point.\r\n   *\r\n   * @param geoPoint  Optional center point\r\n   * @param duration  Duration for zoom animation (ms)\r\n   * @return Zoom animation\r\n   */\n\n\n  MapChart.prototype.zoomIn = function (geoPoint, duration, sensitivity) {\n    if (sensitivity === void 0) {\n      sensitivity = 1;\n    }\n\n    var step = 1 + (this.zoomStep - 1) * sensitivity;\n\n    if (step < 1) {\n      step = 1;\n    }\n\n    return this.zoomToGeoPoint(geoPoint, this.zoomLevel * step, false, duration);\n  };\n  /**\r\n   * Zooms out the map, optionally centering on particular latitude/longitude\r\n   * point.\r\n   *\r\n   * @param geoPoint  Optional center point\r\n   * @param duration  Duration for zoom animation (ms)\r\n   * @return Zoom animation\r\n   */\n\n\n  MapChart.prototype.zoomOut = function (geoPoint, duration, sensitivity) {\n    if (sensitivity === void 0) {\n      sensitivity = 1;\n    }\n\n    var step = 1 + (this.zoomStep - 1) * sensitivity;\n\n    if (step < 1) {\n      step = 1;\n    }\n\n    return this.zoomToGeoPoint(geoPoint, this.zoomLevel / step, false, duration);\n  };\n  /**\r\n   * Pans the maps using relative coordinates. E.g.:\r\n   *\r\n   * ```JSON\r\n   * {\r\n   *   x: 0.1,\r\n   *   y: -0.1\r\n   * }\r\n   * ```\r\n   *\r\n   * The above will move the map by 10% to the right, and by 10% upwards.\r\n   *\r\n   * @param shift     Vertical and horizontal shift\r\n   * @param duration  Pan animation duration (ms)\r\n   */\n\n\n  MapChart.prototype.pan = function (shift, duration) {\n    var point = this.geoPointToSVG(this.zoomGeoPoint);\n    point.x += this.pixelWidth * shift.x;\n    point.y += this.pixelHeight * shift.y;\n    this.zoomToGeoPoint(this.svgPointToGeo(point), this.zoomLevel, true, duration, true);\n  };\n\n  Object.defineProperty(MapChart.prototype, \"zoomGeoPoint\", {\n    /**\r\n     * Current lat/long coordinates for the center of the viewport. (default\r\n     * zoom reference point)\r\n     *\r\n     * @readonly\r\n     * @return Coordinates\r\n     */\n    get: function () {\n      var point = $utils.spritePointToSvg({\n        x: this.pixelWidth / 2,\n        y: this.pixelHeight / 2\n      }, this);\n      return this.svgPointToGeo(point);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapChart.prototype, \"zoomLevel\", {\n    /**\r\n     * @return Zoom level\r\n     */\n    get: function () {\n      return this.seriesContainer.scale;\n    },\n\n    /**\r\n     * Current zoom level.\r\n     *\r\n     * @readonly\r\n     * @return Zoom level\r\n     */\n    set: function (value) {\n      this.seriesContainer.scale = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Dispatches events after some map transformation, like pan or zoom.\r\n   *\r\n   * @ignore\r\n   */\n\n  MapChart.prototype.handleMapTransform = function () {\n    if (this.zoomLevel != this._prevZoomLevel) {\n      this.dispatch(\"zoomlevelchanged\");\n      this._prevZoomLevel = this.zoomLevel;\n      this.svgContainer.readerAlert(this.language.translate(\"Zoom level changed to %1\", this.language.locale, $type.castString(this.zoomLevel)));\n    }\n\n    if (this.zoomGeoPoint && (this._prevZoomGeoPoint.latitude != this.zoomGeoPoint.latitude || this._prevZoomGeoPoint.longitude != this.zoomGeoPoint.longitude)) {\n      this.dispatch(\"mappositionchanged\");\n    }\n  };\n\n  Object.defineProperty(MapChart.prototype, \"smallMap\", {\n    /**\r\n     * @return Small map\r\n     */\n    get: function () {\n      if (!this._smallMap) {\n        var smallMap = new SmallMap();\n        this.smallMap = smallMap;\n      }\n\n      return this._smallMap;\n    },\n\n    /**\r\n     * A [[SmallMap]] to be used on the map.\r\n     *\r\n     * Please note, that accessing this property will NOT create a small map\r\n     * if it has not yet been created. (except in JSON)\r\n     *\r\n     * ```TypeScript\r\n     * // Create a small map\r\n     * map.smallMap = new am4maps.SmallMap();\r\n     * ```\r\n     * ```JavaScript\r\n     * // Create a small map\r\n     * map.smallMap = new am4maps.SmallMap();\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"smallMap\": {}\r\n     *   // ...\r\n     * }\r\n     * ```\r\n     *\r\n     * @param smallMap  Small map\r\n     */\n    set: function (smallMap) {\n      if (this._smallMap) {\n        this.removeDispose(this._smallMap);\n      }\n\n      this._smallMap = smallMap;\n      this._smallMap.chart = this;\n      smallMap.parent = this.chartContainer;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapChart.prototype, \"zoomControl\", {\n    /**\r\n     * @return Zoom control\r\n     */\n    get: function () {\n      return this._zoomControl;\n    },\n\n    /**\r\n     * A [[ZoomControl]] to be used on the map.\r\n     *\r\n     * Please note, that accessing this property will NOT create a zoom control\r\n     * if it has not yet been created. (except in JSON)\r\n     *\r\n     * ```TypeScript\r\n     * // Create a zoom control\r\n     * map.zoomControl = new am4maps.ZoomControl();\r\n     * ```\r\n     * ```JavaScript\r\n     * // Create a zoom control\r\n     * map.zoomControl = new am4maps.ZoomControl();\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   // ...\r\n     *   \"zoomControl\": {}\r\n     *   // ...\r\n     * }\r\n     * ```\r\n     *\r\n     * @param zoomControl  Zoom control\r\n     */\n    set: function (zoomControl) {\n      if (this._zoomControl) {\n        this.removeDispose(this._zoomControl);\n      }\n\n      this._zoomControl = zoomControl;\n      zoomControl.chart = this;\n      zoomControl.parent = this.chartContainer;\n      zoomControl.plusButton.exportable = false;\n      zoomControl.minusButton.exportable = false;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Creates and returns a map series of appropriate type.\r\n   *\r\n   * @return Map series\r\n   */\n\n  MapChart.prototype.createSeries = function () {\n    return new MapSeries();\n  };\n\n  Object.defineProperty(MapChart.prototype, \"deltaLongitude\", {\n    /**\r\n     * @return Rotation\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"deltaLongitude\");\n    },\n\n    /**\r\n     * Degrees to rotate the map around vertical axis (Y).\r\n     *\r\n     * E.g. if set to -160, the longitude 20 will become a new center, creating\r\n     * a Pacific-centered map.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/chart-types/map/#Map_rotation} For more info on map rotation.\r\n     * @param  value  Rotation\r\n     */\n    set: function (value) {\n      value = $math.round(value, 3);\n\n      if (this.setPropertyValue(\"deltaLongitude\", $geo.wrapAngleTo180(value))) {\n        this.rotateMap();\n        this.updateZoomGeoPoint();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapChart.prototype, \"deltaLatitude\", {\n    /**\r\n     * @return Rotation\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"deltaLatitude\");\n    },\n\n    /**\r\n     * Degrees to rotate the map around horizontal axis (X).\r\n     *\r\n     * E.g. setting this to 90 will put Antarctica directly in the center of\r\n     * the map.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/chart-types/map/#Map_rotation} For more info on map rotation.\r\n     * @since 4.3.0\r\n     * @param  value  Rotation\r\n     */\n    set: function (value) {\n      value = $math.round(value, 3);\n\n      if (this.setPropertyValue(\"deltaLatitude\", value)) {\n        this.rotateMap();\n        this.updateZoomGeoPoint();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapChart.prototype, \"deltaGamma\", {\n    /**\r\n     * @return Rotation\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"deltaGamma\");\n    },\n\n    /**\r\n     * Degrees to rotate the map around \"Z\" axis. This is the axis that pierces\r\n     * the globe directly from the viewer's point of view.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/chart-types/map/#Map_rotation} For more info on map rotation.\r\n     * @since 4.3.0\r\n     * @param  value  Rotation\r\n     */\n    set: function (value) {\n      value = $math.round(value, 3);\n\n      if (this.setPropertyValue(\"deltaGamma\", value)) {\n        this.rotateMap();\n        this.updateZoomGeoPoint();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  MapChart.prototype.rotateMap = function () {\n    if (this.projection.d3Projection) {\n      if (this.projection.d3Projection.rotate) {\n        this.projection.d3Projection.rotate([this.deltaLongitude, this.deltaLatitude, this.deltaGamma]);\n        this.invalidateProjection();\n        this.updateExtremes();\n      }\n    }\n  };\n\n  Object.defineProperty(MapChart.prototype, \"maxPanOut\", {\n    /**\r\n     * @return Max pan out\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"maxPanOut\");\n    },\n\n    /**\r\n     * Maximum portion of the map's width/height to allow panning \"off screen\".\r\n     *\r\n     * A value of 0 (zero) will prevent any portion of the the map to be panned\r\n     * outside the viewport.\r\n     *\r\n     * 0.5 will allow half of the map to be outside viewable area.\r\n     *\r\n     * @default 0.7\r\n     * @param value  Max pan out\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"maxPanOut\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapChart.prototype, \"homeGeoPoint\", {\n    /**\r\n     * @return Home geo point\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"homeGeoPoint\");\n    },\n\n    /**\r\n     * The geographical point to center map on when it is first loaded.\r\n     *\r\n     * The map will also be centered to this point when you call `goHome()`\r\n     * method.\r\n     *\r\n     * @param value  Home geo point\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"homeGeoPoint\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapChart.prototype, \"homeZoomLevel\", {\n    /**\r\n     * @return Home zoom level\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"homeZoomLevel\");\n    },\n\n    /**\r\n     * The zoom level to put the map in when it is first loaded.\r\n     *\r\n     * The map will also be set to this zoom level when you call `goHome()`\r\n     * method.\r\n     *\r\n     * @param value  Home zoom level\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"homeZoomLevel\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapChart.prototype, \"zoomStep\", {\n    /**\r\n     * @return Zoom factor\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"zoomStep\");\n    },\n\n    /**\r\n     * When user zooms in or out current zoom level is multiplied or divided\r\n     * by value of this setting.\r\n     *\r\n     * @default 2\r\n     * @param value  Zoom factor\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"zoomStep\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Invalidates projection, causing all series to be redrawn.\r\n   *\r\n   * Call this after changing projection or its settings.\r\n   */\n\n  MapChart.prototype.invalidateProjection = function () {\n    this.east = undefined;\n    this.invalidateDataUsers();\n    this.updateCenterGeoPoint();\n  };\n\n  Object.defineProperty(MapChart.prototype, \"geodataSource\", {\n    /**\r\n     * Returns a [[DataSource]] specifically for loading Component's data.\r\n     *\r\n     * @return Data source\r\n     */\n    get: function () {\n      if (!this._dataSources[\"geodata\"]) {\n        this.getDataSource(\"geodata\");\n      }\n\n      return this._dataSources[\"geodata\"];\n    },\n\n    /**\r\n     * Sets a [[DataSource]] to be used for loading Component's data.\r\n     *\r\n     * @param value Data source\r\n     */\n    set: function (value) {\n      var _this = this;\n\n      if (this._dataSources[\"geodata\"]) {\n        this.removeDispose(this._dataSources[\"geodata\"]);\n      }\n\n      this._dataSources[\"geodata\"] = value;\n      this._dataSources[\"geodata\"].component = this;\n      this.events.on(\"inited\", function () {\n        _this.loadData(\"geodata\");\n      }, this, false);\n      this.setDataSourceEvents(value, \"geodata\");\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n\n  MapChart.prototype.processConfig = function (config) {\n    if ($type.hasValue(config[\"geodata\"]) && $type.isString(config[\"geodata\"])) {\n      var name_1 = config[\"geodata\"]; // Check if there's a map loaded by such name\n\n      if ($type.hasValue(window[\"am4geodata_\" + config[\"geodata\"]])) {\n        config[\"geodata\"] = window[\"am4geodata_\" + config[\"geodata\"]];\n      } // Nope. Let's try maybe we got JSON as string?\n      else {\n          try {\n            config[\"geodata\"] = JSON.parse(config[\"geodata\"]);\n          } catch (e) {\n            // No go again. Error out.\n            this.raiseCriticalError(Error(\"MapChart error: Geodata `\" + name_1 + \"` is not loaded or is incorrect.\"), true);\n          }\n        }\n    } // Instantiate projection\n\n\n    if ($type.hasValue(config[\"projection\"]) && $type.isString(config[\"projection\"])) {\n      config[\"projection\"] = this.createClassInstance(config[\"projection\"]);\n    } // Set up small map\n\n\n    if ($type.hasValue(config.smallMap) && !$type.hasValue(config.smallMap.type)) {\n      config.smallMap.type = \"SmallMap\";\n    } // Set up zoom control\n\n\n    if ($type.hasValue(config.zoomControl) && !$type.hasValue(config.zoomControl.type)) {\n      config.zoomControl.type = \"ZoomControl\";\n    }\n\n    _super.prototype.processConfig.call(this, config);\n  };\n  /**\r\n   * Decorates a new [[Series]] object with required parameters when it is\r\n   * added to the chart.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param event  Event\r\n   */\n\n\n  MapChart.prototype.handleSeriesAdded = function (event) {\n    _super.prototype.handleSeriesAdded.call(this, event);\n\n    var series = event.newValue;\n    series.scale = this.scaleRatio;\n    series.events.on(\"validated\", this.updateCenterGeoPoint, this, false);\n  };\n  /**\r\n   * This function is used to sort element's JSON config properties, so that\r\n   * some properties that absolutely need to be processed last, can be put at\r\n   * the end.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param a  Element 1\r\n   * @param b  Element 2\r\n   * @return Sorting number\r\n   */\n\n\n  MapChart.prototype.configOrder = function (a, b) {\n    if (a == b) {\n      return 0;\n    } // Must come last\n    else if (a == \"smallMap\") {\n        return 1;\n      } else if (b == \"smallMap\") {\n        return -1;\n      } else if (a == \"series\") {\n        return 1;\n      } else if (b == \"series\") {\n        return -1;\n      } else {\n        return _super.prototype.configOrder.call(this, a, b);\n      }\n  };\n  /**\r\n   * Adds `projection` to \"as is\" fields.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as is?\r\n   */\n\n\n  MapChart.prototype.asIs = function (field) {\n    return field == \"projection\" || field == \"geodata\" || _super.prototype.asIs.call(this, field);\n  };\n\n  Object.defineProperty(MapChart.prototype, \"centerGeoPoint\", {\n    /**\r\n     * Geo point of map center\r\n     *\r\n     * @readonly\r\n     */\n    get: function () {\n      return this._centerGeoPoint;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Resets the map to its original position and zoom level.\r\n   *\r\n   * Use the only parameter to set number of milliseconds for the zoom\r\n   * animation to play.\r\n   *\r\n   * @param  duration  Duration (ms)\r\n   */\n\n  MapChart.prototype.goHome = function (duration) {\n    var homeGeoPoint = this.homeGeoPoint;\n\n    if (!homeGeoPoint) {\n      homeGeoPoint = this.centerGeoPoint;\n    }\n\n    if (homeGeoPoint) {\n      this.zoomToGeoPoint(homeGeoPoint, this.homeZoomLevel, true, duration, true);\n    }\n  };\n  /**\r\n   * Sets [[Paper]] instance to use to draw elements.\r\n   *\r\n   * @ignore\r\n   * @param   paper  Paper\r\n   * @return         true if paper was changed, false, if it's the same\r\n   */\n\n\n  MapChart.prototype.setPaper = function (paper) {\n    if (this.svgContainer) {\n      this.svgContainer.hideOverflow = true;\n    }\n\n    return _super.prototype.setPaper.call(this, paper);\n  };\n\n  Object.defineProperty(MapChart.prototype, \"backgroundSeries\", {\n    /**\r\n     * Background series will create polygons that will fill all the map area\r\n     * with some color (or other fill).\r\n     *\r\n     * This might be useful with non-rectangular projections, like Orthographic,\r\n     * Albers, etc.\r\n     *\r\n     * To change background color/opacity access polygon template.\r\n     *\r\n     * ```TypeScript\r\n     * chart.backgroundSeries.mapPolygons.template.polygon.fill = am4core.color(\"#fff\");\r\n     * chart.backgroundSeries.mapPolygons.template.polygon.fillOpacity = 0.1;\r\n     * ```\r\n     * ```JavaScript\r\n     * chart.backgroundSeries.mapPolygons.template.polygon.fill = am4core.color(\"#fff\");\r\n     * chart.backgroundSeries.mapPolygons.template.polygon.fillOpacity = 0.1;\r\n     * ```\r\n     * ```JSON\r\n     * {\r\n     *   \"backgroundSeries\": {\r\n     *     \"mapPolygons\": {\r\n     *       \"polygon\": {\r\n     *         \"fill\": \"#fff\",\r\n     *         \"fillOpacity\": 0.1\r\n     *       }\r\n     *     }\r\n     *   }\r\n     * }\r\n     * ```\r\n     *\r\n     * @since 4.3.0\r\n     */\n    get: function () {\n      var _this = this;\n\n      if (!this._backgroundSeries) {\n        var backgroundSeries = new MapPolygonSeries();\n        backgroundSeries.parent = this.seriesContainer;\n        backgroundSeries.chart = this;\n        backgroundSeries.hiddenInLegend = true;\n        backgroundSeries.mapPolygons.template.focusable = false;\n        backgroundSeries.addDisposer(new Disposer(function () {\n          _this._backgroundSeries = undefined;\n        }));\n\n        this._disposers.push(backgroundSeries);\n\n        var interfaceColors = new InterfaceColorSet();\n        var color = interfaceColors.getFor(\"background\");\n        var polygonTemplate = backgroundSeries.mapPolygons.template.polygon;\n        polygonTemplate.stroke = color;\n        polygonTemplate.fill = color;\n        polygonTemplate.fillOpacity = 0;\n        polygonTemplate.strokeOpacity = 0; //polygonTemplate.focusable = false;\n\n        backgroundSeries.mapPolygons.create();\n        this._backgroundSeries = backgroundSeries;\n      }\n\n      return this._backgroundSeries;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Prepares the legend instance for use in this chart.\r\n   *\r\n   * @param legend  Legend\r\n   */\n\n  MapChart.prototype.setLegend = function (legend) {\n    _super.prototype.setLegend.call(this, legend);\n\n    if (legend) {\n      legend.parent = this;\n    }\n  };\n  /**\r\n   * @param  value  Tap to activate?\r\n   */\n\n\n  MapChart.prototype.setTapToActivate = function (value) {\n    _super.prototype.setTapToActivate.call(this, value); // setup other containers\n\n\n    this.seriesContainer.interactions.isTouchProtected = true;\n    this.panSprite.interactions.isTouchProtected = true;\n  };\n\n  MapChart.prototype.handleTapToActivate = function () {\n    _super.prototype.handleTapToActivate.call(this);\n\n    this.seriesContainer.interactions.isTouchProtected = false;\n    this.panSprite.interactions.isTouchProtected = false;\n  };\n\n  MapChart.prototype.handleTapToActivateDeactivation = function () {\n    _super.prototype.handleTapToActivateDeactivation.call(this);\n\n    this.seriesContainer.interactions.isTouchProtected = true;\n    this.panSprite.interactions.isTouchProtected = true;\n  };\n  /**\r\n   * Adds easing functions to \"function\" fields.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as function?\r\n   */\n\n\n  MapChart.prototype.asFunction = function (field) {\n    return field == \"zoomEasing\" || _super.prototype.asIs.call(this, field);\n  };\n\n  return MapChart;\n}(SerialChart);\n\nexport { MapChart };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\n\nregistry.registeredClasses[\"MapChart\"] = MapChart;","map":{"version":3,"sources":["../../../../../src/.internal/charts/types/MapChart.ts"],"names":[],"mappings":"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","sourcesContent":["/**\r\n * Map module.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { SerialChart, ISerialChartProperties, ISerialChartDataFields, ISerialChartAdapters, ISerialChartEvents, SerialChartDataItem } from \"./SerialChart\";\r\nimport { Sprite, ISpriteEvents, AMEvent } from \"../../core/Sprite\";\r\nimport { IDisposer, Disposer } from \"../../core/utils/Disposer\";\r\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\r\nimport { MapSeries } from \"../map/MapSeries\";\r\nimport { MapObject } from \"../map/MapObject\";\r\nimport { MapImage } from \"../map/MapImage\";\r\nimport { MapPolygon } from \"../map/MapPolygon\";\r\nimport { MapPolygonSeries } from \"../map/MapPolygonSeries\";\r\nimport { IPoint } from \"../../core/defs/IPoint\";\r\nimport { IGeoPoint } from \"../../core/defs/IGeoPoint\";\r\nimport { DataSource } from \"../../core/data/DataSource\";\r\nimport { Projection } from \"../map/projections/Projection\";\r\nimport { ZoomControl } from \"../map/ZoomControl\";\r\nimport { Ordering } from \"../../core/utils/Order\";\r\nimport { Circle } from \"../../core/elements/Circle\";\r\nimport { SmallMap } from \"../map/SmallMap\";\r\nimport * as $mapUtils from \"../map/MapUtils\";\r\nimport { Animation } from \"../../core/utils/Animation\";\r\nimport { keyboard } from \"../../core/utils/Keyboard\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport * as $utils from \"../../core/utils/Utils\";\r\nimport * as $ease from \"../../core/utils/Ease\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $geo from \"../map/Geo\";\r\nimport { Paper } from \"../../core/rendering/Paper\";\r\nimport { IListEvents } from \"../../core/utils/List\";\r\nimport { GraticuleSeries } from \"../map/GraticuleSeries\";\r\nimport { getInteraction, IInteractionEvents } from \"../../core/interaction/Interaction\";\r\nimport { Legend } from \"../Legend\";\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines a [[DataItem]] for [[MapChart]].\r\n *\r\n * @see {@link DataItem}\r\n */\r\nexport class MapChartDataItem extends SerialChartDataItem {\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for.\r\n\t */\r\n\tpublic _component!: MapChart;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"MapChartDataItem\";\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines interface for a map polygon object.\r\n */\r\nexport interface IMapPolygonDataObject {\r\n\r\n\t/**\r\n\t * A unique id of the object.\r\n\t */\r\n\tid?: string;\r\n\r\n\t/**\r\n\t * Numeric value for heat-map scenarios.\r\n\t */\r\n\tvalue?: number;\r\n\r\n\t/**\r\n\t * Single polygon information in X/Y coordinates.\r\n\t */\r\n\tpolygon?: Array<Array<[number, number]>>;\r\n\r\n\t/**\r\n\t * Multi-part polygon information in X/Y coordinates.\r\n\t */\r\n\tmultiPolygon?: Array<Array<Array<[number, number]>>>;\r\n\r\n\t/**\r\n\t * Single polygon information in lat/long geo-coordinates.\r\n\t */\r\n\tgeoPolygon?: Array<Array<IGeoPoint>>;\r\n\r\n\t/**\r\n\t * Multi-part polygon information in lat/long geo-coordinates.\r\n\t */\r\n\tmultiGeoPolygon?: Array<Array<Array<IGeoPoint>>>;\r\n\r\n\t/**\r\n\t * flag indicating whether this data item was created from geo data\r\n\t */\r\n\tmadeFromGeoData?: boolean;\r\n}\r\n\r\n/**\r\n * Defines types of map line.\r\n */\r\nexport type MapLineType = \"line\" | \"arc\" | \"spline\" | \"realTrajectory\";\r\n\r\n/**\r\n * Defines interface for the map line object.\r\n */\r\nexport interface IMapLineDataObject {\r\n\r\n\t/**\r\n\t * A unique id of the object.\r\n\t */\r\n\tid?: string;\r\n\r\n\t/**\r\n\t * Numeric value for heat-map scenarios.\r\n\t */\r\n\tvalue?: number;\r\n\r\n\t/**\r\n\t * Single line information in X/Y coordinates.\r\n\t */\r\n\tline?: Array<[number, number]>;\r\n\r\n\t/**\r\n\t * Multi-part line information in X/Y coordinates.\r\n\t */\r\n\tmultiLine?: Array<Array<[number, number]>>;\r\n\r\n\t/**\r\n\t * Single line information in lat/long geo-coordinates.\r\n\t */\r\n\tgeoLine?: Array<IGeoPoint>;\r\n\r\n\t/**\r\n\t * Multi-part line information in lat/long geo-coordinates.\r\n\t */\r\n\tmultiGeoLine?: Array<Array<IGeoPoint>>;\r\n\r\n\t/**\r\n\t * flag indicating whether this data item was created from geo data\r\n\t */\r\n\tmadeFromGeoData?: boolean;\r\n\r\n}\r\n\r\n/**\r\n * Defines interface for a map image (market) object.\r\n */\r\nexport interface IMapImageDataObject {\r\n\r\n\t/**\r\n\t * A unique id of the object.\r\n\t */\r\n\tid?: string;\r\n\r\n\t/**\r\n\t * Numeric value for heat-map scenarios.\r\n\t */\r\n\tvalue?: number;\r\n\r\n\t/**\r\n\t * Image position information in X/Y coordinates.\r\n\t */\r\n\tpoint?: [number, number];\r\n\r\n\t/**\r\n\t * Multi-image position information in X/Y coordinates.\r\n\t */\r\n\tmultiPoint?: Array<[number, number]>;\r\n\r\n\t/**\r\n\t * Image position information in lat/long geo-coordinates.\r\n\t */\r\n\tgeoPoint?: IGeoPoint;\r\n\r\n\t/**\r\n\t * Multi-image position information in lat/long geo-coordinates.\r\n\t */\r\n\tmultiGeoPoint?: Array<IGeoPoint>;\r\n\r\n\r\n\t/**\r\n\t * flag indicating whether this data item was created from geo data\r\n\t */\r\n\tmadeFromGeoData?: boolean;\r\n}\r\n\r\n/**\r\n * Defines type suitable for all map objects.\r\n */\r\nexport type IMapDataObject = IMapPolygonDataObject | IMapLineDataObject;\r\n\r\n/**\r\n * Defines data fields for [[MapChart]].\r\n */\r\nexport interface IMapChartDataFields extends ISerialChartDataFields { }\r\n\r\n/**\r\n * Defines properties for [[MapChart]].\r\n */\r\nexport interface IMapChartProperties extends ISerialChartProperties {\r\n\r\n\t/**\r\n\t * Projection to be used when drawing the map.\r\n\t */\r\n\tprojection?: Projection;\r\n\r\n\t/**\r\n\t * Degrees to rotate the map around vertical axis (Y).\r\n\t *\r\n\t * E.g. if set to -160, the longitude 20 will become a new center, creating\r\n\t * a Pacific-centered map.\r\n\t */\r\n\tdeltaLongitude?: number;\r\n\r\n\t/**\r\n\t * Degrees to rotate the map around horizontal axis (X).\r\n\t *\r\n\t * E.g. setting this to -90 will put Antarctica directly in the center of\r\n\t * the map.\r\n\t *\r\n\t * @since 4.3.0\r\n\t */\r\n\tdeltaLatitude?: number;\r\n\r\n\t/**\r\n\t * Degrees to rotate the map around horizontal \"Z\" - an axis that goes from\r\n\t * the center of the globe directly to the viewer.\r\n\t *\r\n\t * @since 4.3.0\r\n\t */\r\n\tdeltaGamma?: number;\r\n\r\n\t/**\r\n\t * Maximum portion of the map's width/height to allow panning \"off screen\".\r\n\t *\r\n\t * A value of 0 (zero) will prevent any portion of the the map to be panned\r\n\t * outside the viewport.\r\n\t *\r\n\t * 0.5 will allow half of the map to be outside viewable area.\r\n\t *\r\n\t * @default 0.7\r\n\t */\r\n\tmaxPanOut?: number;\r\n\r\n\t/**\r\n\t * A map will start centered on this geographical point.\r\n\t */\r\n\thomeGeoPoint?: IGeoPoint;\r\n\r\n\t/**\r\n\t * A map will start zoomed to this level.\r\n\t */\r\n\thomeZoomLevel?: number;\r\n\r\n\t/**\r\n\t * When user zooms in or out current zoom level is multiplied or divided\r\n\t * by value of this setting.\r\n\t *\r\n\t * @default 2\r\n\t */\r\n\tzoomStep?: number;\r\n\r\n\t/**\r\n\t * Specifies what should chart do if when mouse wheel is rotated.\r\n\t */\r\n\tmouseWheelBehavior?: \"zoom\" | \"none\";\r\n\r\n\t/**\r\n\t * What \"dragging\" map does.\r\n\t *\r\n\t * Available values:\r\n\t * * `\"move\"` (default): changes position of the map.\r\n\t * * `\"rotateLat\"`: changes `deltaLatitude` (rotates the globe vertically).\r\n\t * * `\"rotateLong\"`: changes `deltaLongitude` (rotates the globe horizontally).\r\n\t * * `\"rotateLongLat\"`: changes both `deltaLongitude` and `deltaLatitude` (rotates the globe in any direction).\r\n\t *\r\n\t * @default \"move\"\r\n\t * @since 4.3.0\r\n\t */\r\n\tpanBehavior?: \"move\" | \"rotateLat\" | \"rotateLong\" | \"rotateLongLat\";\r\n\r\n\r\n\t/**\r\n\t * Specifies if the map should be centered when zooming out\r\n\t * @default true\r\n\t * @since 4.7.12\r\n\t */\r\n\tcenterMapOnZoomOut?: boolean;\r\n}\r\n\r\n/**\r\n * Defines events for [[MapChart]].\r\n */\r\nexport interface IMapChartEvents extends ISerialChartEvents {\r\n\r\n\t/**\r\n\t * Invoked when map is zoomed in or out.\r\n\t */\r\n\tzoomlevelchanged: {};\r\n\r\n\t/**\r\n\t * Invoked when map is panned. (moved)\r\n\t */\r\n\tmappositionchanged: {};\r\n\r\n\t/**\r\n\t * Invoked when scale ratio is changed, e.g when the whole map area is\r\n\t * resized and the map needs to be resized to fit it, without changing\r\n\t * zoom level.\r\n\t */\r\n\tscaleratiochanged: {};\r\n\r\n}\r\n\r\n/**\r\n * Defines adapters for [[MapChart]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IMapChartAdapters extends ISerialChartAdapters, IMapChartProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Creates a map.\r\n *\r\n * @see {@link IMapChartEvents} for a list of available Events\r\n * @see {@link IMapChartAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/chart-types/map/} for documentation\r\n */\r\nexport class MapChart extends SerialChart {\r\n\r\n\t/**\r\n\t * Available data fields.\r\n\t */\r\n\tpublic _dataFields: IMapChartDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IMapChartProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IMapChartAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IMapChartEvents;\r\n\r\n\t/**\r\n\t * The East-most longitude point of the map.\r\n\t */\r\n\tpublic east: number;\r\n\r\n\t/**\r\n\t * The West-most longitude point of the map.\r\n\t */\r\n\tpublic west: number;\r\n\r\n\t/**\r\n\t * The South-most latitude point of the map.\r\n\t */\r\n\tpublic south: number;\r\n\r\n\t/**\r\n\t * The North-most latitude point of the map.\r\n\t */\r\n\tpublic north: number;\r\n\r\n\t/**\r\n\t * A ratio to be used when scaling the map shapes.\r\n\t *\r\n\t * @readonly\r\n\t */\r\n\tpublic scaleRatio: number = 1;\r\n\r\n\t/**\r\n\t * A screen point of the map's center.\r\n\t *\r\n\t * @readonly\r\n\t */\r\n\tpublic centerPoint: IPoint;\r\n\r\n\t/**\r\n\t * A screen point of the map's left.\r\n\t *\r\n\t * @readonly\r\n\t */\r\n\tpublic westPoint: IPoint;\r\n\r\n\t/**\r\n\t * A screen point of the map's right.\r\n\t *\r\n\t * @readonly\r\n\t */\r\n\tpublic eastPoint: IPoint;\r\n\r\n\t/**\r\n\t * A screen point of the map's top.\r\n\t *\r\n\t * @readonly\r\n\t */\r\n\tpublic northPoint: IPoint;\r\n\r\n\t/**\r\n\t * A screen point of the map's bottom.\r\n\t *\r\n\t * @readonly\r\n\t */\r\n\tpublic southPoint: IPoint;\r\n\r\n\t/**\r\n\t * Width of the actual map objects (px).\r\n\t */\r\n\tpublic seriesWidth: number;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic seriesMaxLeft: number;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic seriesMaxRight: number;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic seriesMaxTop: number;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic seriesMaxBottom: number;\r\n\r\n\t/**\r\n\t * Height of the actual map objects (px).\r\n\t */\r\n\tpublic seriesHeight: number;\r\n\r\n\t/**\r\n\t * Map data in GeoJSON format.\r\n\t *\r\n\t * @see {@link http://geojson.org/} GeoJSON official specification\r\n\t */\r\n\tprotected _geodata: Object;\r\n\r\n\t/**\r\n\t * Names of geodata items, such as countries, to replace by from loaded\r\n\t * geodata.\r\n\t *\r\n\t * Can be used to override built-in English names for countries.\r\n\t *\r\n\t * ```TypeScript\r\n\t * import am4geodata_lang_ES from '@amcharts4-geodata/lang/es';\r\n\t * // ...\r\n\t * map.geodataNames = am4geodata_lang_ES;\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * map.geodataNames = am4geodata_lang_ES;\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"geodataNames\": am4geodata_lang_ES\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * @since 4.7.4\r\n\t */\r\n\tpublic geodataNames: { [index: string]: string };\r\n\r\n\t/**\r\n\t * A reference to a [[ZoomControl]] instance.\r\n\t */\r\n\tprotected _zoomControl: ZoomControl;\r\n\r\n\t/**\r\n\t * A reference to a [[SmallMap]] control instance.\r\n\t */\r\n\tprotected _smallMap: SmallMap;\r\n\r\n\t/**\r\n\t * [_zoomGeoPoint description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _zoomGeoPoint: IGeoPoint;\r\n\r\n\t/**\r\n\t * Default duration of zoom animations (ms).\r\n\t */\r\n\tpublic zoomDuration: number = 1000;\r\n\r\n\t/**\r\n\t * Default zooming animation easing function.\r\n\t */\r\n\tpublic zoomEasing: (value: number) => number = $ease.cubicOut;\r\n\r\n\t/**\r\n\t * Smallest available zoom level. The map will not allow to zoom out past\r\n\t * this setting.\r\n\t *\r\n\t * NOTE: Should be power of 2.\r\n\t *\r\n\t * @default 1\r\n\t */\r\n\tpublic minZoomLevel: number = 1;\r\n\r\n\t/**\r\n\t * Biggest available zoom level. The map will not allow to zoom in past\r\n\t * this setting.\r\n\t *\r\n\t * NOTE: Should be power of 2.\r\n\t *\r\n\t * @default 32\r\n\t */\r\n\tpublic maxZoomLevel: number = 32;\r\n\r\n\t/**\r\n\t * [_prevZoomLevel description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _prevZoomLevel: number;\r\n\r\n\t/**\r\n\t * [_prevZoomGeoPoint description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _prevZoomGeoPoint: IGeoPoint = { latitude: 0, longitude: 0 };\r\n\r\n\t/**\r\n\t * Defines a type of series that this chart uses.\r\n\t */\r\n\tpublic _seriesType: MapSeries;\r\n\r\n\t/**\r\n\t * A reference to currently playing animation, e.g. zooming.\r\n\t */\r\n\tprotected _mapAnimation: Animation;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected _mouseWheelDisposer: IDisposer;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic _zoomGeoPointReal: IGeoPoint;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected _centerGeoPoint: IGeoPoint;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected _fitWidth: number;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected _fitHeight: number;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\r\n\tpublic panSprite: Circle;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected _downPointOrig: IPoint;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected _downDeltaLongitude: number;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected _downDeltaLatitude: number;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected _backgroundSeries: MapPolygonSeries;\r\n\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"MapChart\";\r\n\r\n\t\t// Set default projection\r\n\t\tthis.projection = new Projection();\r\n\r\n\t\tthis.setPropertyValue(\"deltaLatitude\", 0);\r\n\t\tthis.setPropertyValue(\"deltaLongitude\", 0);\r\n\t\tthis.setPropertyValue(\"deltaGamma\", 0);\r\n\t\tthis.maxPanOut = 0.7;\r\n\t\tthis.homeZoomLevel = 1;\r\n\t\tthis.zoomStep = 2;\r\n\t\tthis.layout = \"absolute\";\r\n\r\n\t\tthis.centerMapOnZoomOut = true;\r\n\r\n\t\t// Set padding\r\n\t\tthis.padding(0, 0, 0, 0);\r\n\r\n\t\t$utils.used(this.backgroundSeries);\r\n\r\n\t\t// so that the map would render in a hidden div too\r\n\t\tthis.minWidth = 10;\r\n\t\tthis.minHeight = 10;\r\n\r\n\t\tthis.events.once(\"inited\", this.handleAllInited, this, false);\r\n\r\n\t\t// Create a container for map series\r\n\t\tlet seriesContainer = this.seriesContainer;\r\n\t\tseriesContainer.visible = false;\r\n\t\tseriesContainer.inert = true;\r\n\t\tseriesContainer.resizable = true;\r\n\t\tseriesContainer.events.on(\"transformed\", this.handleMapTransform, this, false);\r\n\t\tseriesContainer.events.on(\"doublehit\", this.handleDoubleHit, this, false);\r\n\t\tseriesContainer.events.on(\"dragged\", this.handleDrag, this, false);\r\n\t\tseriesContainer.zIndex = 0;\r\n\t\tseriesContainer.dragWhileResize = true;\r\n\t\t//seriesContainer.background.fillOpacity = 0;\r\n\r\n\t\tseriesContainer.adapter.add(\"scale\", (scale, target) => {\r\n\t\t\treturn $math.fitToRange(scale, this.minZoomLevel, this.maxZoomLevel);\r\n\t\t});\r\n\r\n\t\t// Set up events\r\n\t\t//this.events.on(\"validated\", this.updateExtremes, this);\r\n\t\t//this.events.on(\"datavalidated\", this.handleAllValidated, this, false);\r\n\t\t//this.events.on(\"datavalidated\", this.updateExtremes, this, false);\r\n\r\n\t\tthis.events.on(\"maxsizechanged\", (event) => {\r\n\t\t\tif (event.previousWidth == 0 || event.previousHeight == 0) {\r\n\t\t\t\tthis.updateExtremes();\r\n\t\t\t\tthis.updateCenterGeoPoint();\r\n\t\t\t}\r\n\t\t}, undefined, false)\r\n\r\n\t\t// Set up main chart container, e.g. set backgrounds and events to monitor\r\n\t\t// size changes, etc.\r\n\t\tlet chartContainer = this.chartContainer;\r\n\t\tchartContainer.parent = this;\r\n\t\tchartContainer.zIndex = -1;\r\n\r\n\t\tthis._disposers.push(this.events.on(\"maxsizechanged\", () => {\r\n\t\t\tif (this.inited) {\r\n\t\t\t\tif (this._mapAnimation) {\r\n\t\t\t\t\tthis._mapAnimation.stop();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet allInited = true;\r\n\t\t\t\tthis.series.each((series) => {\r\n\t\t\t\t\tseries.updateTooltipBounds();\r\n\t\t\t\t\tif (!series.inited || series.dataInvalid) {\r\n\t\t\t\t\t\tallInited = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t\tif (allInited) {\r\n\t\t\t\t\tthis.updateScaleRatio();\r\n\t\t\t\t}\r\n\t\t\t\tthis.zoomToGeoPoint(this._zoomGeoPointReal, this.zoomLevel, true, 0);\r\n\t\t\t}\r\n\r\n\t\t}, undefined, false));\r\n\r\n\t\tlet chartContainerBg = chartContainer.background;\r\n\t\tchartContainerBg.fillOpacity = 0;\r\n\t\tchartContainerBg.events.on(\"down\", (e) => { this.seriesContainer.dragStart(e.target.interactions.downPointers.getIndex(0)); }, this);\r\n\t\tchartContainerBg.events.on(\"up\", (e) => { this.seriesContainer.dragStop() }, this);\r\n\t\tchartContainerBg.events.on(\"doublehit\", this.handleDoubleHit, this);\r\n\t\tchartContainerBg.focusable = true;\r\n\r\n\t\tchartContainer.events.on(\"down\", this.handleMapDown, this, false);\r\n\r\n\t\tthis.addDisposer(seriesContainer.events.on(\"down\", () => {\r\n\t\t\t// Cancel any move inertia if there is one\r\n\t\t\tconst inertia = this.seriesContainer.interactions.inertias.getKey(\"move\");\r\n\t\t\tif (inertia) {\r\n\t\t\t\tinertia.done();\r\n\t\t\t}\r\n\t\t}))\t\t\r\n\r\n\t\t// Add description to background\r\n\t\tthis.background.fillOpacity = 0;\r\n\r\n\t\t// Add keyboard events for panning\r\n\t\tthis._disposers.push(getInteraction().body.events.on(\"keyup\", (ev) => {\r\n\t\t\tif (this.topParent.hasFocused) {\r\n\t\t\t\tconst key = keyboard.getEventKey(ev.event);\r\n\t\t\t\tif (!this._zoomControl || !this._zoomControl.thumb.isFocused) {\r\n\t\t\t\t\tswitch (key) {\r\n\t\t\t\t\t\tcase \"up\":\r\n\t\t\t\t\t\t\tthis.pan({ x: 0, y: 0.1 });\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"down\":\r\n\t\t\t\t\t\t\tthis.pan({ x: 0, y: -0.1 });\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"left\":\r\n\t\t\t\t\t\t\tthis.pan({ x: 0.1, y: 0 });\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase \"right\":\r\n\t\t\t\t\t\t\tthis.pan({ x: -0.1, y: 0 });\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}, this));\r\n\r\n\t\tthis.mouseWheelBehavior = \"zoom\";\r\n\r\n\t\tconst interaction = getInteraction();\r\n\t\tthis._disposers.push(interaction.body.events.on(\"down\", this.handlePanDown, this));\r\n\t\tthis._disposers.push(interaction.body.events.on(\"up\", this.handlePanUp, this));\r\n\t\t//this._disposers.push(interaction.body.events.on(\"track\", this.handlePanMove, this));\r\n\r\n\t\tlet panSprite = this.seriesContainer.createChild(Circle);\r\n\t\tpanSprite.radius = 10;\r\n\t\tpanSprite.inert = true;\r\n\t\tpanSprite.isMeasured = false;\r\n\t\tpanSprite.events.on(\"transformed\", this.handlePanMove, this, false);\r\n\t\tpanSprite.interactionsEnabled = false;\r\n\t\tpanSprite.opacity = 0;\r\n\t\tpanSprite.x = 0;\r\n\t\tpanSprite.y = 0;\r\n\t\tthis.panSprite = panSprite;\r\n\t\tthis.panBehavior = \"move\";\r\n\t\t/*\r\n\t\t\t\tthis.panSprite.inertiaOptions.setKey(\"move\", {\r\n\t\t\t\t\t\"time\": 100,\r\n\t\t\t\t\t\"duration\": 1000,\r\n\t\t\t\t\t\"factor\": 3,\r\n\t\t\t\t\t\"easing\": $ease.sinOut\r\n\t\t\t\t});*/\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected handlePanDown(event: IInteractionEvents[\"down\"]): void {\r\n\t\tlet svgPoint = $utils.documentPointToSvg(event.pointer.point, this.htmlContainer);\r\n\t\tif (svgPoint.x > 0 && svgPoint.y > 0 && svgPoint.x < this.svgContainer.width && svgPoint.y < this.svgContainer.height) {\r\n\t\t\t// Get local point\r\n\t\t\tthis._downPointOrig = $utils.documentPointToSprite(event.pointer.point, this.seriesContainer);\r\n\r\n\t\t\tthis.panSprite.moveTo(this._downPointOrig);\r\n\t\t\tthis.panSprite.dragStart(event.pointer);\r\n\t\t\tthis._downDeltaLongitude = this.deltaLongitude;\r\n\t\t\tthis._downDeltaLatitude = this.deltaLatitude;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected handlePanUp(event: IInteractionEvents[\"down\"]): void {\r\n\t\tif (this._downPointOrig) {\r\n\t\t\tthis.panSprite.dragStop(event.pointer, true);\r\n\t\t}\r\n\t\tthis._downPointOrig = undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected handlePanMove(): void {\r\n\r\n\t\tif (!this.seriesContainer.isResized) {\r\n\r\n\t\t\tif (getInteraction().areTransformed([this.panSprite.interactions, this.seriesContainer.interactions])) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tlet d3Projection = this.projection.d3Projection;\r\n\r\n\t\t\tlet panBehavior = this.panBehavior;\r\n\r\n\t\t\tif (panBehavior != \"move\" && panBehavior != \"none\" && this._downPointOrig && d3Projection.rotate) {\r\n\r\n\t\t\t\tlet rotation = d3Projection.rotate();\r\n\r\n\t\t\t\tlet dln = rotation[0];\r\n\t\t\t\tlet dlt = rotation[1];\r\n\t\t\t\tlet dlg = rotation[2];\r\n\r\n\t\t\t\td3Projection.rotate([0, 0, 0]);\r\n\r\n\t\t\t\tlet downGeoLocal = this.projection.invert(this._downPointOrig);\r\n\r\n\t\t\t\tlet local: IPoint = { x: this.panSprite.pixelX, y: this.panSprite.pixelY };\r\n\t\t\t\tlet geoLocal: IGeoPoint;\r\n\t\t\t\tif (local) {\r\n\t\t\t\t\tgeoLocal = this.projection.invert(local);\r\n\t\t\t\t}\r\n\r\n\t\t\t\td3Projection.rotate([dln, dlt, dlg]);\r\n\t\t\t\tif (geoLocal) {\r\n\t\t\t\t\tif (panBehavior == \"rotateLat\" || panBehavior == \"rotateLongLat\") {\r\n\t\t\t\t\t\tthis.deltaLatitude = this._downDeltaLatitude + geoLocal.latitude - downGeoLocal.latitude;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (panBehavior == \"rotateLong\" || panBehavior == \"rotateLongLat\") {\r\n\t\t\t\t\t\tthis.deltaLongitude = this._downDeltaLongitude + geoLocal.longitude - downGeoLocal.longitude;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected handleAllInited() {\r\n\t\tlet inited = true;\r\n\t\tthis.seriesContainer.visible = true;\r\n\t\tthis.series.each((series) => {\r\n\t\t\tif (!series.inited || series.dataInvalid) {\r\n\t\t\t\tinited = false;\r\n\t\t\t}\r\n\t\t})\r\n\t\tif (inited) {\r\n\t\t\tthis.updateCenterGeoPoint();\r\n\t\t\tthis.updateScaleRatio();\r\n\t\t\tthis.goHome(0);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// TODO verify that this is correct\r\n\t\t\tconst disposer = registry.events.once(\"exitframe\", () => {\r\n\t\t\t\tthis.removeDispose(disposer);\r\n\t\t\t\tthis.handleAllInited();\r\n\t\t\t}, this, false);\r\n\r\n\t\t\tthis.addDisposer(disposer);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic updateZoomGeoPoint() {\r\n\t\tlet seriesPoint = $utils.svgPointToSprite({ x: this.innerWidth / 2 + this.pixelPaddingLeft, y: this.innerHeight / 2 + this.pixelPaddingTop }, this.series.getIndex(0));\r\n\t\tlet geoPoint = this.projection.invert(seriesPoint);\r\n\t\tthis._zoomGeoPointReal = geoPoint;\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic updateCenterGeoPoint() {\r\n\t\tlet maxLeft: number;\r\n\t\tlet maxRight: number;\r\n\t\tlet maxTop: number;\r\n\t\tlet maxBottom: number;\r\n\r\n\r\n\t\tif (this.backgroundSeries) {\r\n\t\t\tlet features = this.backgroundSeries.getFeatures();\r\n\t\t\tif (features.length > 0) {\r\n\t\t\t\tlet bounds = this.projection.d3Path.bounds(<any>features[0].geometry);\r\n\t\t\t\tmaxLeft = bounds[0][0];\r\n\t\t\t\tmaxTop = bounds[0][1];\r\n\t\t\t\tmaxRight = bounds[1][0];\r\n\t\t\t\tmaxBottom = bounds[1][1];\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.series.each((series) => {\r\n\t\t\t\tlet bbox = series.group.node.getBBox();\r\n\r\n\t\t\t\tif (maxLeft > bbox.x || !$type.isNumber(maxLeft)) {\r\n\t\t\t\t\tmaxLeft = bbox.x;\r\n\t\t\t\t}\r\n\t\t\t\tif (maxRight < bbox.x + bbox.width || !$type.isNumber(maxRight)) {\r\n\t\t\t\t\tmaxRight = bbox.x + bbox.width;\r\n\t\t\t\t}\r\n\t\t\t\tif (maxTop > bbox.y || !$type.isNumber(maxTop)) {\r\n\t\t\t\t\tmaxTop = bbox.y;\r\n\t\t\t\t}\r\n\t\t\t\tif (maxBottom < bbox.y + bbox.height || !$type.isNumber(maxBottom)) {\r\n\t\t\t\t\tmaxBottom = bbox.y + bbox.height;\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tthis.seriesMaxLeft = maxLeft;\r\n\t\tthis.seriesMaxRight = maxRight;\r\n\t\tthis.seriesMaxTop = maxTop;\r\n\t\tthis.seriesMaxBottom = maxBottom;\r\n\r\n\t\tthis.seriesWidth = maxRight - maxLeft;\r\n\t\tthis.seriesHeight = maxBottom - maxTop;\r\n\r\n\t\tif (this.seriesWidth > 0 && this.seriesHeight > 0) {\r\n\t\t\tthis.chartContainer.visible = true;\r\n\t\t\tthis._centerGeoPoint = this.projection.invert({ x: maxLeft + (maxRight - maxLeft) / 2, y: maxTop + (maxBottom - maxTop) / 2 });\r\n\r\n\t\t\tif (!this._zoomGeoPointReal || !$type.isNumber(this._zoomGeoPointReal.latitude)) {\r\n\t\t\t\tthis._zoomGeoPointReal = this._centerGeoPoint;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.chartContainer.visible = false;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Prevents map to be dragged out of the container area\r\n\t * @ignore\r\n\t */\r\n\tprotected handleDrag() {\r\n\r\n\t\tlet d = this.zoomLevel * this.scaleRatio;\r\n\r\n\t\tlet ww = this.seriesWidth * d;\r\n\t\tlet hh = this.seriesHeight * d;\r\n\r\n\t\tlet seriesContainer = this.seriesContainer;\r\n\t\tlet maxLeft = this.seriesMaxLeft * d;\r\n\t\tlet maxRight = this.seriesMaxRight * d;\r\n\t\tlet maxTop = this.seriesMaxTop * d;\r\n\t\tlet maxBottom = this.seriesMaxBottom * d;\r\n\r\n\t\tlet x = seriesContainer.pixelX;\r\n\t\tlet y = seriesContainer.pixelY;\r\n\r\n\t\tlet maxPanOut = this.maxPanOut;\r\n\r\n\t\tlet minX = Math.min(this.maxWidth * (1 - maxPanOut) - ww - maxLeft, -maxLeft);\r\n\t\tif (x < minX) {\r\n\t\t\tx = minX;\r\n\t\t}\r\n\r\n\t\tlet maxX = Math.max(this.maxWidth * maxPanOut - maxLeft, this.maxWidth - maxRight);\r\n\t\tif (x > maxX) {\r\n\t\t\tx = maxX;\r\n\t\t}\r\n\r\n\t\tlet minY = Math.min(this.maxHeight * (1 - maxPanOut) - hh - maxTop, -maxTop)\r\n\t\tif (y < minY) {\r\n\t\t\ty = minY;\r\n\t\t}\r\n\r\n\t\tlet maxY = Math.max(this.maxHeight * maxPanOut - maxTop, this.maxHeight - maxBottom);\r\n\t\tif (y > maxY) {\r\n\t\t\ty = maxY;\r\n\t\t}\r\n\r\n\t\tseriesContainer.moveTo({ x: x, y: y }, undefined, undefined, true);\r\n\r\n\t\tthis._zoomGeoPointReal = this.zoomGeoPoint;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets defaults that instantiate some objects that rely on parent, so they\r\n\t * cannot be set in constructor.\r\n\t */\r\n\tprotected applyInternalDefaults(): void {\r\n\r\n\t\tsuper.applyInternalDefaults();\r\n\r\n\t\t// Add a default screen reader title for accessibility\r\n\t\t// This will be overridden in screen reader if there are any `titles` set\r\n\t\tif (!$type.hasValue(this.readerTitle)) {\r\n\t\t\tthis.readerTitle = this.language.translate(\"Map\");\r\n\t\t}\r\n\r\n\t\tif (!$type.hasValue(this.background.readerTitle)) {\r\n\t\t\tthis.background.readerTitle = this.language.translate(\"Use plus and minus keys on your keyboard to zoom in and out\");\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Handles event when a pointer presses down on the map, e.g. user presses\r\n\t * down mouse or touches the map on a screen.\r\n\t *\r\n\t * Stops all animations currently going on.\r\n\t */\r\n\tprotected handleMapDown(): void {\r\n\t\tif (this._mapAnimation) {\r\n\t\t\tthis._mapAnimation.stop();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Handles the event when user doubleclicks or dooubletaps the map: zooms\r\n\t * in on the reference point.\r\n\t *\r\n\t * @param event  Original event\r\n\t */\r\n\tprotected handleDoubleHit(event: AMEvent<Sprite, ISpriteEvents>[\"doublehit\"]) {\r\n\t\tlet svgPoint: IPoint = $utils.documentPointToSvg(event.point, this.htmlContainer, this.svgContainer.cssScale);\r\n\t\tlet geoPoint: IGeoPoint = this.svgPointToGeo(svgPoint);\r\n\t\tthis.zoomIn(geoPoint);\r\n\t}\r\n\r\n\t/**\r\n\t * Handles mouse wheel event, e.g. user rotates mouse wheel while over the\r\n\t * map: zooms in or out depending on the direction of the wheel turn.\r\n\t *\r\n\t * @param event  Original event\r\n\t */\r\n\tprotected handleWheel(event: AMEvent<Sprite, ISpriteEvents>[\"wheel\"]) {\r\n\r\n\t\t// Cancel any move inertia if there is one\r\n\t\tconst inertia = this.seriesContainer.interactions.inertias.getKey(\"move\");\r\n\t\tif (inertia) {\r\n\t\t\tinertia.done();\r\n\t\t}\r\n\r\n\t\tlet svgPoint: IPoint = $utils.documentPointToSvg(event.point, this.htmlContainer, this.svgContainer.cssScale);\r\n\t\tlet geoPoint: IGeoPoint = this.svgPointToGeo(svgPoint);\r\n\r\n\t\tif (event.shift.y < 0) {\r\n\t\t\tthis.zoomIn(geoPoint, undefined, this.interactions.mouseOptions.sensitivity);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.zoomOut(geoPoint, undefined, this.interactions.mouseOptions.sensitivity);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Specifies what should chart do if when mouse wheel is rotated.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/reference/sprite/#mouseOptions_property} More information about `mouseOptions`\r\n\t * @param mouse wheel behavior\r\n\t * @default zoomX\r\n\t */\r\n\tpublic set mouseWheelBehavior(value: \"zoom\" | \"none\") {\r\n\r\n\t\tif (this.setPropertyValue(\"mouseWheelBehavior\", value)) {\r\n\t\t\tif (value != \"none\") {\r\n\t\t\t\tthis._mouseWheelDisposer = this.chartContainer.events.on(\"wheel\", this.handleWheel, this, false);\r\n\t\t\t\tthis._disposers.push(this._mouseWheelDisposer);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (this._mouseWheelDisposer) {\r\n\t\t\t\t\tthis._mouseWheelDisposer.dispose();\r\n\t\t\t\t}\r\n\t\t\t\tthis.chartContainer.wheelable = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return mouse wheel behavior\r\n\t */\r\n\tpublic get mouseWheelBehavior(): \"zoom\" | \"none\" {\r\n\t\treturn this.getPropertyValue(\"mouseWheelBehavior\");\r\n\t}\r\n\r\n\t/**\r\n\t * What \"dragging\" map does.\r\n\t *\r\n\t * Available values:\r\n\t * * `\"move\"` (default): changes position of the map.\r\n\t * * `\"rotateLat\"`: changes `deltaLatitude` (rotates the globe vertically).\r\n\t * * `\"rotateLong\"`: changes `deltaLongitude` (rotates the globe horizontally).\r\n\t * * `\"rotateLongLat\"`: changes both `deltaLongitude` and `deltaLatitude` (rotates the globe in any direction).\r\n\t *\r\n\t * @default \"move\"\r\n\t * @since 4.3.0\r\n\t * @param  value  Behavior\r\n\t */\r\n\tpublic set panBehavior(value: \"none\" | \"move\" | \"rotateLat\" | \"rotateLong\" | \"rotateLongLat\") {\r\n\t\tif (this.setPropertyValue(\"panBehavior\", value)) {\r\n\t\t\tlet seriesContainer = this.seriesContainer;\r\n\t\t\tthis.panSprite.draggable = false;\r\n\t\t\tseriesContainer.draggable = false;\r\n\r\n\t\t\tswitch (value) {\r\n\t\t\t\tcase \"move\":\r\n\t\t\t\t\tseriesContainer.draggable = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthis.panSprite.draggable = true;\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @returns If the map should be centered when zooming out.\r\n\t */\r\n\tpublic get centerMapOnZoomOut(): boolean {\r\n\t\treturn this.getPropertyValue(\"centerMapOnZoomOut\");\r\n\t}\r\n\r\n\t/**\r\n\t * Specifies if the map should be centered when zooming out\r\n\t * @default true\r\n\t * @since 4.7.12\r\n\t */\r\n\tpublic set centerMapOnZoomOut(value: boolean) {\r\n\t\tthis.setPropertyValue(\"centerMapOnZoomOut\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @returns Behavior\r\n\t */\r\n\tpublic get panBehavior(): \"none\" | \"move\" | \"rotateLat\" | \"rotateLong\" | \"rotateLongLat\" {\r\n\t\treturn this.getPropertyValue(\"panBehavior\");\r\n\t}\r\n\r\n\t/**\r\n\t * Projection to use for the map.\r\n\t *\r\n\t * Available projections:\r\n\t * * Albers\r\n\t * * AlbersUSA\r\n\t * * AzimuthalEqualArea\r\n\t * * Eckert6\r\n\t * * EqualEarth\r\n\t * * Mercator\r\n\t * * Miller\r\n\t * * NaturalEarth\r\n\t * * Orthographic\r\n\t * * Stereographic\r\n\t *\r\n\t * ```TypeScript\r\n\t * map.projection = new am4maps.projections.Mercator();\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * map.projection = new am4maps.projections.Mercator();\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"projection\": \"Mercator\"\r\n\t *   // ...\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/chart-types/map/#Setting_projection} More about projections\r\n\t * @param projection  Projection\r\n\t */\r\n\tpublic set projection(projection: Projection) {\r\n\t\tif (this.setPropertyValue(\"projection\", projection)) {\r\n\t\t\tthis.invalidateProjection();\r\n\r\n\t\t\tprojection.chart = this;\r\n\r\n\t\t\tif (this._backgroundSeries) {\r\n\t\t\t\tthis._backgroundSeries.invalidate();\r\n\t\t\t}\r\n\r\n\t\t\tif (this.inited) {\r\n\t\t\t\tthis.updateExtremes();\r\n\t\t\t}\r\n\r\n\t\t\tthis.series.each((series) => {\r\n\t\t\t\tseries.events.once(\"validated\", () => {\r\n\t\t\t\t\tthis.updateCenterGeoPoint();\r\n\t\t\t\t\tthis.updateScaleRatio();\r\n\t\t\t\t\tthis.goHome(0);\r\n\t\t\t\t});\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Projection\r\n\t */\r\n\tpublic get projection(): Projection {\r\n\t\treturn this.getPropertyValue(\"projection\");\r\n\t}\r\n\r\n\t/**\r\n\t * Validates (processes) data items.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validateDataItems() {\r\n\t\tsuper.validateDataItems();\r\n\t\tthis.updateExtremes();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Calculates the longitudes and latitudes of the most distant points from\r\n\t * the center in all four directions: West, East, North, and South.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic updateExtremes(): void {\r\n\r\n\t\tlet east: number;\r\n\t\tlet north: number;\r\n\t\tlet west: number;\r\n\t\tlet south: number;\r\n\r\n\t\tthis.series.each((series) => {\r\n\t\t\tif (series.ignoreBounds || (series instanceof GraticuleSeries && series.fitExtent)) {\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (series.north > north || !$type.isNumber(north)) {\r\n\t\t\t\t\tnorth = series.north;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (series.south < south || !$type.isNumber(south)) {\r\n\t\t\t\t\tsouth = series.south;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (series.west < west || !$type.isNumber(west)) {\r\n\t\t\t\t\twest = series.west;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (series.east > east || !$type.isNumber(east)) {\r\n\t\t\t\t\teast = series.east;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\tlet features: any[] = [];\r\n\t\tlet foundGraticule = false;\r\n\t\t// if we gave graticule, get features of these series only for faster fitSize\r\n\t\tthis.series.each((series) => {\r\n\t\t\tif (series instanceof GraticuleSeries && !series.fitExtent) {\r\n\t\t\t\tfeatures = series.getFeatures();\r\n\t\t\t\tfoundGraticule = true;\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\tif (!foundGraticule) {\r\n\t\t\tthis.series.each((series) => {\r\n\t\t\t\tif (series.ignoreBounds || (series instanceof GraticuleSeries && series.fitExtent)) {\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tfeatures = features.concat(series.getFeatures());\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tlet w = $math.max(50, this.innerWidth);\r\n\t\tlet h = $math.max(50, this.innerHeight);\r\n\r\n\t\tlet d3Projection = this.projection.d3Projection;\r\n\r\n\t\tif (features.length > 0 && d3Projection && (this.east != east || this.west != west || this.north != north || this.south != south)) {\r\n\t\t\tthis.east = east;\r\n\t\t\tthis.west = west;\r\n\t\t\tthis.north = north;\r\n\t\t\tthis.south = south;\r\n\t\t\tif (d3Projection.rotate) {\r\n\t\t\t\tlet rotation = d3Projection.rotate();\r\n\t\t\t\tlet deltaLong = rotation[0];\r\n\t\t\t\tlet deltaLat = rotation[1];\r\n\t\t\t\tlet deltaGamma = rotation[2];\r\n\r\n\t\t\t\tthis.deltaLongitude = deltaLong;\r\n\t\t\t\tthis.deltaLatitude = deltaLat;\r\n\t\t\t\tthis.deltaGamma = deltaGamma;\r\n\t\t\t}\r\n\r\n\t\t\tlet geoJSON = { \"type\": \"FeatureCollection\", features: features };\r\n\r\n\t\t\tlet initialScale = d3Projection.scale();\r\n\r\n\t\t\td3Projection.fitSize([w, h], <any>geoJSON);\r\n\r\n\t\t\tif (d3Projection.scale() != initialScale) {\r\n\t\t\t\tthis.invalidateDataUsers();\r\n\t\t\t}\r\n\r\n\t\t\tthis.series.each((series) => {\r\n\t\t\t\tif (series instanceof GraticuleSeries) {\r\n\t\t\t\t\tseries.invalidateData();\r\n\t\t\t\t}\r\n\t\t\t})\r\n\r\n\t\t\tif (this._backgroundSeries) {\r\n\t\t\t\tlet polygon = this._backgroundSeries.mapPolygons.getIndex(0);\r\n\t\t\t\tif (polygon) {\r\n\t\t\t\t\tpolygon.multiPolygon = $mapUtils.getBackground(this.north, this.east, this.south, this.west);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis._fitWidth = w;\r\n\t\t\tthis._fitHeight = h;\r\n\t\t}\r\n\r\n\t\tif (!this._zoomGeoPointReal || !$type.isNumber(this._zoomGeoPointReal.latitude)) {\r\n\t\t\tthis.goHome(0);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * (Re)calculates a ratio which should be used to scale the actual map so\r\n\t * that it fits perfectly into available space. Helps to avoid redrawing of all the map if container size changes\r\n\t * @ignore\r\n\t */\r\n\tprotected updateScaleRatio(): void {\r\n\t\tlet scaleRatio: number;\r\n\r\n\t\tthis.updateCenterGeoPoint();\r\n\r\n\t\tlet hScale: number = this.innerWidth / this.seriesWidth;\r\n\t\tlet vScale: number = this.innerHeight / this.seriesHeight;\r\n\r\n\t\tscaleRatio = $math.min(hScale, vScale);\r\n\r\n\t\tif ($type.isNaN(scaleRatio) || scaleRatio == Infinity) {\r\n\t\t\tscaleRatio = 1;\r\n\t\t}\r\n\r\n\t\tif (scaleRatio != this.scaleRatio) {\r\n\t\t\tthis.scaleRatio = scaleRatio;\r\n\r\n\t\t\t$iter.each(this.series.iterator(), (series) => {\r\n\t\t\t\tseries.scale = scaleRatio;\r\n\t\t\t\tseries.updateTooltipBounds();\r\n\t\t\t});\r\n\r\n\t\t\tthis.backgroundSeries.scale = scaleRatio;\r\n\r\n\t\t\tthis.dispatch(\"scaleratiochanged\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a point within map container to geographical (lat/long)\r\n\t * coordinates.\r\n\t *\r\n\t * @param point  Source point\r\n\t * @return Geo-point\r\n\t */\r\n\tpublic svgPointToGeo(point: IPoint): IGeoPoint {\r\n\t\tlet series: MapSeries = <MapSeries>this.series.getIndex(0);\r\n\t\tif (series) {\r\n\t\t\tlet seriesPoint: IPoint = $utils.svgPointToSprite(point, series);\r\n\t\t\treturn this.seriesPointToGeo(seriesPoint);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts geographical (lat/long) coordinates to an X/Y point within map's\r\n\t * container.\r\n\t *\r\n\t * @param point  Source geo-point\r\n\t * @return Point\r\n\t */\r\n\tpublic geoPointToSVG(point: IGeoPoint): IPoint {\r\n\t\tlet series: MapSeries = <MapSeries>this.series.getIndex(0);\r\n\t\tif (series) {\r\n\t\t\tlet seriesPoint: IPoint = this.geoPointToSeries(point);\r\n\t\t\treturn $utils.spritePointToSvg(seriesPoint, series);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a point (X/Y) within actual objects of the map to geographical\r\n\t * (lat/long) coordinates.\r\n\t *\r\n\t * @param point  Source point\r\n\t * @return Geo-point\r\n\t */\r\n\tpublic seriesPointToGeo(point: IPoint): IGeoPoint {\r\n\t\treturn this.projection.invert(point);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts geographical (lat/long) coordinates to an X/Y point within\r\n\t * actual elements/objects of the maps.\r\n\t *\r\n\t * @param point  Source geo-point\r\n\t * @return Point\r\n\t */\r\n\tpublic geoPointToSeries(point: IGeoPoint): IPoint {\r\n\t\treturn this.projection.convert(point);\r\n\t}\r\n\r\n\t/**\r\n\t * Map data in GeoJSON format.\r\n\t *\r\n\t * The Map supports the following GeoJSON objects: `Point`, `LineString`,\r\n\t * `Polygon`, `MultiPoint`, `MultiLineString`, and `MultiPolygon`.\r\n\t *\r\n\t * @see {@link http://geojson.org/} Official GeoJSON format specification\r\n\t * @param geoJSON GeoJSON data\r\n\t */\r\n\tpublic set geodata(geodata: Object) {\r\n\t\tif (geodata != this._geodata) {\r\n\t\t\tthis._geodata = geodata;\r\n\t\t\tthis.invalidateData();\r\n\r\n\t\t\tthis.dataUsers.each((dataUser) => {\r\n\t\t\t\tfor (let i = dataUser.data.length - 1; i >= 0; i--) {\r\n\t\t\t\t\tif (dataUser.data[i].madeFromGeoData == true) {\r\n\t\t\t\t\t\tdataUser.data.splice(i, 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tdataUser.disposeData();\r\n\t\t\t\tdataUser.invalidateData();\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return GeoJSON data\r\n\t */\r\n\tpublic get geodata(): Object {\r\n\t\treturn this._geodata;\r\n\t}\r\n\r\n\t/**\r\n\t * Zooms the map to particular zoom level and centers on a latitude/longitude\r\n\t * coordinate.\r\n\t *\r\n\t * @param point      Center coordinate\r\n\t * @param zoomLevel  Zoom level\r\n\t * @param center     Center on the given coordinate?\r\n\t * @param duration   Duration for zoom animation (ms)\r\n\t * @return Zoom animation\r\n\t */\r\n\tpublic zoomToGeoPoint(point: IGeoPoint, zoomLevel: number, center?: boolean, duration?: number, mapObject?: boolean): Animation {\r\n\r\n\t\tif (!point) {\r\n\t\t\tlet hasData = false;\r\n\t\t\tthis.series.each((series) => {\r\n\t\t\t\tif (series.dataItems.length > 0) {\r\n\t\t\t\t\thasData = true;\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\tif (hasData) {\r\n\t\t\t\tpoint = this.zoomGeoPoint;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!point || !$type.isNumber(point.longitude) || !$type.isNumber(point.latitude)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._zoomGeoPointReal = point;\r\n\r\n\t\tzoomLevel = $math.fitToRange(zoomLevel, this.minZoomLevel, this.maxZoomLevel);\r\n\r\n\t\tlet seriesPoint: IPoint = this.projection.convert(point);\r\n\t\tif (seriesPoint) {\r\n\r\n\t\t\tlet svgPoint: IPoint = this.geoPointToSVG(point);\r\n\r\n\t\t\tlet mapPoint = $utils.svgPointToSprite(svgPoint, this);\r\n\r\n\t\t\tif (center) {\r\n\t\t\t\tmapPoint = {\r\n\t\t\t\t\tx: this.innerWidth / 2,\r\n\t\t\t\t\ty: this.innerHeight / 2\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tif (!$type.isNumber(duration)) {\r\n\t\t\t\tduration = this.zoomDuration;\r\n\t\t\t}\r\n\r\n\t\t\tlet x = mapPoint.x - seriesPoint.x * zoomLevel * this.scaleRatio;\r\n\t\t\tlet y = mapPoint.y - seriesPoint.y * zoomLevel * this.scaleRatio;\r\n\r\n\r\n\t\t\tif (!mapObject && zoomLevel < this.zoomLevel && this.centerMapOnZoomOut && zoomLevel < 1.5) {\r\n\t\t\t\tx = this.innerWidth / 2 - (this.seriesMaxLeft + (this.seriesMaxRight - this.seriesMaxLeft) / 2) * zoomLevel * this.scaleRatio;\r\n\t\t\t\ty = this.innerHeight / 2 - (this.seriesMaxTop + (this.seriesMaxBottom - this.seriesMaxTop) / 2) * zoomLevel * this.scaleRatio;\r\n\t\t\t}\r\n\r\n\t\t\tthis._mapAnimation = this.seriesContainer.animate(\r\n\t\t\t\t[{\r\n\t\t\t\t\tproperty: \"scale\",\r\n\t\t\t\t\tto: zoomLevel\r\n\t\t\t\t}, {\r\n\t\t\t\t\tproperty: \"x\", from: this.seriesContainer.pixelX,\r\n\t\t\t\t\tto: x\r\n\t\t\t\t}, {\r\n\t\t\t\t\tproperty: \"y\", from: this.seriesContainer.pixelY,\r\n\t\t\t\t\tto: y\r\n\t\t\t\t}], duration, this.zoomEasing);\r\n\r\n\t\t\tthis._disposers.push(this._mapAnimation.events.on(\"animationended\", () => {\r\n\t\t\t\tthis._zoomGeoPointReal = this.zoomGeoPoint;\r\n\t\t\t}))\r\n\r\n\r\n\t\t\tthis.seriesContainer.validatePosition();\r\n\r\n\t\t\treturn this._mapAnimation;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Zooms the map to a particular map object.\r\n\t *\r\n\t * @param mapObject  Target map object\r\n\t * @param zoomLevel  Zoom level\r\n\t * @param center     Center on the given coordinate?\r\n\t * @param duration   Duration for zoom animation (ms)\r\n\t * @return Zoom animation\r\n\t */\r\n\tpublic zoomToMapObject(mapObject: MapObject, zoomLevel?: number, center?: boolean, duration?: number): Animation {\r\n\t\tif (center == undefined) {\r\n\t\t\tcenter = true;\r\n\t\t}\r\n\r\n\t\tconst inertia = this.seriesContainer.interactions.inertias.getKey(\"move\");\r\n\t\tif (inertia) {\r\n\t\t\tinertia.done();\r\n\t\t}\r\n\r\n\t\tif (mapObject instanceof MapImage) {\r\n\t\t\tif ($type.isNaN(zoomLevel)) {\r\n\t\t\t\tzoomLevel = 5;\r\n\t\t\t}\r\n\t\t\treturn this.zoomToGeoPoint({ latitude: mapObject.latitude, longitude: mapObject.longitude }, zoomLevel, center, duration, true);\r\n\t\t}\r\n\r\n\t\tlet dataItem = mapObject.dataItem;\r\n\r\n\t\tif (dataItem && $type.isNumber(dataItem.zoomLevel)) {\r\n\t\t\tzoomLevel = dataItem.zoomLevel;\r\n\t\t}\r\n\r\n\r\n\t\tif (mapObject instanceof MapPolygon) {\r\n\t\t\tlet dataItem = mapObject.dataItem;\r\n\t\t\tlet bbox = mapObject.polygon.bbox;\r\n\t\t\tif (bbox.width == 0 || bbox.height == 0) {\r\n\t\t\t\tbbox = mapObject.polygon.group.getBBox();\r\n\t\t\t}\r\n\r\n\t\t\tif (!$type.isNumber(zoomLevel)) {\r\n\t\t\t\tzoomLevel = Math.min(this.seriesWidth / bbox.width, this.seriesHeight / bbox.height);\r\n\t\t\t}\r\n\r\n\t\t\tlet geoPoint: IGeoPoint;\r\n\r\n\t\t\tif (dataItem && $type.hasValue(dataItem.zoomGeoPoint)) {\r\n\t\t\t\tgeoPoint = dataItem.zoomGeoPoint;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// this is more accurate\r\n\t\t\t\tlet polygonPoint = { x: bbox.x + bbox.width / 2, y: bbox.y + bbox.height / 2 };\r\n\t\t\t\tlet seriesPoint = $utils.spritePointToSprite(polygonPoint, mapObject.polygon, mapObject.series);\r\n\r\n\t\t\t\tgeoPoint = this.seriesPointToGeo(seriesPoint);\r\n\t\t\t}\r\n\r\n\t\t\treturn this.zoomToGeoPoint(geoPoint, zoomLevel, true, duration, true);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Zooms the map to a particular viewport.\r\n\t *\r\n\t * The `north`, `east`, `south`, and `west` define boundaries of the\r\n\t * imaginary viewort we want to zoom the map to.\r\n\t *\r\n\t * `level` is not actual zoom level. The map will determine the zoom level\r\n\t * required to accommodated such zoom, and will adjust it by `level` if set.\r\n\t *\r\n\t * @param north     Latitude of the North-most boundary\r\n\t * @param east      Longitude of the East-most boundary\r\n\t * @param south     Latitude of the South-most boundary\r\n\t * @param west      Longitude of the West-most boundary\r\n\t * @param level     Adjust zoom level\r\n\t * @param center    Center on the given coordinate?\r\n\t * @param duration  Duration for zoom animation (ms)\r\n\t * @return Zoom animation\r\n\t */\r\n\tpublic zoomToRectangle(north: number, east: number, south: number, west: number, level?: number, center?: boolean, duration?: number): Animation {\r\n\t\tif ($type.isNaN(level)) {\r\n\t\t\tlevel = 1;\r\n\t\t}\r\n\r\n\t\tlet w = $math.min(west, east);\r\n\t\tlet e = $math.max(west, east);\r\n\r\n\t\twest = w;\r\n\t\teast = e;\r\n\r\n\t\tlet splitLongitude = $math.normalizeAngle(180 - this.deltaLongitude);\r\n\t\tif (splitLongitude > 180) {\r\n\t\t\tsplitLongitude -= 360;\r\n\t\t}\r\n\r\n\t\tlet newLong = west + (east - west) / 2;\r\n\t\tlet d = (west - east);\r\n\r\n\t\tif (west < splitLongitude && east > splitLongitude) {\r\n\t\t\tnewLong += 180;\r\n\t\t\td = $math.normalizeAngle(east - west - 360);\r\n\t\t}\r\n\r\n\t\tlet zoomLevel = level * Math.min((this.south - this.north) / (south - north), Math.abs((this.west - this.east) / d));\r\n\r\n\t\treturn this.zoomToGeoPoint({ latitude: north + (south - north) / 2, longitude: newLong }, zoomLevel, center, duration, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Zooms in the map, optionally centering on particular latitude/longitude\r\n\t * point.\r\n\t *\r\n\t * @param geoPoint  Optional center point\r\n\t * @param duration  Duration for zoom animation (ms)\r\n\t * @return Zoom animation\r\n\t */\r\n\tpublic zoomIn(geoPoint?: IGeoPoint, duration?: number, sensitivity: number = 1): Animation {\r\n\t\tlet step = 1 + (this.zoomStep - 1) * sensitivity;\r\n\t\tif (step < 1) {\r\n\t\t\tstep = 1;\r\n\t\t}\r\n\t\treturn this.zoomToGeoPoint(geoPoint, this.zoomLevel * step, false, duration);\r\n\t}\r\n\r\n\t/**\r\n\t * Zooms out the map, optionally centering on particular latitude/longitude\r\n\t * point.\r\n\t *\r\n\t * @param geoPoint  Optional center point\r\n\t * @param duration  Duration for zoom animation (ms)\r\n\t * @return Zoom animation\r\n\t */\r\n\tpublic zoomOut(geoPoint?: IGeoPoint, duration?: number, sensitivity: number = 1): Animation {\r\n\t\tlet step = 1 + (this.zoomStep - 1) * sensitivity;\r\n\t\tif (step < 1) {\r\n\t\t\tstep = 1;\r\n\t\t}\r\n\t\treturn this.zoomToGeoPoint(geoPoint, this.zoomLevel / step, false, duration);\r\n\t}\r\n\r\n\t/**\r\n\t * Pans the maps using relative coordinates. E.g.:\r\n\t *\r\n\t * ```JSON\r\n\t * {\r\n\t *   x: 0.1,\r\n\t *   y: -0.1\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * The above will move the map by 10% to the right, and by 10% upwards.\r\n\t *\r\n\t * @param shift     Vertical and horizontal shift\r\n\t * @param duration  Pan animation duration (ms)\r\n\t */\r\n\tpublic pan(shift: IPoint, duration?: number): void {\r\n\t\tlet point = this.geoPointToSVG(this.zoomGeoPoint);\r\n\t\tpoint.x += this.pixelWidth * shift.x;\r\n\t\tpoint.y += this.pixelHeight * shift.y;\r\n\t\tthis.zoomToGeoPoint(this.svgPointToGeo(point), this.zoomLevel, true, duration, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Current lat/long coordinates for the center of the viewport. (default\r\n\t * zoom reference point)\r\n\t *\r\n\t * @readonly\r\n\t * @return Coordinates\r\n\t */\r\n\tpublic get zoomGeoPoint(): IGeoPoint {\r\n\t\tconst point = $utils.spritePointToSvg({ x: this.pixelWidth / 2, y: this.pixelHeight / 2 }, this);\r\n\t\treturn this.svgPointToGeo(point);\r\n\t}\r\n\r\n\t/**\r\n\t * Current zoom level.\r\n\t *\r\n\t * @readonly\r\n\t * @return Zoom level\r\n\t */\r\n\tpublic set zoomLevel(value: number) {\r\n\t\tthis.seriesContainer.scale = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Zoom level\r\n\t */\r\n\tpublic get zoomLevel(): number {\r\n\t\treturn this.seriesContainer.scale;\r\n\t}\r\n\r\n\t/**\r\n\t * Dispatches events after some map transformation, like pan or zoom.\r\n\t *\r\n\t * @ignore\r\n\t */\r\n\tprotected handleMapTransform(): void {\r\n\t\tif (this.zoomLevel != this._prevZoomLevel) {\r\n\t\t\tthis.dispatch(\"zoomlevelchanged\");\r\n\t\t\tthis._prevZoomLevel = this.zoomLevel;\r\n\t\t\tthis.svgContainer.readerAlert(this.language.translate(\"Zoom level changed to %1\", this.language.locale, $type.castString(this.zoomLevel)));\r\n\t\t}\r\n\r\n\t\tif (this.zoomGeoPoint && (this._prevZoomGeoPoint.latitude != this.zoomGeoPoint.latitude || this._prevZoomGeoPoint.longitude != this.zoomGeoPoint.longitude)) {\r\n\t\t\tthis.dispatch(\"mappositionchanged\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * A [[SmallMap]] to be used on the map.\r\n\t *\r\n\t * Please note, that accessing this property will NOT create a small map\r\n\t * if it has not yet been created. (except in JSON)\r\n\t *\r\n\t * ```TypeScript\r\n\t * // Create a small map\r\n\t * map.smallMap = new am4maps.SmallMap();\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * // Create a small map\r\n\t * map.smallMap = new am4maps.SmallMap();\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"smallMap\": {}\r\n\t *   // ...\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * @param smallMap  Small map\r\n\t */\r\n\tpublic set smallMap(smallMap: SmallMap) {\r\n\t\tif (this._smallMap) {\r\n\t\t\tthis.removeDispose(this._smallMap);\r\n\t\t}\r\n\t\tthis._smallMap = smallMap;\r\n\t\tthis._smallMap.chart = this;\r\n\t\tsmallMap.parent = this.chartContainer;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Small map\r\n\t */\r\n\tpublic get smallMap(): SmallMap {\r\n\t\tif (!this._smallMap) {\r\n\t\t\tlet smallMap: SmallMap = new SmallMap();\r\n\t\t\tthis.smallMap = smallMap;\r\n\t\t}\r\n\t\treturn this._smallMap;\r\n\t}\r\n\r\n\t/**\r\n\t * A [[ZoomControl]] to be used on the map.\r\n\t *\r\n\t * Please note, that accessing this property will NOT create a zoom control\r\n\t * if it has not yet been created. (except in JSON)\r\n\t *\r\n\t * ```TypeScript\r\n\t * // Create a zoom control\r\n\t * map.zoomControl = new am4maps.ZoomControl();\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * // Create a zoom control\r\n\t * map.zoomControl = new am4maps.ZoomControl();\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"zoomControl\": {}\r\n\t *   // ...\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * @param zoomControl  Zoom control\r\n\t */\r\n\tpublic set zoomControl(zoomControl: ZoomControl) {\r\n\t\tif (this._zoomControl) {\r\n\t\t\tthis.removeDispose(this._zoomControl);\r\n\t\t}\r\n\t\tthis._zoomControl = zoomControl;\r\n\t\tzoomControl.chart = this;\r\n\t\tzoomControl.parent = this.chartContainer;\r\n\t\tzoomControl.plusButton.exportable = false;\r\n\t\tzoomControl.minusButton.exportable = false;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Zoom control\r\n\t */\r\n\tpublic get zoomControl(): ZoomControl {\r\n\t\treturn this._zoomControl;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates and returns a map series of appropriate type.\r\n\t *\r\n\t * @return Map series\r\n\t */\r\n\tprotected createSeries(): this[\"_seriesType\"] {\r\n\t\treturn new MapSeries();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Degrees to rotate the map around vertical axis (Y).\r\n\t *\r\n\t * E.g. if set to -160, the longitude 20 will become a new center, creating\r\n\t * a Pacific-centered map.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/chart-types/map/#Map_rotation} For more info on map rotation.\r\n\t * @param  value  Rotation\r\n\t */\r\n\tpublic set deltaLongitude(value: number) {\r\n\t\tvalue = $math.round(value, 3);\r\n\t\tif (this.setPropertyValue(\"deltaLongitude\", $geo.wrapAngleTo180(value))) {\r\n\t\t\tthis.rotateMap();\r\n\t\t\tthis.updateZoomGeoPoint();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Rotation\r\n\t */\r\n\tpublic get deltaLongitude(): number {\r\n\t\treturn this.getPropertyValue(\"deltaLongitude\");\r\n\t}\r\n\r\n\t/**\r\n\t * Degrees to rotate the map around horizontal axis (X).\r\n\t *\r\n\t * E.g. setting this to 90 will put Antarctica directly in the center of\r\n\t * the map.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/chart-types/map/#Map_rotation} For more info on map rotation.\r\n\t * @since 4.3.0\r\n\t * @param  value  Rotation\r\n\t */\r\n\tpublic set deltaLatitude(value: number) {\r\n\t\tvalue = $math.round(value, 3);\r\n\t\tif (this.setPropertyValue(\"deltaLatitude\", value)) {\r\n\t\t\tthis.rotateMap();\r\n\t\t\tthis.updateZoomGeoPoint();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Rotation\r\n\t */\r\n\tpublic get deltaLatitude(): number {\r\n\t\treturn this.getPropertyValue(\"deltaLatitude\");\r\n\t}\r\n\r\n\t/**\r\n\t * Degrees to rotate the map around \"Z\" axis. This is the axis that pierces\r\n\t * the globe directly from the viewer's point of view.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/chart-types/map/#Map_rotation} For more info on map rotation.\r\n\t * @since 4.3.0\r\n\t * @param  value  Rotation\r\n\t */\r\n\tpublic set deltaGamma(value: number) {\r\n\t\tvalue = $math.round(value, 3);\r\n\t\tif (this.setPropertyValue(\"deltaGamma\", value)) {\r\n\t\t\tthis.rotateMap();\r\n\t\t\tthis.updateZoomGeoPoint();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Rotation\r\n\t */\r\n\tpublic get deltaGamma(): number {\r\n\t\treturn this.getPropertyValue(\"deltaGamma\");\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected rotateMap() {\r\n\t\tif (this.projection.d3Projection) {\r\n\t\t\tif (this.projection.d3Projection.rotate) {\r\n\t\t\t\tthis.projection.d3Projection.rotate([this.deltaLongitude, this.deltaLatitude, this.deltaGamma]);\r\n\t\t\t\tthis.invalidateProjection();\r\n\t\t\t\tthis.updateExtremes();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Maximum portion of the map's width/height to allow panning \"off screen\".\r\n\t *\r\n\t * A value of 0 (zero) will prevent any portion of the the map to be panned\r\n\t * outside the viewport.\r\n\t *\r\n\t * 0.5 will allow half of the map to be outside viewable area.\r\n\t *\r\n\t * @default 0.7\r\n\t * @param value  Max pan out\r\n\t */\r\n\tpublic set maxPanOut(value: number) {\r\n\t\tthis.setPropertyValue(\"maxPanOut\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Max pan out\r\n\t */\r\n\tpublic get maxPanOut(): number {\r\n\t\treturn this.getPropertyValue(\"maxPanOut\");\r\n\t}\r\n\r\n\t/**\r\n\t * The geographical point to center map on when it is first loaded.\r\n\t *\r\n\t * The map will also be centered to this point when you call `goHome()`\r\n\t * method.\r\n\t *\r\n\t * @param value  Home geo point\r\n\t */\r\n\tpublic set homeGeoPoint(value: IGeoPoint) {\r\n\t\tthis.setPropertyValue(\"homeGeoPoint\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Home geo point\r\n\t */\r\n\tpublic get homeGeoPoint(): IGeoPoint {\r\n\t\treturn this.getPropertyValue(\"homeGeoPoint\");\r\n\t}\r\n\r\n\t/**\r\n\t * The zoom level to put the map in when it is first loaded.\r\n\t *\r\n\t * The map will also be set to this zoom level when you call `goHome()`\r\n\t * method.\r\n\t *\r\n\t * @param value  Home zoom level\r\n\t */\r\n\tpublic set homeZoomLevel(value: number) {\r\n\t\tthis.setPropertyValue(\"homeZoomLevel\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Home zoom level\r\n\t */\r\n\tpublic get homeZoomLevel(): number {\r\n\t\treturn this.getPropertyValue(\"homeZoomLevel\");\r\n\t}\r\n\r\n\t/**\r\n\t * When user zooms in or out current zoom level is multiplied or divided\r\n\t * by value of this setting.\r\n\t *\r\n\t * @default 2\r\n\t * @param value  Zoom factor\r\n\t */\r\n\tpublic set zoomStep(value: number) {\r\n\t\tthis.setPropertyValue(\"zoomStep\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Zoom factor\r\n\t */\r\n\tpublic get zoomStep(): number {\r\n\t\treturn this.getPropertyValue(\"zoomStep\");\r\n\t}\r\n\r\n\t/**\r\n\t * Invalidates projection, causing all series to be redrawn.\r\n\t *\r\n\t * Call this after changing projection or its settings.\r\n\t */\r\n\tpublic invalidateProjection() {\r\n\t\tthis.east = undefined;\r\n\t\tthis.invalidateDataUsers();\r\n\t\tthis.updateCenterGeoPoint();\r\n\t}\r\n\r\n\t/**\r\n\t * Sets a [[DataSource]] to be used for loading Component's data.\r\n\t *\r\n\t * @param value Data source\r\n\t */\r\n\tpublic set geodataSource(value: DataSource) {\r\n\t\tif (this._dataSources[\"geodata\"]) {\r\n\t\t\tthis.removeDispose(this._dataSources[\"geodata\"]);\r\n\t\t}\r\n\t\tthis._dataSources[\"geodata\"] = value;\r\n\t\tthis._dataSources[\"geodata\"].component = this;\r\n\t\tthis.events.on(\"inited\", () => {\r\n\t\t\tthis.loadData(\"geodata\")\r\n\t\t}, this, false);\r\n\t\tthis.setDataSourceEvents(value, \"geodata\");\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a [[DataSource]] specifically for loading Component's data.\r\n\t *\r\n\t * @return Data source\r\n\t */\r\n\tpublic get geodataSource(): DataSource {\r\n\t\tif (!this._dataSources[\"geodata\"]) {\r\n\t\t\tthis.getDataSource(\"geodata\");\r\n\t\t}\r\n\t\treturn this._dataSources[\"geodata\"];\r\n\t}\r\n\r\n\t/**\r\n\t * Processes JSON-based config before it is applied to the object.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param config  Config\r\n\t */\r\n\tpublic processConfig(config?: { [index: string]: any }): void {\r\n\r\n\t\tif ($type.hasValue(config[\"geodata\"]) && $type.isString(config[\"geodata\"])) {\r\n\t\t\tconst name = config[\"geodata\"];\r\n\t\t\t// Check if there's a map loaded by such name\r\n\t\t\tif ($type.hasValue((<any>window)[\"am4geodata_\" + config[\"geodata\"]])) {\r\n\t\t\t\tconfig[\"geodata\"] = (<any>window)[\"am4geodata_\" + config[\"geodata\"]];\r\n\t\t\t}\r\n\t\t\t// Nope. Let's try maybe we got JSON as string?\r\n\t\t\telse {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconfig[\"geodata\"] = JSON.parse(config[\"geodata\"]);\r\n\t\t\t\t}\r\n\t\t\t\tcatch (e) {\r\n\t\t\t\t\t// No go again. Error out.\r\n\t\t\t\t\tthis.raiseCriticalError(Error(\"MapChart error: Geodata `\" + name + \"` is not loaded or is incorrect.\"), true);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Instantiate projection\r\n\t\tif ($type.hasValue(config[\"projection\"]) && $type.isString(config[\"projection\"])) {\r\n\t\t\tconfig[\"projection\"] = this.createClassInstance(config[\"projection\"]);\r\n\t\t}\r\n\r\n\t\t// Set up small map\r\n\t\tif ($type.hasValue(config.smallMap) && !$type.hasValue(config.smallMap.type)) {\r\n\t\t\tconfig.smallMap.type = \"SmallMap\";\r\n\t\t}\r\n\r\n\t\t// Set up zoom control\r\n\t\tif ($type.hasValue(config.zoomControl) && !$type.hasValue(config.zoomControl.type)) {\r\n\t\t\tconfig.zoomControl.type = \"ZoomControl\";\r\n\t\t}\r\n\r\n\t\tsuper.processConfig(config);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Decorates a new [[Series]] object with required parameters when it is\r\n\t * added to the chart.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param event  Event\r\n\t */\r\n\tpublic handleSeriesAdded(event: IListEvents<MapSeries>[\"inserted\"]): void {\r\n\t\tsuper.handleSeriesAdded(event);\r\n\t\tlet series = event.newValue;\r\n\t\tseries.scale = this.scaleRatio;\r\n\t\tseries.events.on(\"validated\", this.updateCenterGeoPoint, this, false);\r\n\t}\r\n\r\n\r\n\t/**\r\n \t * This function is used to sort element's JSON config properties, so that\r\n \t * some properties that absolutely need to be processed last, can be put at\r\n \t * the end.\r\n \t *\r\n \t * @ignore Exclude from docs\r\n \t * @param a  Element 1\r\n \t * @param b  Element 2\r\n \t * @return Sorting number\r\n \t */\r\n\tprotected configOrder(a: string, b: string): Ordering {\r\n\t\tif (a == b) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\t// Must come last\r\n\t\telse if (a == \"smallMap\") {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\telse if (b == \"smallMap\") {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\telse if (a == \"series\") {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\telse if (b == \"series\") {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn super.configOrder(a, b);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Adds `projection` to \"as is\" fields.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @return Assign as is?\r\n\t */\r\n\tprotected asIs(field: string): boolean {\r\n\t\treturn field == \"projection\" || field == \"geodata\" || super.asIs(field);\r\n\t}\r\n\r\n\t/**\r\n\t * Geo point of map center\r\n\t *\r\n\t * @readonly\r\n\t */\r\n\tpublic get centerGeoPoint(): IGeoPoint {\r\n\t\treturn this._centerGeoPoint;\r\n\t}\r\n\r\n\t/**\r\n\t * Resets the map to its original position and zoom level.\r\n\t *\r\n\t * Use the only parameter to set number of milliseconds for the zoom\r\n\t * animation to play.\r\n\t *\r\n\t * @param  duration  Duration (ms)\r\n\t */\r\n\tpublic goHome(duration?: number) {\r\n\t\tlet homeGeoPoint = this.homeGeoPoint;\r\n\t\tif (!homeGeoPoint) {\r\n\t\t\thomeGeoPoint = this.centerGeoPoint;\r\n\t\t}\r\n\t\tif (homeGeoPoint) {\r\n\t\t\tthis.zoomToGeoPoint(homeGeoPoint, this.homeZoomLevel, true, duration, true);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets [[Paper]] instance to use to draw elements.\r\n\t *\r\n\t * @ignore\r\n\t * @param   paper  Paper\r\n\t * @return         true if paper was changed, false, if it's the same\r\n\t */\r\n\tpublic setPaper(paper: Paper): boolean {\r\n\t\tif (this.svgContainer) {\r\n\t\t\tthis.svgContainer.hideOverflow = true;\r\n\t\t}\r\n\r\n\t\treturn super.setPaper(paper);\r\n\t}\r\n\r\n\t/**\r\n\t * Background series will create polygons that will fill all the map area\r\n\t * with some color (or other fill).\r\n\t *\r\n\t * This might be useful with non-rectangular projections, like Orthographic,\r\n\t * Albers, etc.\r\n\t *\r\n\t * To change background color/opacity access polygon template.\r\n\t *\r\n\t * ```TypeScript\r\n\t * chart.backgroundSeries.mapPolygons.template.polygon.fill = am4core.color(\"#fff\");\r\n\t * chart.backgroundSeries.mapPolygons.template.polygon.fillOpacity = 0.1;\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * chart.backgroundSeries.mapPolygons.template.polygon.fill = am4core.color(\"#fff\");\r\n\t * chart.backgroundSeries.mapPolygons.template.polygon.fillOpacity = 0.1;\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   \"backgroundSeries\": {\r\n\t *     \"mapPolygons\": {\r\n\t *       \"polygon\": {\r\n\t *         \"fill\": \"#fff\",\r\n\t *         \"fillOpacity\": 0.1\r\n\t *       }\r\n\t *     }\r\n\t *   }\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * @since 4.3.0\r\n\t */\r\n\tpublic get backgroundSeries(): MapPolygonSeries {\r\n\t\tif (!this._backgroundSeries) {\r\n\t\t\tlet backgroundSeries = new MapPolygonSeries();\r\n\t\t\tbackgroundSeries.parent = this.seriesContainer;\r\n\t\t\tbackgroundSeries.chart = this;\r\n\r\n\t\t\tbackgroundSeries.hiddenInLegend = true;\r\n\t\t\tbackgroundSeries.mapPolygons.template.focusable = false;\r\n\t\t\tbackgroundSeries.addDisposer(new Disposer(() => {\r\n\t\t\t\tthis._backgroundSeries = undefined;\r\n\t\t\t}))\r\n\t\t\tthis._disposers.push(backgroundSeries);\r\n\r\n\t\t\tlet interfaceColors = new InterfaceColorSet();\r\n\t\t\tlet color = interfaceColors.getFor(\"background\");\r\n\r\n\t\t\tlet polygonTemplate = backgroundSeries.mapPolygons.template.polygon;\r\n\t\t\tpolygonTemplate.stroke = color;\r\n\t\t\tpolygonTemplate.fill = color;\r\n\t\t\tpolygonTemplate.fillOpacity = 0;\r\n\t\t\tpolygonTemplate.strokeOpacity = 0;\r\n\t\t\t//polygonTemplate.focusable = false;\r\n\r\n\t\t\tbackgroundSeries.mapPolygons.create();\r\n\r\n\t\t\tthis._backgroundSeries = backgroundSeries;\r\n\t\t}\r\n\r\n\t\treturn this._backgroundSeries;\r\n\t}\r\n\r\n\t/**\r\n\t * Prepares the legend instance for use in this chart.\r\n\t *\r\n\t * @param legend  Legend\r\n\t */\r\n\tprotected setLegend(legend: Legend) {\r\n\t\tsuper.setLegend(legend);\r\n\t\tif (legend) {\r\n\t\t\tlegend.parent = this;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @param  value  Tap to activate?\r\n\t */\r\n\tprotected setTapToActivate(value: boolean): void {\r\n\t\tsuper.setTapToActivate(value);\r\n\t\t// setup other containers\r\n\t\tthis.seriesContainer.interactions.isTouchProtected = true;\r\n\t\tthis.panSprite.interactions.isTouchProtected = true;\r\n\t}\r\n\r\n\tprotected handleTapToActivate(): void {\r\n\t\tsuper.handleTapToActivate();\r\n\t\tthis.seriesContainer.interactions.isTouchProtected = false;\r\n\t\tthis.panSprite.interactions.isTouchProtected = false;\r\n\t}\r\n\r\n\tprotected handleTapToActivateDeactivation(): void {\r\n\t\tsuper.handleTapToActivateDeactivation();\r\n\t\tthis.seriesContainer.interactions.isTouchProtected = true;\r\n\t\tthis.panSprite.interactions.isTouchProtected = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Adds easing functions to \"function\" fields.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @return Assign as function?\r\n\t */\r\n\tprotected asFunction(field: string): boolean {\r\n\t\treturn field == \"zoomEasing\" || super.asIs(field);\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"MapChart\"] = MapChart;\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}